:py:mod:`core.fftw`
===================

.. py:module:: core.fftw


Module Contents
---------------


Functions
~~~~~~~~~

.. autoapisummary::

   core.fftw.nyquist_1D
   core.fftw.nyquist_2D
   core.fftw.nyquist_3D
   core.fftw.fft_1D
   core.fftw.ifft_1D
   core.fftw.fftc_1D
   core.fftw.ifftc_1D
   core.fftw.fft_2D
   core.fftw.ifft_2D
   core.fftw.fftc_2D
   core.fftw.ifftc_2D
   core.fftw.fftw_initialize_2D
   core.fftw.fftw_initialize_3D
   core.fftw.fft_3D
   core.fftw.ifft_3D
   core.fftw.fftc_3D
   core.fftw.ifftc_3D
   core.fftw.CreateHT
   core.fftw.HankelTransform
   core.fftw.Transform
   core.fftw.iTransform



Attributes
~~~~~~~~~~

.. autoapisummary::

   core.fftw.fft_1d
   core.fftw.ifft_1d
   core.fftw.fftc_1d
   core.fftw.ifftc_1d
   core.fftw.fft_2d
   core.fftw.ifft_2d
   core.fftw.fftc_2d
   core.fftw.ifftc_2d
   core.fftw.fft_3d
   core.fftw.ifft_3d
   core.fftw.fftc_3d
   core.fftw.ifftc_3d


.. py:function:: nyquist_1D(Z: numpy.typing.NDArray[_dc]) -> None


.. py:function:: nyquist_2D(Z: numpy.typing.NDArray[_dc]) -> None


.. py:function:: nyquist_3D(Z: numpy.typing.NDArray[_dc]) -> None


.. py:function:: fft_1D(Z: numpy.typing.NDArray[_dc]) -> None


.. py:function:: ifft_1D(Z: numpy.typing.NDArray[_dc]) -> None


.. py:function:: fftc_1D(Z: numpy.typing.NDArray[_dc]) -> None


.. py:function:: ifftc_1D(Z: numpy.typing.NDArray[_dc]) -> None


.. py:function:: fft_2D(Z: numpy.typing.NDArray[_dc]) -> None


.. py:function:: ifft_2D(Z: numpy.typing.NDArray[_dc]) -> None


.. py:function:: fftc_2D(Z: numpy.typing.NDArray[_dc]) -> None


.. py:function:: ifftc_2D(Z: numpy.typing.NDArray[_dc]) -> None


.. py:function:: fftw_initialize_2D(Z: numpy.typing.NDArray[_dc]) -> None

   API-compat stub: planning handled by SciPy/pyFFTW internally.


.. py:function:: fftw_initialize_3D(Z: numpy.typing.NDArray[_dc]) -> None

   API-compat stub: planning handled by SciPy/pyFFTW internally.


.. py:function:: fft_3D(Z: numpy.typing.NDArray[_dc]) -> None


.. py:function:: ifft_3D(Z: numpy.typing.NDArray[_dc]) -> None


.. py:function:: fftc_3D(Z: numpy.typing.NDArray[_dc]) -> None


.. py:function:: ifftc_3D(Z: numpy.typing.NDArray[_dc]) -> None


.. py:function:: CreateHT(Nr: int) -> None

   Precompute Hankel transform matrix HT(Nr, Nr) from J0 zeros.

   Fortran reference:
     HT(m,n) = (2/a(Nr+1)) * J0( a(m)*a(n) / a(Nr+1) ) / J1(a(n))**2,   m,n=1..Nr
   where a(:) are the first Nr+1 zeros of J0.

   We store a length-(Nr+1) array and a (Nr,Nr) HT in double precision.


.. py:function:: HankelTransform(f: numpy.typing.NDArray[_dc]) -> None

   Apply HT @ f in-place (f length must match HT dimension).


.. py:function:: Transform(Z: numpy.typing.NDArray[_dc]) -> None

   If Z has shape (1, Nr, Nt), apply Hankel along r and FFT along t; else FFT3D.

   Fortran logic:
       if size(Z,1) == 1:
           for k: HankelTransform(Z(1,:,k))
           for j: FFT(Z(1,j,:))
       else:
           FFT(Z)


.. py:function:: iTransform(Z: numpy.typing.NDArray[_dc]) -> None

   Inverse of Transform using ifft along t; Hankel is its own inverse for this discretization.

   Fortran logic called HankelTransform both ways; we mirror that.


.. py:data:: fft_1d

   

.. py:data:: ifft_1d

   

.. py:data:: fftc_1d

   

.. py:data:: ifftc_1d

   

.. py:data:: fft_2d

   

.. py:data:: ifft_2d

   

.. py:data:: fftc_2d

   

.. py:data:: ifftc_2d

   

.. py:data:: fft_3d

   

.. py:data:: ifft_3d

   

.. py:data:: fftc_3d

   

.. py:data:: ifftc_3d

   

