:py:mod:`PSTD3D`
================

.. py:module:: PSTD3D


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   SBEs/index.rst
   coulomb/index.rst
   dcfield/index.rst
   dephasing/index.rst
   emission/index.rst
   epsrtl/index.rst
   helpers/index.rst
   phonons/index.rst
   phost/index.rst
   qwoptics/index.rst
   rhoPJ/index.rst
   sbetestprop/index.rst
   sbetestpropnov30/index.rst
   typespace/index.rst
   usefulsubs/index.rst


Package Contents
----------------


Functions
~~~~~~~~~

.. autoapisummary::

   PSTD3D.Prop2QW
   PSTD3D.QWChi1
   PSTD3D.QW2Prop
   PSTD3D.WritePropFields
   PSTD3D.QWPolarization3
   PSTD3D.QWRho5
   PSTD3D.WriteSBESolns
   PSTD3D.InitializeQWOptics
   PSTD3D.Xcv
   PSTD3D.Ycv
   PSTD3D.Zcv
   PSTD3D.yw
   PSTD3D.FFTG
   PSTD3D.iFFTG
   PSTD3D.printITR
   PSTD3D.TotalEnergy
   PSTD3D.Temperature
   PSTD3D.WriteIt
   PSTD3D.locator
   PSTD3D.GetArray0Index
   PSTD3D.CalcI0
   PSTD3D.CalcPD
   PSTD3D.CalcVD
   PSTD3D.InitializeDC
   PSTD3D.GetEDrift
   PSTD3D.Transport
   PSTD3D.CalcI0n
   PSTD3D.WriteDephasing
   PSTD3D.CalcGammaE
   PSTD3D.CalcGammaH
   PSTD3D.OffDiagDephasing2
   PSTD3D.InitializeDephasing
   PSTD3D.CalcScreenedArrays
   PSTD3D.SetLorentzDelta
   PSTD3D.GetEps1Dqw
   PSTD3D.GetChi1Dqw
   PSTD3D.InitializeCoulomb
   PSTD3D.MBCE
   PSTD3D.MBCH
   PSTD3D.MBPH
   PSTD3D.MBPE
   PSTD3D.InitializePhonons
   PSTD3D.FermiDistr
   PSTD3D.SpontEmission
   PSTD3D.InitializeEmission
   PSTD3D.Calchw
   PSTD3D.GetSpaceArray
   PSTD3D.GetKArray
   PSTD3D.QWCalculator
   PSTD3D.Checkout
   PSTD3D.Checkin
   PSTD3D.Preparation
   PSTD3D.CalcH
   PSTD3D.chiqw
   PSTD3D.getqc
   PSTD3D.QWArea
   PSTD3D.ShutOffOptics
   PSTD3D.ReadQWParams
   PSTD3D.ReadMBParams
   PSTD3D.WriteSBEsData
   PSTD3D.ReadSBEsData
   PSTD3D.Relaxation
   PSTD3D.RelaxationE
   PSTD3D.RelaxationH
   PSTD3D.dpdt
   PSTD3D.dCdt
   PSTD3D.dDdt
   PSTD3D.write_statistics
   PSTD3D.CalcMeh
   PSTD3D.CalcWnn
   PSTD3D.CalcXqw
   PSTD3D.RecordEpsLqw
   PSTD3D.RecordXqw
   PSTD3D.GetArrays
   PSTD3D.MakeKKP
   PSTD3D.kindex
   PSTD3D.InitializeSBE
   PSTD3D.SBECalculator
   PSTD3D.FFTG
   PSTD3D.iFFTG
   PSTD3D.printIT
   PSTD3D.printIT2D
   PSTD3D.GetArray0Index
   PSTD3D.Prop2QW
   PSTD3D.QW2Prop
   PSTD3D.QWPolarization3
   PSTD3D.yw
   PSTD3D.printITReal2
   PSTD3D.WriteSBESolns
   PSTD3D.WritePLSpectrum
   PSTD3D.WriteQWFields
   PSTD3D.WritePropFields
   PSTD3D.QWRho5
   PSTD3D.printIT3D
   PSTD3D.printITReal
   PSTD3D.QWChi1
   PSTD3D.CalcQWWindow
   PSTD3D.InitializeQWOptics
   PSTD3D.CalcExpikr
   PSTD3D.Xcv
   PSTD3D.Ycv
   PSTD3D.Zcv
   PSTD3D.GetVn1n2
   PSTD3D.GetKArray
   PSTD3D.InitializeDC
   PSTD3D.CalcDCE2
   PSTD3D.CalcDCH2
   PSTD3D.CalcDCE
   PSTD3D.CalcDCH
   PSTD3D.CalcI0n
   PSTD3D.CalcI0
   PSTD3D.EkReNorm
   PSTD3D.DriftVt
   PSTD3D.Lrtz
   PSTD3D.theta
   PSTD3D.FDrift2
   PSTD3D.FDrift
   PSTD3D.ThetaEM
   PSTD3D.ThetaABS
   PSTD3D.CalcAvgCoeff
   PSTD3D.CalcVD
   PSTD3D.CalcPD
   PSTD3D.GetEDrift
   PSTD3D.GetHDrift
   PSTD3D.GetVEDrift
   PSTD3D.GetVHDrift
   PSTD3D.dndEk
   PSTD3D.ThetaEMABS
   PSTD3D.DC_Step_Scale
   PSTD3D.DC_Step_FD
   PSTD3D.ShiftN1D
   PSTD3D.ShiftN2D
   PSTD3D.Transport
   PSTD3D.K03
   PSTD3D.InitializeCoulomb
   PSTD3D.Vint
   PSTD3D.Vehint
   PSTD3D.CalcCoulombArrays
   PSTD3D.GaussDelta
   PSTD3D.MakeK3
   PSTD3D.MakeQs
   PSTD3D.MakeUnDel
   PSTD3D.SetLorentzDelta
   PSTD3D.CalcMBArrays
   PSTD3D.GetChi1Dqw
   PSTD3D.GetEps1Dqw
   PSTD3D.CalcChi1D
   PSTD3D.Eps1D
   PSTD3D.CalcScreenedArrays
   PSTD3D.CalcMVeh
   PSTD3D.undell
   PSTD3D.BGRenorm
   PSTD3D.EeRenorm
   PSTD3D.EhRenorm
   PSTD3D.MBCE2
   PSTD3D.MBCE
   PSTD3D.MBCH
   PSTD3D.InitializePhonons
   PSTD3D.MBPE
   PSTD3D.MBPH
   PSTD3D.Cq2
   PSTD3D.FermiDistr
   PSTD3D.BoseDistr
   PSTD3D.N00



Attributes
~~~~~~~~~~

.. autoapisummary::

   PSTD3D.eV
   PSTD3D.me0
   PSTD3D.hbar
   PSTD3D.e0
   PSTD3D.eps0
   PSTD3D.pi
   PSTD3D.twopi
   PSTD3D.ii
   PSTD3D.twopi
   PSTD3D.c0
   PSTD3D.hbar
   PSTD3D.eps0
   PSTD3D.ii
   PSTD3D.pi
   PSTD3D.hbar
   PSTD3D.ii
   PSTD3D.pi
   PSTD3D.twopi
   PSTD3D.hbar
   PSTD3D.eV
   PSTD3D.ii
   PSTD3D.hbar
   PSTD3D.kB
   PSTD3D.ii


.. py:function:: Prop2QW(RR, Exx, Eyy, Ezz, Vrr, Edc, R, Ex, Ey, Ez, Vr, t, xxx)

   Convert Maxwell electric fields from propagation space to QW space.

   Converts the Maxwell electric fields (Exx, Eyy, Ezz, Vrr) in
   the propagation space (RR) into the QW electric fields (Ex, Ey, Ez, Vr)
   in the QW electric field space (R). After interpolating from the RR-space
   to the R-space, the FFT from the R- to Qr-space is taken.

   :param RR: Maxwell RR spatial array, 1D array
   :type RR: ndarray
   :param Exx: Maxwell X electric field, 1D array, complex
   :type Exx: ndarray
   :param Eyy: Maxwell Y electric field, 1D array, complex
   :type Eyy: ndarray
   :param Ezz: Maxwell Z electric field, 1D array, complex
   :type Ezz: ndarray
   :param Vrr: Maxwell free charge potential, 1D array, complex
   :type Vrr: ndarray
   :param Edc: QW spatial array (modified in-place, currently unused)
   :type Edc: float
   :param R: QW spatial array, 1D array
   :type R: ndarray
   :param Ex: QW X electric field (modified in-place), 1D array, complex
   :type Ex: ndarray
   :param Ey: QW Y electric field (modified in-place), 1D array, complex
   :type Ey: ndarray
   :param Ez: QW Z electric field (modified in-place), 1D array, complex
   :type Ez: ndarray
   :param Vr: QW free charge potential (modified in-place), 1D array, complex
   :type Vr: ndarray
   :param t: Current time (s)
   :type t: float
   :param xxx: Time index
   :type xxx: int

   :returns: Ex, Ey, Ez, Vr, Edc are modified in-place
   :rtype: None

   .. rubric:: Notes

   Uses module-level variable _QWWindow for windowing.
   Fields are made real before FFT.


.. py:function:: QWChi1(lam, dky, Ee, Eh, area, geh, dcv)

   Calculate quantum wire linear susceptibility.

   Computes the frequency-dependent linear susceptibility of the quantum wire.

   :param lam: Wavelength (m)
   :type lam: float
   :param dky: Momentum step (1/m)
   :type dky: float
   :param Ee: Electron energies, 1D array
   :type Ee: ndarray
   :param Eh: Hole energies, 1D array
   :type Eh: ndarray
   :param area: Area of wire (m^2)
   :type area: float
   :param geh: Electron-hole dephasing rate (1/s)
   :type geh: float
   :param dcv: Carrier dipole moment (C m)
   :type dcv: complex

   :returns: Linear susceptibility chi^(1)
   :rtype: complex

   .. rubric:: Notes

   Uses module-level constants twopi, c0, eps0, hbar, ii.
   Formula: chi^(1) = 4 * dcv^2 / (eps0 * area) * dky / (2*pi) *
            sum((Ee+Eh) / ((Ee+Eh - i*hbar*geh - hbar*w) * (Ee+Eh + i*hbar*geh + hbar*w)))


.. py:function:: QW2Prop(r, Qr, Ex, Ey, Ez, Vr, Px, Py, Pz, re, rh, RR, Pxx, Pyy, Pzz, RhoE, RhoH, w, xxx, WriteFields, Plasmonics)

   Convert QW fields and polarizations back to propagation space.

   Converts QW electric fields, polarizations, and charge densities
   from QW space (r, Qr) back to propagation space (RR).

   :param r: QW Y-spaces, 1D array
   :type r: ndarray
   :param Qr: QW momentum space, 1D array
   :type Qr: ndarray
   :param Ex: QW X electric field (modified in-place), 1D array, complex
   :type Ex: ndarray
   :param Ey: QW Y electric field (modified in-place), 1D array, complex
   :type Ey: ndarray
   :param Ez: QW Z electric field (modified in-place), 1D array, complex
   :type Ez: ndarray
   :param Vr: QW free charge potential (modified in-place), 1D array, complex
   :type Vr: ndarray
   :param Px: QW X polarization (modified in-place), 1D array, complex
   :type Px: ndarray
   :param Py: QW Y polarization (modified in-place), 1D array, complex
   :type Py: ndarray
   :param Pz: QW Z polarization (modified in-place), 1D array, complex
   :type Pz: ndarray
   :param re: QW electron charge density (modified in-place), 1D array, complex
   :type re: ndarray
   :param rh: QW hole charge density (modified in-place), 1D array, complex
   :type rh: ndarray
   :param RR: Propagation Y-spaces, 1D array
   :type RR: ndarray
   :param Pxx: Propagation X polarization (modified in-place), 1D array, complex
   :type Pxx: ndarray
   :param Pyy: Propagation Y polarization (modified in-place), 1D array, complex
   :type Pyy: ndarray
   :param Pzz: Propagation Z polarization (modified in-place), 1D array, complex
   :type Pzz: ndarray
   :param RhoE: Propagation electron charge density (modified in-place), 1D array, complex
   :type RhoE: ndarray
   :param RhoH: Propagation hole charge density (modified in-place), 1D array, complex
   :type RhoH: ndarray
   :param w: Wire index
   :type w: int
   :param xxx: Time index
   :type xxx: int
   :param WriteFields: Record fields?
   :type WriteFields: bool
   :param Plasmonics: Calculate charge densities?
   :type Plasmonics: bool

   :returns: All input arrays are modified in-place
   :rtype: None

   .. rubric:: Notes

   Uses module-level variable _small for numerical stability.
   Charge densities are normalized if Plasmonics is True.


.. py:function:: WritePropFields(y, Ex, Ey, Ez, Vr, Px, Py, Pz, Re, Rh, sp, w, xxx)

   Write propagation field arrays to files.

   Writes propagation electric fields, polarizations, and charge densities
   to output files.

   :param y: Spatial coordinate array, 1D array
   :type y: ndarray
   :param Ex: Propagation X electric field, 1D array, complex
   :type Ex: ndarray
   :param Ey: Propagation Y electric field, 1D array, complex
   :type Ey: ndarray
   :param Ez: Propagation Z electric field, 1D array, complex
   :type Ez: ndarray
   :param Vr: Propagation free charge potential, 1D array, complex
   :type Vr: ndarray
   :param Px: Propagation X polarization, 1D array, complex
   :type Px: ndarray
   :param Py: Propagation Y polarization, 1D array, complex
   :type Py: ndarray
   :param Pz: Propagation Z polarization, 1D array, complex
   :type Pz: ndarray
   :param Re: Propagation electron charge density, 1D array, complex
   :type Re: ndarray
   :param Rh: Propagation hole charge density, 1D array, complex
   :type Rh: ndarray
   :param sp: Space label for file name
   :type sp: str
   :param w: Wire index
   :type w: int
   :param xxx: Time index
   :type xxx: int

   :rtype: None

   .. rubric:: Notes

   Uses printITReal2 to write real parts of complex fields.
   Uses printIT for charge density difference.


.. py:function:: QWPolarization3(y, ky, p, ehint, area, L, Px, Py, Pz, xxx, w)

   Calculate QW polarization in 3D.

   Computes the QW polarization components (Px, Py, Pz) from the
   density matrix p using the dipole matrix elements.

   :param y: Spatial coordinate array, 1D array
   :type y: ndarray
   :param ky: Momentum coordinate array, 1D array
   :type ky: ndarray
   :param p: Density matrix, shape (Nk, Nk), complex
   :type p: ndarray
   :param ehint: Electron-hole space integral
   :type ehint: float
   :param area: Area of wire (m^2)
   :type area: float
   :param L: Length of wire (m)
   :type L: float
   :param Px: QW X polarization (modified in-place), 1D array, complex
   :type Px: ndarray
   :param Py: QW Y polarization (modified in-place), 1D array, complex
   :type Py: ndarray
   :param Pz: QW Z polarization (modified in-place), 1D array, complex
   :type Pz: ndarray
   :param xxx: Time index
   :type xxx: int
   :param w: Wire index
   :type w: int

   :returns: Px, Py, Pz are modified in-place
   :rtype: None

   .. rubric:: Notes

   Uses module-level variables _Xvc0, _Yvc0, _Zvc0, _Expikr, _Expikrc, _QWWindow.
   Uses JIT compilation for performance-critical loops.


.. py:function:: QWRho5(Qr, kr, R, L, kkp, p, CC, DD, ne, nh, re, rh, xxx, jjj)

   Calculate quantum wire charge densities.

   Computes electron and hole charge densities in real space from
   coherence matrices CC and DD using Fourier transforms.

   :param Qr: QW momentum array, 1D array
   :type Qr: ndarray
   :param kr: QW momentum array, 1D array
   :type kr: ndarray
   :param R: QW spatial coordinate array, 1D array
   :type R: ndarray
   :param L: Length of wire (m)
   :type L: float
   :param kkp: Momentum difference index matrix, 2D array, integer
   :type kkp: ndarray
   :param p: Density matrix (unused, kept for interface compatibility), 2D array, complex
   :type p: ndarray
   :param CC: Electron/electron coherence matrix, 2D array, complex
   :type CC: ndarray
   :param DD: Hole/hole coherence matrix, 2D array, complex
   :type DD: ndarray
   :param ne: Electron occupation numbers, 1D array, complex
   :type ne: ndarray
   :param nh: Hole occupation numbers, 1D array, complex
   :type nh: ndarray
   :param re: Electron charge density (modified in-place), 1D array, complex
   :type re: ndarray
   :param rh: Hole charge density (modified in-place), 1D array, complex
   :type rh: ndarray
   :param xxx: Time index
   :type xxx: int
   :param jjj: Additional index (unused, kept for interface compatibility)
   :type jjj: int

   :returns: re and rh are modified in-place
   :rtype: None

   .. rubric:: Notes

   Uses module-level variables _Expikr, _Expikrc, _QWWindow, _small.
   Normalizes charge densities to match total electron/hole numbers.
   Removes boundary effects by subtracting average of first/last 10 points.


.. py:function:: WriteSBESolns(ky, ne, nh, C, D, P, Ee, Eh, w, xxx)

   Write SBE (Semiconductor Bloch Equations) solutions to files.

   Writes quantum wire electron/hole occupation numbers, coherence matrices,
   and energies to output files.

   :param ky: QW momentum array, 1D array
   :type ky: ndarray
   :param ne: QW electron occupation numbers, 1D array, complex
   :type ne: ndarray
   :param nh: QW hole occupation numbers, 1D array, complex
   :type nh: ndarray
   :param C: QW electron/electron coherence matrix, 2D array, complex
   :type C: ndarray
   :param D: QW hole/hole coherence matrix, 2D array, complex
   :type D: ndarray
   :param P: QW electron/hole coherence matrix, 2D array, complex
   :type P: ndarray
   :param Ee: QW electron energies, 1D array, complex
   :type Ee: ndarray
   :param Eh: QW hole energies, 1D array, complex
   :type Eh: ndarray
   :param w: Wire index
   :type w: int
   :param xxx: Time index
   :type xxx: int

   :rtype: None

   .. rubric:: Notes

   Uses printIT and printIT2D from usefulsubs to write data files.


.. py:function:: InitializeQWOptics(RR, L, dcv, kr, Qr, Ee, Eh, ehint, area, gap)

   Initialize quantum wire optics module.

   Sets up all necessary arrays and parameters for quantum wire optics
   calculations, including window functions, phase factors, and dipole
   matrix elements.

   :param RR: Spatial coordinate array, 1D array
   :type RR: ndarray
   :param L: Length of wire (m)
   :type L: float
   :param dcv: Carrier dipole moment (C m)
   :type dcv: complex
   :param kr: Momentum coordinate array, 1D array
   :type kr: ndarray
   :param Qr: Momentum coordinate array (unused, kept for interface compatibility), 1D array
   :type Qr: ndarray
   :param Ee: Electron energies, 1D array
   :type Ee: ndarray
   :param Eh: Hole energies, 1D array
   :type Eh: ndarray
   :param ehint: Electron-hole space integral
   :type ehint: float
   :param area: Area of wire (m^2)
   :type area: float
   :param gap: Band gap (J) (unused, kept for interface compatibility)
   :type gap: float

   :rtype: None

   .. rubric:: Notes

   Modifies module-level variables _QWWindow, _Expikr, _Expikrc, _dcv0, _Vol,
   _Xcv0, _Ycv0, _Zcv0, _Xvc0, _Yvc0, _Zvc0.
   Calculates dipole matrix elements Xcv0, Ycv0, Zcv0 and their conjugates.
   Uses module-level constants twopi.


.. py:function:: Xcv(k, kp)

   Get X dipole matrix element.

   Returns the X component of the dipole matrix element at indices (k, kp).

   :param k: First index (0-based in Python)
   :type k: int
   :param kp: Second index (0-based in Python)
   :type kp: int

   :returns: X dipole matrix element value
   :rtype: complex

   .. rubric:: Notes

   Uses module-level variable _Xcv0.


.. py:function:: Ycv(k, kp)

   Get Y dipole matrix element.

   Returns the Y component of the dipole matrix element at indices (k, kp).

   :param k: First index (0-based in Python)
   :type k: int
   :param kp: Second index (0-based in Python)
   :type kp: int

   :returns: Y dipole matrix element value
   :rtype: complex

   .. rubric:: Notes

   Uses module-level variable _Ycv0.


.. py:function:: Zcv(k, kp)

   Get Z dipole matrix element.

   Returns the Z component of the dipole matrix element at indices (k, kp).

   :param k: First index (0-based in Python)
   :type k: int
   :param kp: Second index (0-based in Python)
   :type kp: int

   :returns: Z dipole matrix element value
   :rtype: complex

   .. rubric:: Notes

   Uses module-level variable _Zcv0.


.. py:function:: yw(w)

   Calculate wire-dependent sign factor.

   Computes a sign factor based on the wire index.

   :param w: Wire index
   :type w: int

   :returns: Sign factor: (-1)**floor((w-1)/2)
   :rtype: int

   .. rubric:: Notes

   Used for alternating sign patterns in multi-wire systems.


.. py:function:: FFTG(F)

   FFT with Gaussian normalization.

   Performs FFT and applies Gaussian normalization: F = -FFT(F) / Nf

   :param F: Input function (complex), modified in-place, 1D array
   :type F: ndarray

   :returns: F array is modified in-place.
   :rtype: None

   .. rubric:: Notes

   Uses pyfftw for FFT computation.
   The function performs: FFTC(F) then F = -F / Nf


.. py:function:: iFFTG(F)

   IFFT with Gaussian normalization.

   Performs IFFT and applies Gaussian normalization: F = -IFFT(F) * Nf

   :param F: Input function (complex), modified in-place, 1D array
   :type F: ndarray

   :returns: F array is modified in-place.
   :rtype: None

   .. rubric:: Notes

   Uses pyfftw for IFFT computation.
   The function performs: iFFTC(F) then F = -F * Nf


.. py:function:: printITR(Dx, z, n, file)

   Print real field to file with index number.

   Writes a real 1D field array to a file with index number in filename.

   :param Dx: Field array (real), 1D array
   :type Dx: ndarray
   :param z: Spatial coordinates (real), 1D array
   :type z: ndarray
   :param n: Index number for filename
   :type n: int
   :param file: Base filename (without extension and index)
   :type file: str

   :rtype: None

   .. rubric:: Notes

   The file is written to 'dataQW/{file}{n:06d}.dat'.
   Each line contains: z(i), Dx(i)


.. py:function:: TotalEnergy(n, E)

   Calculate total energy.

   Computes total energy as real part of sum(n * E).

   :param n: Occupation numbers (complex), 1D array
   :type n: ndarray
   :param E: Energy values (real), 1D array
   :type E: ndarray

   :returns: Total energy
   :rtype: float


.. py:function:: Temperature(n, E)

   Calculate temperature from energy distribution.

   Computes temperature as 2 * AvgEnergy(n, E) / kB.

   :param n: Occupation numbers (complex), 1D array
   :type n: ndarray
   :param E: Energy values (real), 1D array
   :type E: ndarray

   :returns: Temperature (K)
   :rtype: float

   .. rubric:: Notes

   Uses Boltzmann constant kB for temperature calculation.


.. py:function:: WriteIt(V, file)

   Write array to file (interface-style wrapper).

   Automatically dispatches to WriteIT1D or WriteIT2D based on array dimensions.
   This provides a unified interface similar to Fortran's interface construct.

   :param V: Array to write (real), 1D or 2D array
   :type V: ndarray
   :param file: Base filename (without extension)
   :type file: str

   :rtype: None

   .. rubric:: Notes

   - 1D arrays: calls WriteIT1D
   - 2D arrays: calls WriteIT2D
   - Raises ValueError for unsupported array dimensions


.. py:function:: locator(x, x0)

   Find index in sorted array where value should be inserted.

   Finds the index i such that x[i] <= x0 < x[i+1] (0-based indexing).

   :param x: Sorted array (real), 1D array
   :type x: ndarray
   :param x0: Value to locate
   :type x0: float

   :returns: Index i such that x[i] <= x0 < x[i+1] (0-based)
   :rtype: int

   .. rubric:: Notes

   Uses binary search to find the insertion point.
   Returns 0 if x0 < x[0], and len(x)-2 if x0 >= x[-1].


.. py:function:: GetArray0Index(x)

   Get index of array element closest to zero.

   Finds the index where the array value is closest to zero
   by rounding and checking for zero.

   :param x: Input array (real), 1D array
   :type x: ndarray

   :returns: Index (1-based in Fortran, 0-based in Python) where value is closest to zero
   :rtype: int

   .. rubric:: Notes

   The function rounds array values and finds the first index
   where the rounded value is zero. Returns error message if not found.


.. py:function:: CalcI0(ne, nh, Ee, Eh, VC, dk, ky, I0)

   Calculate total current from electron and hole distributions.

   Computes the total current by calculating drift velocities for both
   electrons and holes, then combining them.

   :param ne: Electron occupation numbers (complex), 1D array
   :type ne: ndarray
   :param nh: Hole occupation numbers (complex), 1D array
   :type nh: ndarray
   :param Ee: Electron energies (J), 1D array
   :type Ee: ndarray
   :param Eh: Hole energies (J), 1D array
   :type Eh: ndarray
   :param VC: Interaction matrix (J), 3D array VC[:,:,2] for electrons, VC[:,:,3] for holes
   :type VC: ndarray
   :param dk: Momentum step size (1/m)
   :type dk: float
   :param ky: Momentum coordinates (1/m), 1D array (unused, kept for interface compatibility)
   :type ky: ndarray
   :param I0: Input value (unused, kept for interface compatibility)
   :type I0: float

   :returns: Total current (A)
   :rtype: float


.. py:function:: CalcPD(ky, m, n)

   Calculate momentum from distribution.

   Computes the average momentum from the carrier distribution:
   p = sum(abs(n) * hbar * ky) / sum(abs(n) + small)

   :param ky: Momentum coordinates (1/m), 1D array
   :type ky: ndarray
   :param m: Carrier mass (kg) (unused, kept for interface compatibility)
   :type m: float
   :param n: Carrier occupation numbers (complex), 1D array
   :type n: ndarray

   :returns: Average momentum (kg·m/s)
   :rtype: float


.. py:function:: CalcVD(ky, m, n)

   Calculate drift velocity from distribution.

   Computes the average drift velocity from the carrier distribution
   and momentum: v = sum(real(n) * hbar * ky / m) / sum(real(n) + small)

   :param ky: Momentum coordinates (1/m), 1D array
   :type ky: ndarray
   :param m: Carrier mass (kg)
   :type m: float
   :param n: Carrier occupation numbers (complex), 1D array
   :type n: ndarray

   :returns: Drift velocity (m/s)
   :rtype: float


.. py:function:: InitializeDC(ky, me, mh)

   Initialize the DC field module.

   Sets up all module-level arrays required for DC field calculations.
   Allocates and initializes Y, xe, xh, qinv arrays and opens output files.

   :param ky: Momentum coordinates of quantum wire (1/m), 1D array
   :type ky: ndarray
   :param me: Effective electron mass (kg)
   :type me: float
   :param mh: Effective hole mass (kg)
   :type mh: float

   :returns: All arrays are stored as module-level variables.
   :rtype: None


.. py:function:: GetEDrift()

   Get electron drift rate.

   Returns the electron temperature damping rate.

   :returns: Electron temperature damping rate (Hz)
   :rtype: float


.. py:function:: Transport(C, Edc, Eac, dt, DCTrans, k1nek2)

   Transport step for distribution matrix (legacy code).

   Performs a transport step on the distribution matrix C by shifting
   in momentum space. Can operate on the full 2D matrix or just the diagonal.

   :param C: Distribution matrix (complex), modified in-place, 2D array
   :type C: ndarray
   :param Edc: DC electric field (V/m)
   :type Edc: float
   :param Eac: AC electric field (V/m)
   :type Eac: float
   :param dt: Time step (s)
   :type dt: float
   :param DCTrans: Whether to include DC transport terms
   :type DCTrans: bool
   :param k1nek2: If True, shift the full 2D matrix; if False, shift only the diagonal
   :type k1nek2: bool

   :returns: C array is modified in-place.
   :rtype: None


.. py:function:: CalcI0n(ne, me, ky)

   Calculate electron current.

   Computes the electron current from the electron distribution and momentum.

   :param ne: Electron occupation numbers (complex), 1D array
   :type ne: ndarray
   :param me: Effective electron mass (kg)
   :type me: float
   :param ky: Momentum coordinates (1/m), 1D array
   :type ky: ndarray

   :returns: Electron current (A)
   :rtype: float


.. py:function:: WriteDephasing(ky, gamE, gamH, w, xxx)

   Write dephasing rates to files.

   Writes electron and hole dephasing rates to files with wire index.

   :param ky: Quantum wire momentum coordinates (1/m), 1D array
   :type ky: ndarray
   :param gamE: Electron diagonal dephasing rate (Hz), 1D array
   :type gamE: ndarray
   :param gamH: Hole diagonal dephasing rate (Hz), 1D array
   :type gamH: ndarray
   :param w: Wire index
   :type w: int
   :param xxx: Time index
   :type xxx: int

   :rtype: None

   .. rubric:: Notes

   Writes files to:
   - 'dataQW/Wire/Ge/Ge.{w:02d}.k.{xxx:05d}.dat' for electrons
   - 'dataQW/Wire/Gh/Gh.{w:02d}.k.{xxx:05d}.dat' for holes


.. py:function:: CalcGammaE(ky, ne0, nh0, VC, GammaE)

   Calculate electron dephasing rate.

   Computes the dephasing rate for electrons due to electron-electron
   and electron-hole interactions.

   :param ky: Momentum coordinates (1/m), 1D array
   :type ky: ndarray
   :param ne0: Electron occupation numbers (complex), 1D array
   :type ne0: ndarray
   :param nh0: Hole occupation numbers (complex), 1D array
   :type nh0: ndarray
   :param VC: Interaction matrix (J), 3D array VC[:,:,0] for e-h, VC[:,:,1] for e-e
   :type VC: ndarray
   :param GammaE: Output electron dephasing rate (modified in-place), 1D array
   :type GammaE: ndarray

   :returns: GammaE array is modified in-place.
   :rtype: None

   .. rubric:: Notes

   The function computes dephasing from:
   1. Electron-electron interactions
   2. Electron-hole interactions
   Uses extended arrays (with boundary points) for indexing safety.


.. py:function:: CalcGammaH(ky, ne0, nh0, VC, GammaH)

   Calculate hole dephasing rate.

   Computes the dephasing rate for holes due to hole-hole
   and electron-hole interactions.

   :param ky: Momentum coordinates (1/m), 1D array
   :type ky: ndarray
   :param ne0: Electron occupation numbers (complex), 1D array
   :type ne0: ndarray
   :param nh0: Hole occupation numbers (complex), 1D array
   :type nh0: ndarray
   :param VC: Interaction matrix (J), 3D array VC[:,:,0] for e-h, VC[:,:,2] for h-h
   :type VC: ndarray
   :param GammaH: Output hole dephasing rate (modified in-place), 1D array
   :type GammaH: ndarray

   :returns: GammaH array is modified in-place.
   :rtype: None

   .. rubric:: Notes

   The function computes dephasing from:
   1. Hole-hole interactions
   2. Electron-hole interactions
   Uses extended arrays (with boundary points) for indexing safety.


.. py:function:: OffDiagDephasing2(ne, nh, p, ky, Ee, Eh, g, VC, t, x)

   Calculate off-diagonal dephasing contribution (version 2).

   Computes the off-diagonal dephasing contribution to the polarization equation
   using version 2 algorithm with negative indexing support.

   :param ne: Electron occupation numbers (complex), 1D array
   :type ne: ndarray
   :param nh: Hole occupation numbers (complex), 1D array
   :type nh: ndarray
   :param p: Polarization matrix (complex), 2D array
   :type p: ndarray
   :param ky: Momentum coordinates (1/m), 1D array
   :type ky: ndarray
   :param Ee: Electron energies (J), 1D array
   :type Ee: ndarray
   :param Eh: Hole energies (J), 1D array
   :type Eh: ndarray
   :param g: Dephasing rates (Hz), 1D array [gee, ghh, geh]
   :type g: ndarray
   :param VC: Interaction matrix (J), 3D array
   :type VC: ndarray
   :param t: Time (s)
   :type t: float
   :param x: Output dephasing contribution (modified in-place), 2D array
   :type x: ndarray

   :returns: x array is modified in-place.
   :rtype: None

   .. rubric:: Notes

   The function computes dephasing from electron-electron, hole-hole,
   and electron-hole interactions. Writes max/min values to output files.


.. py:function:: InitializeDephasing(ky, me, mh)

   Initialize the dephasing module.

   Sets up all module-level arrays required for dephasing calculations.
   Allocates and initializes momentum index arrays and opens output files.

   :param ky: Momentum coordinates of quantum wire (1/m), 1D array
   :type ky: ndarray
   :param me: Effective electron mass (kg)
   :type me: float
   :param mh: Effective hole mass (kg)
   :type mh: float

   :returns: All arrays are stored as module-level variables.
   :rtype: None


.. py:function:: CalcScreenedArrays(screened, L, ne, nh, VC, E1D)

   Calculate screened Coulomb interaction arrays.

   Computes the screened version of the Coulomb interaction matrices by dividing
   by the dielectric function. If screening is disabled, returns the unscreened arrays.

   :param screened: If True, apply screening. If False, return unscreened arrays.
   :type screened: bool
   :param L: Length of the quantum wire (m)
   :type L: float
   :param ne: Electron population array, 1D array
   :type ne: ndarray
   :param nh: Hole population array, 1D array
   :type nh: ndarray
   :param VC: Input/output array for interaction matrices, shape (N, N, 3).
              On input: should contain unscreened arrays (or will be filled from module-level).
              On output: contains screened arrays if screened=True, unscreened otherwise.
   :type VC: ndarray
   :param E1D: Input/output array for dielectric function, shape (N, N).
               On input: can be any array (will be overwritten).
               On output: contains dielectric function matrix if screened=True, ones otherwise.
   :type E1D: ndarray

   :returns: Arrays are modified in-place (matching Fortran intent(inout) behavior).
   :rtype: None

   .. rubric:: Notes

   The function uses module-level variables _Veh0, _Vee0, _Vhh0, _qe, _qh
   (matching Fortran module behavior). If screening is enabled, computes the
   dielectric function and divides the interaction matrices by it.


.. py:function:: SetLorentzDelta(boolean)

   Set the LorentzDelta flag for many-body array calculations.

   This function sets a module-level flag that determines whether to use
   Lorentzian broadening (True) or Gaussian delta function (False) in
   the CalcMBArrays function.

   :param boolean: If True, use Lorentzian broadening. If False, use Gaussian delta function.
   :type boolean: bool

   .. rubric:: Notes

   This matches the Fortran interface where SetLorentzDelta sets a module-level
   variable. The flag affects the behavior of CalcMBArrays when called without
   explicitly specifying the LorentzDelta parameter.


.. py:function:: GetEps1Dqw(alphae, alphah, Delta0, epsr, me, mh, n1D, q, w)

   Calculate the 1D quantum wire dielectric function epsilon(q, w).

   Computes the real and imaginary parts of the dielectric function for a quantum wire,
   which describes how the system responds to electromagnetic fields. This is used in
   screening calculations.

   :param alphae: Level separation parameter for electrons (1/m)
   :type alphae: float
   :param alphah: Level separation parameter for holes (1/m)
   :type alphah: float
   :param Delta0: Thickness of the quantum wire (m)
   :type Delta0: float
   :param L: Length of the quantum wire (m)
   :type L: float
   :param epsr: Background dielectric constant (dimensionless)
   :type epsr: float
   :param me: Electron effective mass (kg)
   :type me: float
   :param mh: Hole effective mass (kg)
   :type mh: float
   :param n1D: 1D carrier density (1/m)
   :type n1D: float
   :param q: Momentum (1/m)
   :type q: float
   :param w: Frequency (rad/s)
   :type w: float

   :returns: (epr, epi) where:
             - epr: Real part of dielectric function (dimensionless)
             - epi: Imaginary part of dielectric function (dimensionless)
   :rtype: tuple of float

   .. rubric:: Notes

   The function computes the dielectric function using the Lindhard formula
   for a 1D system, with contributions from both electrons and holes.


.. py:function:: GetChi1Dqw(alphae, alphah, Delta0, epsr, game, gamh, ky, Ee, Eh, ne, nh, qq, w)

   Calculate the 1D quantum wire susceptibility (chi) for a given momentum and frequency.

   Computes the real and imaginary parts of the susceptibility chi(q, w) for a quantum wire,
   which describes the response of the system to external perturbations. This is used in
   screening calculations.

   :param alphae: Level separation parameter for electrons (1/m)
   :type alphae: float
   :param alphah: Level separation parameter for holes (1/m)
   :type alphah: float
   :param Delta0: Thickness of the quantum wire (m)
   :type Delta0: float
   :param L: Length of the quantum wire (m)
   :type L: float
   :param epsr: Background dielectric constant (dimensionless)
   :type epsr: float
   :param game: Electron inverse lifetime array (Hz), 1D array
   :type game: ndarray
   :param gamh: Hole inverse lifetime array (Hz), 1D array
   :type gamh: ndarray
   :param ky: Momentum coordinates of quantum wire (1/m), 1D array
   :type ky: ndarray
   :param Ee: Electron energies (J), 1D array
   :type Ee: ndarray
   :param Eh: Hole energies (J), 1D array
   :type Eh: ndarray
   :param ne: Electron population array, 1D array
   :type ne: ndarray
   :param nh: Hole population array, 1D array
   :type nh: ndarray
   :param qq: Momentum value (1/m)
   :type qq: float
   :param w: Frequency (rad/s)
   :type w: float

   :returns: (chir, chii) where:
             - chir: Real part of susceptibility (dimensionless)
             - chii: Imaginary part of susceptibility (dimensionless)
   :rtype: tuple of float

   .. rubric:: Notes

   The function computes the susceptibility by summing over momentum states,
   taking into account the energy differences and broadening due to lifetimes.
   The calculation uses the K03 Bessel function for the interaction kernel.


.. py:function:: InitializeCoulomb(y, ky, L, Delta0, me, mh, Ee, Eh, ge, gh, alphae, alphah, er, Qy, kkp, screened)

   Initialize the coulomb module and all of its needed quantities.

   This is the main initialization function that sets up all module-level arrays
   required for Coulomb interaction calculations. It calls the various setup functions
   in the correct order, checking if arrays are already initialized to avoid
   redundant calculations.

   :param y: Length coordinates of quantum wire (m), 1D array
   :type y: ndarray
   :param ky: Momentum coordinates of quantum wire (1/m), 1D array
   :type ky: ndarray
   :param L: Length of the quantum wire (m)
   :type L: float
   :param Delta0: Thickness of the quantum wire (m)
   :type Delta0: float
   :param me: Effective electron mass (kg)
   :type me: float
   :param mh: Effective hole mass (kg)
   :type mh: float
   :param Ee: Electron energies (J), 1D array
   :type Ee: ndarray
   :param Eh: Hole energies (J), 1D array
   :type Eh: ndarray
   :param ge: Inverse electron lifetime (Hz)
   :type ge: float
   :param gh: Inverse hole lifetime (Hz)
   :type gh: float
   :param alphae: Level separation between ground and 1st excited state for electrons (1/m)
   :type alphae: float
   :param alphah: Level separation between ground and 1st excited state for holes (1/m)
   :type alphah: float
   :param er: Background dielectric constant (dimensionless)
   :type er: float
   :param Qy: Momentum difference array (1/m), 1D array
   :type Qy: ndarray
   :param kkp: Index mapping array, 2D integer array. Maps (k,q) indices to Qy indices.
   :type kkp: ndarray
   :param screened: Whether to use screened interactions (not used in initialization, but passed through)
   :type screened: bool

   :returns: All arrays are stored as module-level variables (matching Fortran behavior).
   :rtype: None

   .. rubric:: Notes

   The function initializes arrays in the following order:
   1. UnDel - inverse delta function array
   2. k3 - momentum conservation indexing array
   3. qe, qh - momentum difference arrays
   4. Ceh, Cee, Chh - many-body interaction arrays (requires k3 and UnDel)
   5. Veh0, Vee0, Vhh0 - unscreened Coulomb arrays
   6. Chi1De, Chi1Dh - susceptibility arrays (requires qe and qh)

   Each array is only computed if it hasn't been initialized yet, allowing
   for incremental initialization or re-initialization with different parameters.


.. py:function:: MBCE(ne0, nh0, ky, Ee, Eh, VC, geh, ge, Win, Wout, k3=None, Ceh=None, Cee=None)

   Calculate the Many-body Coulomb In/Out rates for electrons.

   Computes the many-body relaxation rates Win and Wout for electrons due to
   electron-hole and electron-electron Coulomb interactions. This is identical
   to MBCE2 but kept as a separate function to match Fortran structure.

   :param ne0: Electron population array, shape (Nk,), real
   :type ne0: ndarray
   :param nh0: Hole population array, shape (Nk,), real
   :type nh0: ndarray
   :param ky: Momentum coordinates (not used in calculation but kept for interface compatibility)
   :type ky: ndarray
   :param Ee: Electron energies (not used in calculation but kept for interface compatibility)
   :type Ee: ndarray
   :param Eh: Hole energies (not used in calculation but kept for interface compatibility)
   :type Eh: ndarray
   :param VC: Screened Coulomb interaction matrices, shape (Nk, Nk, 3)
              VC[:, :, 0] = Veh (electron-hole)
              VC[:, :, 1] = Vee (electron-electron)
   :type VC: ndarray
   :param geh: Electron-hole inverse lifetime (not used in calculation but kept for interface)
   :type geh: float
   :param ge: Electron inverse lifetime (not used in calculation but kept for interface)
   :type ge: float
   :param Win: Input/output array for in-scattering rates, shape (Nk,), real.
               Will be modified in-place (matching Fortran intent(inout)).
   :type Win: ndarray
   :param Wout: Input/output array for out-scattering rates, shape (Nk,), real.
                Will be modified in-place (matching Fortran intent(inout)).
   :type Wout: ndarray
   :param k3: 3D indexing array from MakeK3, shape (Nk, Nk, Nk).
              If None, uses module-level _k3.
   :type k3: ndarray, optional
   :param Ceh: Electron-hole many-body interaction array, shape (Nk, Nk, Nk).
               If None, uses module-level _Ceh.
   :type Ceh: ndarray, optional
   :param Cee: Electron-electron many-body interaction array, shape (Nk, Nk, Nk).
               If None, uses module-level _Cee.
   :type Cee: ndarray, optional

   :returns: Win and Wout are modified in-place (matching Fortran intent(inout) behavior).
   :rtype: None

   .. rubric:: Notes

   Uses JIT compilation with parallel execution (matching Fortran OpenMP behavior).
   This function is identical to MBCE2 but kept separate to match Fortran code structure.


.. py:function:: MBCH(ne0, nh0, ky, Ee, Eh, VC, geh, gh, Win, Wout, k3=None, Ceh=None, Chh=None)

   Calculate the Many-body Coulomb In/Out rates for holes.

   Computes the many-body relaxation rates Win and Wout for holes due to
   electron-hole and hole-hole Coulomb interactions. These represent
   non-Hartree-Fock terms in the many-body dynamics.

   :param ne0: Electron population array, shape (Nk,), real
   :type ne0: ndarray
   :param nh0: Hole population array, shape (Nk,), real
   :type nh0: ndarray
   :param ky: Momentum coordinates (not used in calculation but kept for interface compatibility)
   :type ky: ndarray
   :param Ee: Electron energies (not used in calculation but kept for interface compatibility)
   :type Ee: ndarray
   :param Eh: Hole energies (not used in calculation but kept for interface compatibility)
   :type Eh: ndarray
   :param VC: Screened Coulomb interaction matrices, shape (Nk, Nk, 3)
              VC[:, :, 0] = Veh (electron-hole)
              VC[:, :, 2] = Vhh (hole-hole)
   :type VC: ndarray
   :param geh: Electron-hole inverse lifetime (not used in calculation but kept for interface)
   :type geh: float
   :param gh: Hole inverse lifetime (not used in calculation but kept for interface)
   :type gh: float
   :param Win: Input/output array for in-scattering rates, shape (Nk,), real.
               Will be modified in-place (matching Fortran intent(inout)).
   :type Win: ndarray
   :param Wout: Input/output array for out-scattering rates, shape (Nk,), real.
                Will be modified in-place (matching Fortran intent(inout)).
   :type Wout: ndarray
   :param k3: 3D indexing array from MakeK3, shape (Nk, Nk, Nk).
              If None, uses module-level _k3.
   :type k3: ndarray, optional
   :param Ceh: Electron-hole many-body interaction array, shape (Nk, Nk, Nk).
               If None, uses module-level _Ceh.
   :type Ceh: ndarray, optional
   :param Chh: Hole-hole many-body interaction array, shape (Nk, Nk, Nk).
               If None, uses module-level _Chh.
   :type Chh: ndarray, optional

   :returns: Win and Wout are modified in-place (matching Fortran intent(inout) behavior).
   :rtype: None

   .. rubric:: Notes

   Uses JIT compilation with parallel execution (matching Fortran OpenMP behavior).
   The function computes scattering rates due to electron-hole and hole-hole
   interactions, accounting for Pauli blocking factors (1 - n) and occupation factors n.


.. py:function:: MBPH(nh, VC, E1D, Win, Wout)

   Many-body phonon-hole interaction.

   Calculates the in-scattering and out-scattering rates for holes
   due to phonon interactions.

   :param nh: Hole carrier populations, 1D array
   :type nh: ndarray
   :param VC: Coulomb interaction array, shape (Nk, Nk, 3)
              Uses VC[:, :, 2] for hole-hole interaction (Fortran uses VC(:,:,3) which is 1-based)
   :type VC: ndarray
   :param E1D: 1D energy array, shape (Nk, Nk)
   :type E1D: ndarray
   :param Win: In-scattering rates (modified in-place), 1D array
   :type Win: ndarray
   :param Wout: Out-scattering rates (modified in-place), 1D array
   :type Wout: ndarray

   :rtype: None

   .. rubric:: Notes

   Modifies Win and Wout in-place.
   Uses module-level variables _HPT, _HP, _Vscale.


.. py:function:: MBPE(ne, VC, E1D, Win, Wout)

   Many-body phonon-electron interaction.

   Calculates the in-scattering and out-scattering rates for electrons
   due to phonon interactions.

   :param ne: Electron carrier populations, 1D array
   :type ne: ndarray
   :param VC: Coulomb interaction array, shape (Nk, Nk, 3)
              Uses VC[:, :, 1] for electron-electron interaction (Fortran uses VC(:,:,2) which is 1-based)
   :type VC: ndarray
   :param E1D: 1D energy array, shape (Nk, Nk)
   :type E1D: ndarray
   :param Win: In-scattering rates (modified in-place), 1D array
   :type Win: ndarray
   :param Wout: Out-scattering rates (modified in-place), 1D array
   :type Wout: ndarray

   :rtype: None

   .. rubric:: Notes

   Modifies Win and Wout in-place.
   Uses module-level variables _EPT, _EP, _Vscale.


.. py:function:: InitializePhonons(ky, Ee, Eh, L, epsr, Gph, Oph)

   Initialize phonon interaction matrices (Unecessary the jit version?).

   Sets up the electron and hole phonon interaction matrices EP, HP
   and their transposes EPT, HPT. Also calculates the scaling factor Vscale.

   :param ky: Momentum coordinates (1/m), 1D array
   :type ky: ndarray
   :param Ee: Electron energies (J), 1D array
   :type Ee: ndarray
   :param Eh: Hole energies (J), 1D array
   :type Eh: ndarray
   :param L: Length parameter (unused, kept for interface compatibility)
   :type L: float
   :param epsr: Dielectric constant
   :type epsr: float
   :param Gph: Phonon damping rate (Hz)
   :type Gph: float
   :param Oph: Phonon frequency (Hz)
   :type Oph: float

   :rtype: None

   .. rubric:: Notes

   Sets module-level variables:
   - _NO: Bose distribution for phonons
   - _idel: Identity exclusion matrix (1 where k != k1, 0 where k == k1)
   - _EP, _EPT: Electron phonon interaction matrix and its transpose
   - _HP, _HPT: Hole phonon interaction matrix and its transpose
   - _Vscale: Scaling constant for Coulomb interactions


.. py:function:: FermiDistr(En)

   Calculate Fermi-Dirac distribution.

   Computes the Fermi-Dirac distribution assuming host temperature
   and Fermi Energy = 0.

   :param En: Energy (J)
   :type En: float or ndarray

   :returns: Fermi-Dirac distribution value: 1 / (exp(En / (kB * T)) + 1)
   :rtype: float or ndarray

   .. rubric:: Notes

   Uses module-level variable _Temp for temperature.
   Note: Fortran returns complex type, but the value is always real, so Python returns float.


.. py:function:: SpontEmission(ne, nh, Ee, Eh, gap, geh, VC, Rsp)

   Calculate spontaneous emission rates.

   Computes the spontaneous emission rate Rsp for each momentum state
   based on electron and hole occupation numbers and energies.

   :param ne: Electron occupation numbers (complex), 1D array
   :type ne: ndarray
   :param nh: Hole occupation numbers (complex), 1D array
   :type nh: ndarray
   :param Ee: Electron energies (J), 1D array
   :type Ee: ndarray
   :param Eh: Hole energies (J), 1D array
   :type Eh: ndarray
   :param gap: Band gap energy (J)
   :type gap: float
   :param geh: Electron-hole dephasing rate (Hz) (not used, kept for signature consistency)
   :type geh: float
   :param VC: Coulomb interaction array, shape (Nk, Nk, 3)
   :type VC: ndarray
   :param Rsp: Spontaneous emission rates (modified in-place), 1D array
   :type Rsp: ndarray

   :returns: Rsp is modified in-place.
   :rtype: None


.. py:function:: InitializeEmission(ky, Ee, Eh, dcv, epsr, geh, ehint)

   Initialize the emission module.

   Sets up all module-level arrays required for emission calculations.
   Allocates and initializes the idel matrix, calculates RScale,
   and pre-calculates HOmega and square arrays.

   :param ky: Momentum coordinates of quantum wire (1/m), 1D array
   :type ky: ndarray
   :param Ee: Electron energies (J), 1D array (not used, kept for signature consistency)
   :type Ee: ndarray
   :param Eh: Hole energies (J), 1D array (not used, kept for signature consistency)
   :type Eh: ndarray
   :param dcv: Dipole matrix element (C·m)
   :type dcv: float
   :param epsr: Relative dielectric constant
   :type epsr: float
   :param geh: Electron-hole dephasing rate (Hz)
   :type geh: float
   :param ehint: Electron-hole interaction strength
   :type ehint: float

   :returns: All arrays are stored as module-level variables.
   :rtype: None


.. py:function:: Calchw(hw, PLS, Estart, Emax)

   Calculate photon energy array for PL spectrum.

   Sets up the photon energy array hw for photoluminescence spectrum
   calculations.

   :param hw: Photon energy array (modified in-place), 1D array
   :type hw: ndarray
   :param PLS: PL spectrum array (initialized to zero), 1D array
   :type PLS: ndarray
   :param Estart: Starting energy (J)
   :type Estart: float
   :param Emax: Maximum energy (J)
   :type Emax: float

   :returns: hw and PLS are modified in-place.
   :rtype: None


.. py:function:: GetSpaceArray(N, L)

   Generate a real-space position array.

   Creates an array of N positions evenly spaced across a window of width L,
   centered at zero. The positions range from -L/2 to L/2.

   :param N: Number of points
   :type N: int
   :param L: Total width of the window (m)
   :type L: float

   :returns: Array of position values (m), 1D array of length N
   :rtype: ndarray

   .. rubric:: Notes

   The array is centered at zero, so positions range from -L/2 to L/2.
   For N=1, returns array with single value 0.0.

   This function is not defined in typespace.f90 but is used by GetXArray,
   GetYArray, and GetZArray. It is likely defined in the helpers module
   in Fortran. The implementation matches usage patterns in other Fortran files
   (e.g., GetSpaceArray(Ny, (Ny-1) * dyy) in pstd.f90).


.. py:function:: GetKArray(Nk, L)

   Generate k-space array for Fourier transforms.

   Creates an array of Nk k-values (momentum values) for use with FFT.
   The array is centered at zero and spaced by dk = twopi/L.

   :param Nk: Number of k-space points
   :type Nk: int
   :param L: Length of the spatial domain (m)
   :type L: float

   :returns: Array of k values (1/m), 1D array of length Nk
   :rtype: ndarray

   .. rubric:: Notes

   The k-values are centered at zero, suitable for FFT operations.
   For Nk=1, returns array with single value 0.0.

   This function is not defined in typespace.f90 but is used by GetKxArray,
   GetKyArray, and GetKzArray. It is likely defined in the helpers module
   in Fortran. The implementation matches usage patterns in other Fortran files.


.. py:data:: eV
   :value: 1.602176634e-19

   

.. py:data:: me0

   

.. py:data:: hbar

   

.. py:data:: e0

   

.. py:data:: eps0

   

.. py:data:: pi

   

.. py:data:: twopi

   

.. py:data:: ii
   :value: 1j

   

.. py:function:: QWCalculator(Exx, Eyy, Ezz, Vrr, rr, q, dt, w, Pxx, Pyy, Pzz, Rho, DoQWP, DoQWDl)

   Time-evolve the source terms of the quantum wire for Maxwell's equations.

   Solves the 1D Semiconductor Bloch equations and calculates polarization
   and charge density source terms for propagation simulations.

   :param Exx: X-component total electric field in propagation space
   :type Exx: ndarray (complex)
   :param Eyy: Y-component total electric field in propagation space
   :type Eyy: ndarray (complex)
   :param Ezz: Z-component electric field in propagation space
   :type Ezz: ndarray (complex)
   :param Vrr: Potential electric field in propagation space
   :type Vrr: ndarray (complex)
   :param rr: QW spatial array (m)
   :type rr: ndarray (float)
   :param q: QW momentum array (1/m)
   :type q: ndarray (float)
   :param dt: Time step (s)
   :type dt: float
   :param w: Wire index (which wire to calculate for)
   :type w: int
   :param Pxx: X polarization output (modified in-place)
   :type Pxx: ndarray (complex)
   :param Pyy: Y polarization output (modified in-place)
   :type Pyy: ndarray (complex)
   :param Pzz: Z polarization output (modified in-place)
   :type Pzz: ndarray (complex)
   :param Rho: Free charge density output (modified in-place)
   :type Rho: ndarray (complex)
   :param DoQWP: Boolean flag [should propagator use QW polarization] (modified in-place)
   :type DoQWP: list
   :param DoQWDl: Boolean flag [should propagator use longitudinal field] (modified in-place)
   :type DoQWDl: list

   :returns: All outputs are modified in-place
   :rtype: None

   .. rubric:: Notes

   This function:
   - Updates module-level time counters (xxx, jjj, t)
   - Allocates arrays on first call
   - Calls Prop2QW to convert propagation fields to QW fields
   - Calls SBECalculator to solve the SBEs
   - Calls QW2Prop to convert back to propagation space
   - Calculates energy transfer and writes to files
   - Only activates when field is strong enough (controlled by _wireoff)


.. py:function:: Checkout(p1, p2, C1, C2, D1, D2, w)

   Check out coherence matrices from module storage for wire w.

   Retrieves previous time steps from module-level arrays for processing.


.. py:function:: Checkin(p1, p2, p3, C1, C2, C3, D1, D2, D3, w)

   Check in updated coherence matrices to module storage for wire w.

   Stores current and future time steps to module-level arrays.


.. py:function:: Preparation(p2, C2, D2, Ex, Ey, Ez, Vr, w, Heh, Hee, Hhh, VC, E1D, GamE, GamH, OffG, Rsp)

   Prepare Hamiltonians, screening, and dephasing arrays for SBE time step.

   This function calculates all the arrays needed for one time step of the
   semiconductor Bloch equations:
   - Dipole coupling matrix M^{eh} (light-matter interaction)
   - Monopole coupling matrices W^{ee}, W^{hh} (free-carrier potentials)
   - Hamiltonian matrices H^{eh}, H^{ee}, H^{hh} (including many-body effects)
   - Screened Coulomb interaction arrays VC, E1D
   - Diagonal dephasing rates γ_e, γ_h
   - Off-diagonal dephasing rates Γ^{off}
   - Spontaneous emission rates R_sp

   :param p2: Electron-hole coherence matrix at previous time step
   :type p2: ndarray (complex), shape (Nk, Nk)
   :param C2: Electron-electron coherence matrix at previous time step
   :type C2: ndarray (complex), shape (Nk, Nk)
   :param D2: Hole-hole coherence matrix at previous time step
   :type D2: ndarray (complex), shape (Nk, Nk)
   :param Ex: Electric field components in momentum space
   :type Ex: ndarray (complex), shape (Nr,)
   :param Ey: Electric field components in momentum space
   :type Ey: ndarray (complex), shape (Nr,)
   :param Ez: Electric field components in momentum space
   :type Ez: ndarray (complex), shape (Nr,)
   :param Vr: Electric potential from free charge in momentum space
   :type Vr: ndarray (complex), shape (Nr,)
   :param w: Wire index
   :type w: int
   :param Heh: Electron-hole Hamiltonian (output, modified in-place)
   :type Heh: ndarray (complex), shape (Nk, Nk)
   :param Hee: Electron-electron Hamiltonian (output, modified in-place)
   :type Hee: ndarray (complex), shape (Nk, Nk)
   :param Hhh: Hole-hole Hamiltonian (output, modified in-place)
   :type Hhh: ndarray (complex), shape (Nk, Nk)
   :param VC: Screened Coulomb arrays (output, modified in-place)
   :type VC: ndarray (float), shape (Nr, Nr, 3)
   :param E1D: 1D dielectric screening array (output, modified in-place)
   :type E1D: ndarray (float), shape (Nk, Nk)
   :param GamE: Electron diagonal dephasing rates (output, modified in-place)
   :type GamE: ndarray (float), shape (Nk,)
   :param GamH: Hole diagonal dephasing rates (output, modified in-place)
   :type GamH: ndarray (float), shape (Nk,)
   :param OffG: Off-diagonal dephasing arrays (output, modified in-place)
   :type OffG: ndarray (complex), shape (Nk, Nk, 3)
   :param Rsp: Spontaneous emission rates (output, modified in-place)
   :type Rsp: ndarray (float), shape (Nk,)

   :returns: All output arrays are modified in-place.
   :rtype: None

   .. rubric:: Notes

   The preparation sequence:
   1. Initialize all arrays to zero/defaults
   2. Extract carrier populations ne, nh from diagonal of C, D
   3. Calculate dipole coupling M^{eh} if optics enabled
   4. Calculate monopole coupling W^{ee}, W^{hh} if longitudinal field enabled
   5. Calculate screened Coulomb arrays VC, E1D
   6. Calculate Hamiltonian matrices H^{eh}, H^{ee}, H^{hh}
   7. Calculate diagonal dephasing γ_e, γ_h if enabled
   8. Calculate off-diagonal dephasing Γ^{off} if enabled
   9. Calculate spontaneous emission rates R_sp if enabled

   The Hamiltonian includes:
   - Single-particle energies (diagonal)
   - Light-matter coupling (via M^{eh})
   - Coulomb many-body effects (via VC)
   - Excitonic correlations (if _Excitons=True)

   Module flags control which effects are included:
   - _Optics: optical field coupling
   - _LF: longitudinal field effects
   - _FreePot: free potential effects
   - _Excitons: excitonic correlations
   - _DiagDph: diagonal dephasing
   - _OffDiagDph: off-diagonal dephasing
   - _Recomb: spontaneous recombination

   .. seealso::

      :obj:`CalcMeh`
          Dipole coupling matrix

      :obj:`CalcWnn`
          Monopole coupling matrix

      :obj:`CalcH`
          Hamiltonian calculation

      :obj:`CalcScreenedArrays`
          Screened Coulomb arrays

      :obj:`CalcGammaE`, :obj:`CalcGammaH`

      :obj:`OffDiagDephasing2`
          Off-diagonal dephasing

      :obj:`SpontEmission`
          Spontaneous emission rates


.. py:function:: CalcH(Meh, Wee, Whh, C, D, p, VC, Heh, Hee, Hhh)

   Calculate the Hamiltonian matrices for the semiconductor Bloch equations.

   Constructs the effective Hamiltonian matrices that appear in the SBEs,
   including single-particle energies, light-matter coupling, Coulomb many-body
   effects, and excitonic correlations.

   The Hamiltonians govern the coherent dynamics:
   - H^{eh}: electron-hole Hamiltonian (drives optical polarization)
   - H^{ee}: electron-electron Hamiltonian (drives electron coherence)
   - H^{hh}: hole-hole Hamiltonian (drives hole coherence)

   :param Meh: Dipole-field coupling matrix M^{eh}_{k_e,k_h}
   :type Meh: ndarray (complex), shape (Nk, Nk)
   :param Wee: Electron monopole-potential coupling W^{ee}_{k1,k2}
   :type Wee: ndarray (complex), shape (Nk, Nk)
   :param Whh: Hole monopole-potential coupling W^{hh}_{k1,k2}
   :type Whh: ndarray (complex), shape (Nk, Nk)
   :param C: Electron-electron coherence matrix
   :type C: ndarray (complex), shape (Nk, Nk)
   :param D: Hole-hole coherence matrix
   :type D: ndarray (complex), shape (Nk, Nk)
   :param p: Electron-hole coherence matrix (interband polarization)
   :type p: ndarray (complex), shape (Nk, Nk)
   :param VC: Screened Coulomb interaction arrays
   :type VC: ndarray (float), shape (Nr, Nr, 3)
   :param Heh: Output: electron-hole Hamiltonian (modified in-place)
   :type Heh: ndarray (complex), shape (Nk, Nk)
   :param Hee: Output: electron-electron Hamiltonian (modified in-place)
   :type Hee: ndarray (complex), shape (Nk, Nk)
   :param Hhh: Output: hole-hole Hamiltonian (modified in-place)
   :type Hhh: ndarray (complex), shape (Nk, Nk)

   :returns: Hamiltonians Heh, Hee, Hhh are modified in-place.
   :rtype: None

   .. rubric:: Notes

   The Hamiltonians are constructed as:

   H^{eh}_{k_e,k_h} = M^{eh}_{k_e,k_h} + Σ_q V(q) p^†_{k_e+q,k_h+q}

   H^{ee}_{k1,k2} = E_e(k1)δ_{k1,k2} + W^{ee}_{k1,k2}
                   - Σ_q V_ee(q) C^†_{k1+q,k2+q}
                   + Σ_k [V_ee(q)C_{k,k+q} - V_eh(q)D_{k+q,k}] (q = k1-k2)

   H^{hh}_{k1,k2} = E_h(k1)δ_{k1,k2} + W^{hh}_{k1,k2}
                   - Σ_q V_hh(q) D^†_{k1+q,k2+q}
                   + Σ_k [V_hh(q)D_{k,k+q} - V_eh(q)C_{k+q,k}] (q = k1-k2)

   where:
   - V(q) is the screened Coulomb interaction
   - q is momentum transfer
   - † denotes transpose (not conjugate transpose here)

   The excitonic terms (involving V and coherence matrices) are included
   only if _Excitons=True.

   If _LF=True (longitudinal field), off-diagonal Coulomb exchange terms
   are included. If _LF=False, only diagonal terms (k1=k2) are included,
   which is the Hartree-Fock approximation.

   The noq0 array excludes q=0 terms to avoid divergences in the Coulomb
   interaction.

   Loop ranges max(1-k1, 1-k2) to min(Nk-k1, Nk-k2) ensure that k+q
   stays within array bounds [1, Nk] in Fortran (or [0, Nk-1] in Python).

   .. seealso::

      :obj:`Preparation`
          Calls this function to set up Hamiltonians

      :obj:`CalcMeh`
          Calculates dipole coupling M^{eh}

      :obj:`CalcWnn`
          Calculates monopole coupling W^{nn}

      :obj:`dpdt`, :obj:`dCdt`, :obj:`dDdt`


.. py:function:: chiqw()

   Get the current linear optical susceptibility χ(ω).

   Returns the module-level variable _chiw which stores the linear
   susceptibility at the current frequency.

   :returns: **chi** -- Linear optical susceptibility χ(ω) (dimensionless).
   :rtype: complex

   .. rubric:: Notes

   This is a simple accessor function that returns the stored value.
   The susceptibility is calculated elsewhere (e.g., in QWChi1 or CalcXqw)
   and stored in _chiw.

   .. seealso::

      :obj:`getqc`
          Get critical momentum

      :obj:`QWChi1`
          Calculate linear susceptibility (qwoptics module)

      :obj:`CalcXqw`
          Calculate susceptibility at given (q,ω)


.. py:function:: getqc()

   Get the critical momentum q_c.

   Returns the module-level variable _qc which stores the critical
   momentum for some physical process (e.g., plasmon cutoff, screening length).

   :returns: **qc** -- Critical momentum q_c (rad/m).
   :rtype: float

   .. rubric:: Notes

   This is a simple accessor function that returns the stored value.
   The critical momentum is calculated elsewhere and stored in _qc.

   Physical interpretation depends on context:
   - Plasmon physics: momentum where plasmon dispersion changes character
   - Screening: inverse screening length (q_c ≈ 1/λ_screen)
   - Phase transitions: critical wave vector

   .. seealso::

      :obj:`chiqw`
          Get linear susceptibility


.. py:function:: QWArea()

   Get the quantum wire cross-sectional area.

   Returns the module-level variable _area which stores the quantum wire
   cross-sectional area.

   :returns: **area** -- Quantum wire cross-sectional area (m²).
   :rtype: float

   .. rubric:: Notes

   This is a simple accessor function. The area is set during initialization
   and represents the effective cross-sectional area of the quantum wire.

   The area affects:
   - Carrier density normalization
   - Optical transition strengths
   - Coulomb interaction strengths

   .. seealso::

      :obj:`ReadQWParams`
          Reads quantum wire parameters including area


.. py:function:: ShutOffOptics()

   Disable optical coupling in the SBE calculations.

   Sets the module-level flag _Optics to False, which disables the
   light-matter interaction terms in the Hamiltonian. This is useful
   for studying purely electronic dynamics without optical fields.

   :rtype: None

   .. rubric:: Notes

   When _Optics is False:
   - Dipole coupling matrix M^{eh} is not calculated
   - Only electronic Coulomb interactions remain
   - Useful for equilibration or dark dynamics

   To re-enable optics, set _Optics = True directly.

   .. seealso::

      :obj:`Preparation`
          Uses _Optics flag to conditionally calculate coupling

      :obj:`CalcMeh`
          Dipole coupling (only called if _Optics=True)


.. py:function:: ReadQWParams()

   Read quantum wire parameters from 'params/qw.params' file.

   Loads fundamental physical parameters of the quantum wire system from
   a parameter file and converts units where necessary. Sets module-level
   variables used throughout the SBE calculations.

   File Format
   -----------
   params/qw.params should contain one parameter per line:
       L       - Wire length (m)
       Delta0  - Wire thickness (m)
       gap     - Band gap (eV, converted to J)
       me      - Electron effective mass (units of me0)
       mh      - Hole effective mass (units of me0)
       HO      - Energy level separation (eV, converted to J)
       gam_e   - Electron dephasing rate (Hz)
       gam_h   - Hole dephasing rate (Hz)
       gam_eh  - Interband dephasing rate (Hz)
       epsr    - Relative permittivity (dimensionless)
       Oph     - Phonon energy (eV, converted to Hz)
       Gph     - Phonon damping rate (eV, converted to Hz)
       Edc     - DC electric field (V/m)
       jmax    - Output interval (time steps)
       ntmax   - Maximum time steps

   :returns: Module-level variables are set.
   :rtype: None

   .. rubric:: Notes

   Unit conversions performed:
   - gap: eV → J (multiply by e0)
   - me, mh: units of me0 → kg (multiply by me0)
   - HO: eV → J (multiply by e0)
   - Oph: eV → Hz (multiply by e0/hbar)
   - Gph: eV → Hz (multiply by e0/hbar)

   Module variables set:
   _L, _Delta0, _gap, _me, _mh, _HO, _gam_e, _gam_h, _gam_eh,
   _epsr, _Oph, _Gph, _Edc, _jmax, _ntmax

   .. seealso::

      :obj:`ReadMBParams`
          Read many-body physics flags


.. py:function:: ReadMBParams()

   Read many-body physics control flags from 'params/mb.params' file.

   Loads boolean flags that control which physical effects are included
   in the many-body semiconductor Bloch equation calculations. Also sets
   the Lorentzian delta function flag for numerical integration.

   File Format
   -----------
   params/mb.params should contain one flag per line (T/F or 1/0):
       Optics       - Include optical field coupling
       Excitons     - Include excitonic correlations
       EHs          - Include carrier-carrier scattering
       Screened     - Use screened Coulomb interaction
       Phonon       - Include phonon scattering
       DCTrans      - Include DC transport
       LF           - Include longitudinal field
       FreePot      - Include free potential
       DiagDph      - Include diagonal dephasing
       OffDiagDph   - Include off-diagonal dephasing
       Recomb       - Include spontaneous recombination
       PLSpec       - Calculate photoluminescence spectrum
       ignorewire   - Ignore wire effects
       Xqwparams    - Write susceptibility parameters
       LorentzDelta - Use Lorentzian delta function

   :returns: Module-level flags are set.
   :rtype: None

   .. rubric:: Notes

   These flags provide fine-grained control over the physics:

   - _Optics: Enable/disable light-matter interaction
   - _Excitons: Include excitonic Coulomb correlations in Hamiltonian
   - _EHs: Include carrier-carrier scattering (MBCE, MBCH)
   - _screened: Use screened vs bare Coulomb interaction
   - _Phonon: Include carrier-phonon scattering (MBPE, MBPH)
   - _DCTrans: Include DC transport and drift
   - _LF: Include longitudinal field (plasmons, screening)
   - _FreePot: Include free-carrier potential
   - _DiagDph: Momentum-dependent dephasing rates
   - _OffDiagDph: Off-diagonal dephasing (correlations)
   - _Recomb: Spontaneous electron-hole recombination
   - _PLSpec: Track photoluminescence
   - _ignorewire: Single-wire approximation
   - _Xqwparams: Write χ(q,ω) parameter file

   The LorentzDelta flag is passed to SetLorentzDelta in the coulomb module
   to control numerical delta function representation.

   .. seealso::

      :obj:`ReadQWParams`
          Read physical parameters

      :obj:`SetLorentzDelta`
          Set delta function representation (coulomb module)


.. py:function:: WriteSBEsData(n)

   Write SBE coherence matrices to backup files.

   Saves the current state of all coherence matrices (electron-hole,
   electron-electron, hole-hole) at three time steps to disk for backup
   or restart purposes.

   :param n: File index for output filenames (e.g., n=100 creates CC1.100.dat)
   :type n: int

   :returns: * *None* -- Data is written to files in 'dataQW/backup/' directory.
             * *Files Created*
             * *-------------*
             * *For each time step (1, 2, 3) and each matrix type (CC, DD, YY)* -- dataQW/backup/CC1.{n}.dat - Electron coherence, step 1
               dataQW/backup/CC2.{n}.dat - Electron coherence, step 2
               dataQW/backup/CC3.{n}.dat - Electron coherence, step 3
               dataQW/backup/DD1.{n}.dat - Hole coherence, step 1
               dataQW/backup/DD2.{n}.dat - Hole coherence, step 2
               dataQW/backup/DD3.{n}.dat - Hole coherence, step 3
               dataQW/backup/YY1.{n}.dat - e-h coherence, step 1
               dataQW/backup/YY2.{n}.dat - e-h coherence, step 2
               dataQW/backup/YY3.{n}.dat - e-h coherence, step 3
             * *Data Format*
             * *-----------*
             * *Each file contains complex values written as* -- real_part imaginary_part
             * *One matrix element per line, nested loops over wire, k2, k1.*

   .. rubric:: Notes

   The three time steps correspond to the leapfrog integration scheme:
   - Step 1: Previous time (t - dt)
   - Step 2: Current time (t)
   - Step 3: Next time (t + dt)

   Data is written for all wires and all momentum indices.

   File size scales as: Nwires × Nk × Nk × 2 (complex) × 3 (time steps) × 9 (matrices)

   .. seealso::

      :obj:`ReadSBEsData`
          Read coherence matrices from backup files

      :obj:`Checkin`, :obj:`Checkout`


.. py:function:: ReadSBEsData(Nt)

   Read SBE coherence matrices from backup files.

   Loads the saved state of all coherence matrices (electron-hole,
   electron-electron, hole-hole) at three time steps from disk for
   restart or analysis purposes.

   :param Nt: File index for input filenames (e.g., Nt=100 reads CC1.100.dat)
   :type Nt: int

   :returns: * *None* -- Module-level arrays _CC1, _CC2, _CC3, _DD1, _DD2, _DD3,
               _YY1, _YY2, _YY3 are updated.
             * *Files Read*
             * *----------*
             * *For each time step (1, 2, 3) and each matrix type (CC, DD, YY)* -- dataQW/backup/CC1.{Nt}.dat - Electron coherence, step 1
               dataQW/backup/CC2.{Nt}.dat - Electron coherence, step 2
               dataQW/backup/CC3.{Nt}.dat - Electron coherence, step 3
               dataQW/backup/DD1.{Nt}.dat - Hole coherence, step 1
               dataQW/backup/DD2.{Nt}.dat - Hole coherence, step 2
               dataQW/backup/DD3.{Nt}.dat - Hole coherence, step 3
               dataQW/backup/YY1.{Nt}.dat - e-h coherence, step 1
               dataQW/backup/YY2.{Nt}.dat - e-h coherence, step 2
               dataQW/backup/YY3.{Nt}.dat - e-h coherence, step 3
             * *Data Format*
             * *-----------*
             * *Each file contains complex values as* -- real_part imaginary_part
             * *One matrix element per line, nested loops over wire, k2, k1.*

   .. rubric:: Notes

   This function is used to restart simulations from a saved state.
   The data must match the current grid dimensions (Nk, Nwires).

   The three time steps enable continuation of the leapfrog integration
   without loss of temporal accuracy.

   After reading, the simulation can continue from time Nt·dt using
   the loaded coherence matrices.

   .. seealso::

      :obj:`WriteSBEsData`
          Write coherence matrices to backup files

      :obj:`Checkin`, :obj:`Checkout`


.. py:function:: Relaxation(ne, nh, VC, E1D, Rsp, dt, w, WriteFields)

   Apply phonon scattering and carrier-carrier relaxation to electron and hole populations.

   This function calculates the time evolution of carrier populations due to
   many-body scattering processes including:
   - Electron-electron scattering
   - Hole-hole scattering
   - Electron-hole scattering
   - Electron-phonon scattering
   - Hole-phonon scattering
   - Spontaneous electron-hole recombination

   The scattering rates are calculated using many-body perturbation theory
   and applied using an exact exponential solution to the rate equations.

   :param ne: Electron occupation numbers for each momentum state k.
              Modified in-place to apply relaxation effects.
   :type ne: ndarray (complex), shape (Nk,)
   :param nh: Hole occupation numbers for each momentum state k.
              Modified in-place to apply relaxation effects.
   :type nh: ndarray (complex), shape (Nk,)
   :param VC: Real-time screened Coulomb interaction arrays.
              VC[:,:,0] - electron-hole interaction
              VC[:,:,1] - electron-electron interaction
              VC[:,:,2] - hole-hole interaction
   :type VC: ndarray (float), shape (Nk, Nk, 3)
   :param E1D: Real-time 1D dielectric screening array used for carrier-photon
               coupling calculations.
   :type E1D: ndarray (float), shape (Nk, Nk)
   :param Rsp: Spontaneous emission rate for each momentum state (Hz).
               Used if _Recomb is True.
   :type Rsp: ndarray (float), shape (Nk,)
   :param dt: Time step for integration (seconds).
   :type dt: float
   :param w: Wire index identifying which quantum wire is being calculated.
   :type w: int
   :param WriteFields: If True, write scattering rates to output files via printITR.
   :type WriteFields: bool

   :returns: ne and nh are modified in-place.
   :rtype: None

   .. rubric:: Notes

   The carrier population evolution is governed by:

   dn_e/dt = W_in^e * (1 - n_e) - W_out^e * n_e
   dn_h/dt = W_in^h * (1 - n_h) - W_out^h * n_h

   where W_in and W_out are the in-scattering and out-scattering rates.

   This is solved exactly as:
   n(t+dt) = exp(-W*dt) * [(-1 + exp(W*dt) + n)*W_in + n*W_out] / W
   where W = W_in + W_out

   This exponential solution is more accurate than a simple Euler step and
   remains stable even for large time steps or scattering rates.

   If spontaneous recombination is enabled (_Recomb=True), an additional
   decay is applied:
   n_e(t+dt) = n_e * exp(-R_sp * n_h * dt)
   n_h(t+dt) = n_h * exp(-R_sp * n_e * dt)

   The scattering rates are calculated by RelaxationE and RelaxationH which
   call the many-body perturbation theory functions MBPE and MBPH from the
   phonons module.

   Possible Modifications
   -----
   WinE, WoutE, WinH, WoutH could be inplace arguments.

   .. rubric:: Examples

   >>> ne = np.array([0.1, 0.2, 0.3], dtype=complex)
   >>> nh = np.array([0.1, 0.2, 0.3], dtype=complex)
   >>> VC = np.zeros((3, 3, 3))
   >>> E1D = np.zeros((3, 3))
   >>> Rsp = np.zeros(3)
   >>> Relaxation(ne, nh, VC, E1D, Rsp, 1e-15, 0, False)


.. py:function:: RelaxationE(ne, nh, VC, E1D)

   Calculate electron relaxation rates using many-body perturbation theory.

   Computes in-scattering (W_in) and out-scattering (W_out) rates for electrons
   due to:
   - Carrier-carrier scattering (electron-electron, electron-hole)
   - Carrier-phonon scattering (electron-LO phonon, electron-acoustic phonon)

   The rates are calculated using second-order Born approximation within the
   screened Hartree-Fock approximation, accounting for Pauli blocking factors.

   :param ne: Electron occupation numbers for each momentum state
   :type ne: ndarray (complex), shape (Nk,)
   :param nh: Hole occupation numbers for each momentum state
   :type nh: ndarray (complex), shape (Nk,)
   :param VC: Screened Coulomb interaction matrices
   :type VC: ndarray (float), shape (Nk, Nk, 3)
   :param E1D: One-dimensional dielectric screening array
   :type E1D: ndarray (float), shape (Nk, Nk)

   :returns: * **WinE** (*ndarray (float), shape (Nk,)*) -- In-scattering rate into each electron state (Hz).
               W_in^e(k) represents the rate of scattering INTO state k.
             * **WoutE** (*ndarray (float), shape (Nk,)*) -- Out-scattering rate from each electron state (Hz).
               W_out^e(k) represents the rate of scattering OUT OF state k.

   .. rubric:: Notes

   The scattering rates satisfy detailed balance and ensure proper
   thermalization. Pauli exclusion is enforced through (1-n_e) factors.

   Calls MBPE (Many-Body Perturbation theory for Electrons) from the phonons
   module, which implements the full quantum kinetic theory calculation.

   Possible Modifications
   -----
   WinE and WoutE could be inplace arguments.

   .. seealso::

      :obj:`RelaxationH`
          Equivalent calculation for holes

      :obj:`MBPE`
          The underlying many-body calculation (in phonons module)


.. py:function:: RelaxationH(ne, nh, VC, E1D)

   Calculate hole relaxation rates using many-body perturbation theory.

   Computes in-scattering (W_in) and out-scattering (W_out) rates for holes
   due to:
   - Carrier-carrier scattering (hole-hole, hole-electron)
   - Carrier-phonon scattering (hole-LO phonon, hole-acoustic phonon)

   The rates are calculated using second-order Born approximation within the
   screened Hartree-Fock approximation, accounting for Pauli blocking factors.

   :param ne: Electron occupation numbers for each momentum state
   :type ne: ndarray (complex), shape (Nk,)
   :param nh: Hole occupation numbers for each momentum state
   :type nh: ndarray (complex), shape (Nk,)
   :param VC: Screened Coulomb interaction matrices
   :type VC: ndarray (float), shape (Nk, Nk, 3)
   :param E1D: One-dimensional dielectric screening array
   :type E1D: ndarray (float), shape (Nk, Nk)

   :returns: * **WinH** (*ndarray (float), shape (Nk,)*) -- In-scattering rate into each hole state (Hz).
               W_in^h(k) represents the rate of scattering INTO state k.
             * **WoutH** (*ndarray (float), shape (Nk,)*) -- Out-scattering rate from each hole state (Hz).
               W_out^h(k) represents the rate of scattering OUT OF state k.

   .. rubric:: Notes

   The scattering rates satisfy detailed balance and ensure proper
   thermalization. Pauli exclusion is enforced through (1-n_h) factors.

   Calls MBPH (Many-Body Perturbation theory for Holes) from the phonons
   module, which implements the full quantum kinetic theory calculation.

   Possible Modifications
   -----
   WinH, WoutH could be inplace arguments.

   .. seealso::

      :obj:`RelaxationE`
          Equivalent calculation for electrons

      :obj:`MBPH`
          The underlying many-body calculation (in phonons module)


.. py:function:: dpdt(C, D, p, Heh, Hee, Hhh, GamE, GamH, OffP)

   Calculate the time derivative of the electron-hole coherence (interband polarization).

   Implements the Semiconductor Bloch Equation for the electron-hole coherence p,
   which represents the microscopic interband polarization that gives rise to the
   macroscopic optical polarization.

   The equation solved is:
   iℏ dp_{k_e,k_h}/dt =
       + Σ_k' H_{k_h,k'}^{hh} p_{k',k_e}           [hole Hamiltonian term]
       + Σ_k' H_{k_e,k'}^{ee} p_{k_h,k'}           [electron Hamiltonian term]
       - Σ_k' H_{k',k_h}^{eh†} C_{k',k_e}          [electron-electron correlation]
       - Σ_k' H_{k_e,k'}^{eh} D_{k',k_h}           [hole-hole correlation]
       + H_{k_e,k_h}^{eh}                          [light-matter coupling]
       - iℏ(γ_e(k_e) + γ_h(k_h)) p_{k_e,k_h}      [diagonal dephasing]
       + Γ_p^{off}(k_e,k_h)                        [off-diagonal dephasing]

   :param C: Electron-electron coherence matrix C_{k1,k2}.
             Diagonal elements C_{k,k} = n_e(k) are electron occupation numbers.
             Off-diagonal elements represent electron-electron quantum correlations.
   :type C: ndarray (complex), shape (Nk, Nk)
   :param D: Hole-hole coherence matrix D_{k1,k2}.
             Diagonal elements D_{k,k} = n_h(k) are hole occupation numbers.
             Off-diagonal elements represent hole-hole quantum correlations.
   :type D: ndarray (complex), shape (Nk, Nk)
   :param p: Electron-hole coherence matrix p_{k_e,k_h}.
             This is the microscopic polarization between electron state k_e
             and hole state k_h.
   :type p: ndarray (complex), shape (Nk, Nk)
   :param Heh: Electron-hole Hamiltonian matrix elements H_{k_e,k_h}^{eh}.
               Contains the light-matter coupling and screened Coulomb attraction.
   :type Heh: ndarray (complex), shape (Nk, Nk)
   :param Hee: Electron-electron Hamiltonian matrix elements H_{k1,k2}^{ee}.
               Contains kinetic energy (diagonal) and Coulomb repulsion (off-diagonal).
   :type Hee: ndarray (complex), shape (Nk, Nk)
   :param Hhh: Hole-hole Hamiltonian matrix elements H_{k1,k2}^{hh}.
               Contains kinetic energy (diagonal) and Coulomb repulsion (off-diagonal).
   :type Hhh: ndarray (complex), shape (Nk, Nk)
   :param GamE: Diagonal electron dephasing rate γ_e(k) for each momentum state (Hz).
                Due to carrier-carrier and carrier-phonon scattering.
   :type GamE: ndarray (float), shape (Nk,)
   :param GamH: Diagonal hole dephasing rate γ_h(k) for each momentum state (Hz).
                Due to carrier-carrier and carrier-phonon scattering.
   :type GamH: ndarray (float), shape (Nk,)
   :param OffP: Off-diagonal dephasing term Γ_p^{off}(k_e, k_h).
                Accounts for correlations in scattering processes.
   :type OffP: ndarray (complex), shape (Nk, Nk)

   :returns: **dpdt_result** -- Time derivative dp/dt of the electron-hole coherence (1/s).
   :rtype: ndarray (complex), shape (Nk, Nk)

   .. rubric:: Notes

   This is one of the three coupled Semiconductor Bloch Equations (SBEs).
   The equations for C (electrons) and D (holes) are given by dCdt and dDdt.

   The electron-hole coherence p is related to the macroscopic polarization P by:
   P(r,t) = Σ_{k_e,k_h} d_{cv} p_{k_e,k_h}(t) exp(i(k_e-k_h)·r)
   where d_{cv} is the interband dipole matrix element.

   Physical interpretation:
   - The Hamiltonian terms (Hee, Hhh) cause phase evolution
   - The correlation terms (via C, D) include Coulomb many-body effects
   - The Heh term couples to the external field (light)
   - Dephasing terms model irreversible decay processes

   Uses JIT compilation for performance with automatic fallback to pure Python.

   .. rubric:: References

   V. M. Axt and T. Kuhn, "Femtosecond spectroscopy in semiconductors:
   a key to coherences, correlations and quantum kinetics",
   Rep. Prog. Phys. 67, 433 (2004), Eqs. 2.15-2.19.

   .. seealso::

      :obj:`dCdt`
          Time derivative of electron-electron coherence

      :obj:`dDdt`
          Time derivative of hole-hole coherence


.. py:function:: dCdt(Cee, Dhh, Phe, Heh, Hee, Hhh, GamE, GamH, OffE)

   Calculate the time derivative of the electron-electron coherence.

   Implements the Semiconductor Bloch Equation for the electron-electron coherence C,
   which describes the quantum correlations between different electron momentum states.
   The diagonal elements C_{k,k} = n_e(k) are the electron occupation numbers, while
   off-diagonal elements represent quantum coherence between different momentum states.

   The equation solved is:
   iℏ dC_{k1,k2}/dt =
       + Σ_k' H_{k2,k'}^{ee} C_{k1,k'}          [k2 electron Hamiltonian]
       - Σ_k' H_{k',k1}^{ee} C_{k',k2}          [k1 electron Hamiltonian, commutator]
       + Σ_k' H_{k2,k'}^{eh} p_{k1,k'}^†        [e-h correlation via p†]
       - Σ_k' H_{k',k1}^{eh†} p_{k',k2}         [e-h correlation via Heh†]

   Note: Off-diagonal dephasing terms (commented out in original Fortran) are not included.

   :param Cee: Electron-electron coherence matrix C_{k1,k2}.
               Diagonal: C_{k,k} = n_e(k) is electron occupation.
               Off-diagonal: represents electron quantum correlations.
   :type Cee: ndarray (complex), shape (Nk, Nk)
   :param Dhh: Hole-hole coherence matrix D_{k1,k2} (not used in this equation,
               kept for interface compatibility).
   :type Dhh: ndarray (complex), shape (Nk, Nk)
   :param Phe: Electron-hole coherence matrix p_{k_e,k_h}.
               Note: Fortran uses Phe for p, but it's the same as p from dpdt.
   :type Phe: ndarray (complex), shape (Nk, Nk)
   :param Heh: Electron-hole Hamiltonian matrix H_{k_e,k_h}^{eh}.
   :type Heh: ndarray (complex), shape (Nk, Nk)
   :param Hee: Electron-electron Hamiltonian matrix H_{k1,k2}^{ee}.
               Diagonal: kinetic energy E_e(k).
               Off-diagonal: screened Coulomb repulsion between electrons.
   :type Hee: ndarray (complex), shape (Nk, Nk)
   :param Hhh: Hole-hole Hamiltonian (not used, kept for interface compatibility).
   :type Hhh: ndarray (complex), shape (Nk, Nk)
   :param GamE: Electron dephasing rates (not used in this equation).
   :type GamE: ndarray (float), shape (Nk,)
   :param GamH: Hole dephasing rates (not used, kept for interface compatibility).
   :type GamH: ndarray (float), shape (Nk,)
   :param OffE: Off-diagonal dephasing for electrons (not used in current implementation).
   :type OffE: ndarray (complex), shape (Nk, Nk)

   :returns: **dCdt_result** -- Time derivative dC/dt of electron-electron coherence (1/s).
   :rtype: ndarray (complex), shape (Nk, Nk)

   .. rubric:: Notes

   This equation governs the evolution of electron correlations, including:
   - Single-particle evolution via Hee (phase evolution, energy renormalization)
   - Coupling to the interband polarization p via Heh
   - Generation of correlations due to Coulomb interaction

   Physical significance:
   - Diagonal elements: rate of change of electron occupation n_e(k)
   - Off-diagonal: buildup/decay of electron quantum coherence
   - Couples to the p equation via Heh, forming a closed system

   The off-diagonal dephasing terms involving GamE are commented out in the
   original Fortran code and not implemented here. If needed, they would add:
   - iℏ·I_{k1≠k2}·(γ_e(k1) + γ_e(k2))·C_{k1,k2}
   where I_{k1≠k2} is the anti-identity matrix.

   Uses JIT compilation for performance with automatic fallback.

   .. rubric:: References

   V. M. Axt and T. Kuhn, Rep. Prog. Phys. 67, 433 (2004), Eqs. 2.15-2.19.

   .. seealso::

      :obj:`dpdt`
          Time derivative of electron-hole coherence (interband polarization)

      :obj:`dDdt`
          Time derivative of hole-hole coherence


.. py:function:: dDdt(Cee, Dhh, Phe, Heh, Hee, Hhh, GamE, GamH, OffH)

   Calculate the time derivative of the hole-hole coherence.

   Implements the Semiconductor Bloch Equation for the hole-hole coherence D,
   which describes the quantum correlations between different hole momentum states.
   The diagonal elements D_{k,k} = n_h(k) are the hole occupation numbers, while
   off-diagonal elements represent quantum coherence between different momentum states.

   The equation solved is:
   iℏ dD_{k1,k2}/dt =
       + Σ_k' H_{k2,k'}^{hh} D_{k1,k'}          [k2 hole Hamiltonian]
       - Σ_k' H_{k',k1}^{hh} D_{k',k2}          [k1 hole Hamiltonian, commutator]
       + Σ_k' H_{k',k2}^{eh†} p_{k',k1}^†       [e-h correlation via p†]
       - Σ_k' H_{k1,k'}^{eh†} p_{k2,k'}         [e-h correlation via Heh†]

   Note: Off-diagonal dephasing terms (commented out in original Fortran) are not included.

   :param Cee: Electron-electron coherence (not used, kept for interface compatibility).
   :type Cee: ndarray (complex), shape (Nk, Nk)
   :param Dhh: Hole-hole coherence matrix D_{k1,k2}.
               Diagonal: D_{k,k} = n_h(k) is hole occupation.
               Off-diagonal: represents hole quantum correlations.
   :type Dhh: ndarray (complex), shape (Nk, Nk)
   :param Phe: Electron-hole coherence matrix p_{k_e,k_h}.
   :type Phe: ndarray (complex), shape (Nk, Nk)
   :param Heh: Electron-hole Hamiltonian matrix H_{k_e,k_h}^{eh}.
   :type Heh: ndarray (complex), shape (Nk, Nk)
   :param Hee: Electron-electron Hamiltonian (not used, kept for interface compatibility).
   :type Hee: ndarray (complex), shape (Nk, Nk)
   :param Hhh: Hole-hole Hamiltonian matrix H_{k1,k2}^{hh}.
               Diagonal: kinetic energy E_h(k).
               Off-diagonal: screened Coulomb repulsion between holes.
   :type Hhh: ndarray (complex), shape (Nk, Nk)
   :param GamE: Electron dephasing rates (not used, kept for interface compatibility).
   :type GamE: ndarray (float), shape (Nk,)
   :param GamH: Hole dephasing rates (not used in this equation).
   :type GamH: ndarray (float), shape (Nk,)
   :param OffH: Off-diagonal dephasing for holes (not used in current implementation).
   :type OffH: ndarray (complex), shape (Nk, Nk)

   :returns: **dDdt_result** -- Time derivative dD/dt of hole-hole coherence (1/s).
   :rtype: ndarray (complex), shape (Nk, Nk)

   .. rubric:: Notes

   This equation is analogous to the electron equation (dCdt), but for holes.
   It governs the evolution of hole correlations, including:
   - Single-particle evolution via Hhh (phase evolution, energy renormalization)
   - Coupling to the interband polarization p via Heh
   - Generation of correlations due to Coulomb interaction

   Physical significance:
   - Diagonal elements: rate of change of hole occupation n_h(k)
   - Off-diagonal: buildup/decay of hole quantum coherence
   - Couples to the p equation via Heh, forming a closed system with dpdt and dCdt

   The three equations (dpdt, dCdt, dDdt) form the complete set of Semiconductor
   Bloch Equations that must be solved self-consistently. Together they describe:
   - Optical response (via p)
   - Carrier dynamics (via diagonal C and D)
   - Quantum correlations and many-body effects (via off-diagonal C and D)

   The off-diagonal dephasing terms involving GamH are commented out in the
   original Fortran code and not implemented here. If needed, they would add:
   - iℏ·I_{k1≠k2}·(γ_h(k1) + γ_h(k2))·D_{k1,k2}
   where I_{k1≠k2} is the anti-identity matrix.

   Uses JIT compilation for performance with automatic fallback.

   .. rubric:: References

   V. M. Axt and T. Kuhn, "Femtosecond spectroscopy in semiconductors",
   Rep. Prog. Phys. 67, 433 (2004), Eqs. 2.15-2.19.

   .. seealso::

      :obj:`dpdt`
          Time derivative of electron-hole coherence

      :obj:`dCdt`
          Time derivative of electron-electron coherence


.. py:function:: write_statistics(w, dt, ne2, nh2, Re, Rh)

   Write statistical data to file.

   Writes detailed carrier statistics including velocities, densities,
   energies, temperatures, and currents.

   :param w: Wire index
   :type w: int
   :param dt: Time step
   :type dt: float
   :param ne2: Electron occupation numbers
   :type ne2: ndarray
   :param nh2: Hole occupation numbers
   :type nh2: ndarray
   :param Re: Electron charge density
   :type Re: ndarray
   :param Rh: Hole charge density
   :type Rh: ndarray


.. py:function:: CalcMeh(Ex, Ey, Ez, w, Meh)

   Calculate the dipole-field coupling matrix for electron-hole transitions.

   Computes the matrix elements of the light-matter interaction Hamiltonian
   M_{k_e,k_h}^{eh} which couples the electric field to the interband polarization.
   This is the driving term in the optical Bloch equations that causes absorption
   and emission of photons.

   The matrix elements are calculated as:
   M_{k_e,k_h}^{eh} = -η_{int} [X_{cv}(k_e,k_h)·E_x(q) + Y_{cv}(k_e,k_h)·E_y(q)·y_w(w)
                                 + Z_{cv}(k_e,k_h)·E_z(q)·(-1)^w]

   where:
   - η_{int} is the electron-hole spatial overlap integral
   - X_{cv}, Y_{cv}, Z_{cv} are the momentum-dependent dipole matrix elements
   - q = k_e - k_h is the momentum transfer (photon momentum)
   - y_w(w) is a wire-dependent weighting factor
   - (-1)^w alternates sign for different wires

   :param Ex: X-component of electric field in momentum space (Fourier transformed).
              Indexed by momentum q.
   :type Ex: ndarray (complex), shape (Nr,)
   :param Ey: Y-component of electric field in momentum space.
              Multiplied by wire-dependent factor yw(w).
   :type Ey: ndarray (complex), shape (Nr,)
   :param Ez: Z-component of electric field in momentum space.
              Multiplied by (-1)^w for wire parity.
   :type Ez: ndarray (complex), shape (Nr,)
   :param w: Wire index. Used to determine y-polarization weight yw(w) and
             z-polarization sign (-1)^w.
   :type w: int
   :param Meh: Output matrix for dipole-field coupling (modified in-place).
   :type Meh: ndarray (complex), shape (Nk, Nk)

   :returns: Meh is modified in-place.
   :rtype: None

   .. rubric:: Notes

   This function is central to the optical response of the semiconductor.
   The coupling matrix Meh appears in the SBE for the electron-hole coherence p:

   iℏ dp/dt = ... + M^{eh}_{k_e,k_h} + ...

   The momentum index q = k_e - k_h represents the photon momentum absorbed/emitted
   in a transition. This is obtained via the index mapping array kkp(ke, kh).

   The spatial overlap integral η_{int} (ehint) accounts for the finite size
   of the quantum wire and reduces the coupling strength compared to the
   bare dipole moment.

   The factors yw(w) and (-1)^w allow for different polarization responses
   in different wires, enabling modeling of wire arrays with varying orientations.

   Important: The comment in the Fortran code notes that previously there was
   confusion about whether to use FFT or IFFT for the fields, and that q should
   be ke - kh. This has been corrected in the current implementation.

   .. seealso::

      :obj:`Xcv`, :obj:`Ycv`, :obj:`Zcv`

      :obj:`dpdt`
          The SBE that uses this coupling matrix


.. py:function:: CalcWnn(q0, Vr, Wnn)

   Calculate the monopole-potential coupling matrix for carrier-carrier interactions.

   Computes the matrix elements of the free-charge potential coupling
   W_{k1,k2}^{nn} which represents the effect of long-range Coulomb potential
   from free carriers on the carrier states. This contributes to the longitudinal
   field effects in the SBEs.

   The matrix elements are:
   W_{k1,k2}^{nn} = q_0 · V_r(q)

   where:
   - q_0 is the charge of the carrier (+e for holes, -e for electrons)
   - V_r(q) is the electric potential from free charge in momentum space
   - q = k1 - k2 is the momentum transfer

   :param q0: Free charge of carrier species:
              +e0 (positive) for holes
              -e0 (negative) for electrons
              where e0 is the elementary charge (C)
   :type q0: float
   :param Vr: Electric potential from free charge in momentum space (Fourier transformed).
              This is the long-range Coulomb potential V(r) = ρ(r)/(4πε_0ε_r) in q-space.
   :type Vr: ndarray (complex), shape (Nr,)
   :param Wnn: Output monopole-potential coupling matrix (modified in-place).
   :type Wnn: ndarray (complex), shape (Nk, Nk)

   :returns: Wnn is modified in-place.
   :rtype: None

   .. rubric:: Notes

   This function calculates the coupling between carriers and the self-consistent
   mean-field potential arising from the carrier density distribution. It's used
   when the longitudinal field (_LF) is enabled to include plasmon effects and
   long-range Coulomb interactions.

   The coupling matrix Wnn would appear in the SBEs as additional diagonal terms:
   - For electrons: H_{k1,k2}^{ee} += W_{k1,k2}^{ee} (with q0 = -e0)
   - For holes: H_{k1,k2}^{hh} += W_{k1,k2}^{hh} (with q0 = +e0)

   The momentum transfer q = k1 - k2 is obtained via the index mapping kkp(k1, k2).

   Note: This function is currently not actively used in the CalcH function (it's
   commented out in the Fortran code), but is kept for potential future use or
   for studying longitudinal field effects.

   Important: As noted in the Fortran comments, there was previously confusion
   about FFT vs IFFT conventions, which has been corrected. The q index now
   properly represents q = k1 - k2.

   .. seealso::

      :obj:`CalcMeh`
          Dipole-field coupling matrix for optical transitions

      :obj:`CalcH`
          Hamiltonian calculation (where Wnn would be used)


.. py:function:: CalcXqw(iq, w, kr, fe, fh, Ee, Eh, gap, area, game, gamh, dcv)

   Calculate the linear optical susceptibility χ(q,ω) for a quantum wire.

   Computes the frequency and momentum-dependent linear susceptibility using
   the Lindhard formula generalized to include population inversion (fe, fh)
   and dephasing rates (game, gamh). This describes the linear optical response
   of the quantum wire system to an external electromagnetic field.

   The susceptibility includes contributions from both absorption (fc < fv) and
   stimulated emission (fc > fv) processes at each momentum state.

   Physics
   -------
   The linear susceptibility is calculated as:

   χ(q,ω) = Σ_k [N·|d_cv|²/ε₀] × {
       (f_c(k) - f_v(k+q)) / [E_v(k+q) - E_c(k) - ℏω - iℏ(γ_h(k+q) + γ_e(k))]
     + (f_v(k) - f_c(k+q)) / [E_c(k+q) - E_v(k) - ℏω - iℏ(γ_e(k+q) + γ_h(k))]
   }

   where:
   - N = 2·Δk/(2π·A) is the density of states normalization
   - d_cv is the interband dipole matrix element
   - f_c, f_v are electron (conduction) and hole (valence) occupation numbers
   - E_c, E_v are conduction and valence band energies
   - γ_e, γ_h are electron and hole dephasing rates
   - q is the photon momentum (momentum transfer)
   - ω is the photon frequency

   The first term represents transitions where an electron in state k absorbs
   a photon with momentum q, while the second term represents the time-reversed
   process (stimulated emission).

   :param iq: Momentum index for photon momentum q. Can be positive, negative, or zero.
              The actual momentum is q = iq * (kr[1] - kr[0]).
   :type iq: int
   :param w: Angular frequency ω (rad/s) of the electromagnetic field.
   :type w: float
   :param kr: Momentum grid (rad/m) for carrier states.
   :type kr: ndarray (float), shape (Nk,)
   :param fe: Electron occupation numbers f_e(k) at each momentum state.
              Range: [0, 1] for physical occupation.
   :type fe: ndarray (float), shape (Nk,)
   :param fh: Hole occupation numbers f_h(k) at each momentum state.
              Range: [0, 1] for physical occupation.
   :type fh: ndarray (float), shape (Nk,)
   :param Ee: Electron energies E_e(k) relative to conduction band edge (J).
   :type Ee: ndarray (float), shape (Nk,)
   :param Eh: Hole energies E_h(k) relative to valence band edge (J).
   :type Eh: ndarray (float), shape (Nk,)
   :param gap: Band gap energy E_g (J).
   :type gap: float
   :param area: Cross-sectional area A of the quantum wire (m²).
   :type area: float
   :param game: Electron dephasing rates γ_e(k) (1/s).
   :type game: ndarray (float), shape (Nk,)
   :param gamh: Hole dephasing rates γ_h(k) (1/s).
   :type gamh: ndarray (float), shape (Nk,)
   :param dcv: Interband dipole matrix element d_cv (C·m).
   :type dcv: complex

   :returns: **Xqw** -- Linear optical susceptibility χ(q,ω) (dimensionless).
             Real part: related to refractive index change Δn.
             Imaginary part: related to absorption/gain coefficient α.
   :rtype: complex

   .. rubric:: Notes

   The summation range is carefully chosen to avoid out-of-bounds array access:
   - For iq ≥ 0: kmin = 0, kmax = Nk - 1 - iq (Python indexing)
   - For iq < 0: kmin = -iq, kmax = Nk - 1 (Python indexing)

   This ensures that both k and k+iq remain within [0, Nk-1].

   The minimum dephasing is set to 1e-4 eV to prevent numerical instabilities
   from vanishing denominators.

   The valence band occupations are f_v = 1 - f_h, as holes represent absence
   of electrons in the valence band.

   The imaginary part Im[χ(q,ω)] > 0 indicates absorption, while Im[χ] < 0
   indicates gain (population inversion). The real part Re[χ(q,ω)] is related
   to dispersion via the Kramers-Kronig relations.

   Physical applications:
   - Optical absorption/gain spectra
   - Refractive index changes
   - Electromagnetically induced transparency (EIT)
   - Population inversion and lasing conditions
   - Exciton resonances in quantum wires

   .. rubric:: References

   H. Haug and S. W. Koch, "Quantum Theory of the Optical and Electronic
   Properties of Semiconductors", 5th ed., World Scientific (2009), Ch. 13.

   .. seealso::

      :obj:`QWChi1`
          Related function for calculating χ from coulomb module

      :obj:`RecordXqw`
          Function that records χ(q,ω) data to files

      :obj:`GetChi1Dqw`
          1D susceptibility calculation from coulomb module

   .. rubric:: Examples

   >>> # Calculate susceptibility at q=0, near band edge
   >>> iq = 0
   >>> w = gap / hbar  # Frequency at band gap
   >>> chi = CalcXqw(iq, w, kr, fe, fh, Ee, Eh, gap, area, game, gamh, dcv)
   >>> alpha = 2 * w / c * np.imag(chi)  # Absorption coefficient


.. py:function:: RecordEpsLqw(Qr, fe, fh, Ee, Eh, gap, area, gamE, gamH, dcv, ind)

   Record the longitudinal dielectric function ε_L(q,ω) and susceptibility χ_L(q,ω).

   Calculates and saves to file the frequency and momentum-dependent longitudinal
   dielectric function and linear susceptibility for a quantum wire. This provides
   a complete characterization of the collective excitations (plasmons) and
   optical response of the system.

   The longitudinal dielectric function describes the screening of longitudinal
   electric fields (parallel to the wire axis) and determines the dispersion
   relation of plasmon modes via ε_L(q,ω) = 0.

   :param Qr: Momentum grid (rad/m) for the output. Determines the q-resolution.
   :type Qr: ndarray (float), shape (Nq,)
   :param fe: Electron occupation numbers f_e(k).
   :type fe: ndarray (float), shape (Nk,)
   :param fh: Hole occupation numbers f_h(k).
   :type fh: ndarray (float), shape (Nk,)
   :param Ee: Electron energies E_e(k) (J).
   :type Ee: ndarray (float), shape (Nk,)
   :param Eh: Hole energies E_h(k) (J).
   :type Eh: ndarray (float), shape (Nk,)
   :param gap: Band gap energy E_g (J).
   :type gap: float
   :param area: Wire cross-sectional area A (m²).
   :type area: float
   :param gamE: Electron dephasing rates γ_e(k) (1/s).
   :type gamE: ndarray (float), shape (Nk,)
   :param gamH: Hole dephasing rates γ_h(k) (1/s).
   :type gamH: ndarray (float), shape (Nk,)
   :param dcv: Interband dipole matrix element d_cv (C·m).
   :type dcv: complex
   :param ind: File index for output filename generation.
   :type ind: int

   :returns: * *None* -- Data is written to files in 'dataQW/Wire/Xqw/' directory.
             * *Files Created*
             * *-------------*
             * **dataQW/Wire/Xqw/EpsL.{ind** (*06d}.dat :*) -- Contains Re[ε_L(q,ω) - 1] and Im[ε_L(q,ω)] in two columns.
               Data is organized as nested loops: outer loop over ω, inner loop over q.
               Total size: (nwmax+1) × (Nq+1) rows, 2 columns.
             * **dataQW/Wire/Xqw/ChiL.{ind** (*06d}.dat :*) -- Contains Re[χ_L(q,ω)] and Im[χ_L(q,ω)] in two columns.
               Same structure as EpsL file.
             * *dataQW/Wire/Xqw/EpsL.params* -- Parameter file (written only once when _Xqwparams is True).
               Contains grid information: Nq, Nw, Δω, Δq, frequency range, momentum range.

   .. rubric:: Notes

   The frequency grid is automatically generated:
   - ω_max = 2·E_g/ℏ (twice the band gap frequency)
   - Δω = ω_max / 2000
   - Number of points: 2001 (from ω=0 to ω_max)

   The momentum grid uses the input kr spacing:
   - Δq = kr[1] - kr[0]
   - q ranges from 0 to Nk·Δq

   The 1D carrier density is calculated as:
   n_1D = Σ(f_e + f_h) / (2·L)
   but is currently overridden to a fixed value n_1D = 1.5×10⁸ m⁻¹ for testing.

   Two different methods are used:
   1. GetEps1Dqw: Analytical RPA dielectric function (from coulomb module)
   2. GetChi1Dqw: Numerical susceptibility from actual occupations (from coulomb module)

   The longitudinal dielectric function is related to susceptibility by:
   ε_L(q,ω) = 1 + V(q)·χ_L(q,ω)
   where V(q) is the 1D Coulomb interaction.

   Physical applications:
   - Plasmon dispersion relations (zeros of ε_L)
   - Collective oscillation frequencies
   - Screening length determination
   - Optical absorption with many-body effects
   - Carrier density diagnostics

   The data format allows easy plotting as 2D contour plots with:
   - X-axis: momentum q
   - Y-axis: frequency ω
   - Color: Re[ε_L] or Im[ε_L]

   .. rubric:: References

   G. D. Mahan, "Many-Particle Physics", 3rd ed., Springer (2000), Ch. 5.

   .. seealso::

      :obj:`CalcXqw`
          Calculate linear susceptibility at single (q,ω) point

      :obj:`GetEps1Dqw`
          Analytical 1D dielectric function (coulomb module)

      :obj:`GetChi1Dqw`
          Numerical 1D susceptibility (coulomb module)

      :obj:`RecordXqw`
          Similar function for recording χ(q,ω) using CalcXqw

   .. rubric:: Examples

   >>> # Record dielectric function at time step 1000
   >>> RecordEpsLqw(kr, fe, fh, Ee, Eh, gap, area, gamE, gamH, dcv, ind=1000)
   >>> # Files created: EpsL.001000.dat, ChiL.001000.dat


.. py:function:: RecordXqw(kr, fe, fh, Ee, Eh, gap, area, game, gamh, dcv, ind)

   Record the linear optical susceptibility χ(q,ω) using CalcXqw.

   Calculates and saves to file the frequency and momentum-dependent linear
   susceptibility χ(q,ω) for a quantum wire using the direct CalcXqw function.
   This provides the complete optical response spectrum including absorption,
   gain, and dispersion.

   Unlike RecordEpsLqw which uses analytical RPA functions, this uses the
   CalcXqw function that directly sums over carrier occupations, providing
   a more accurate representation when populations deviate from equilibrium.

   :param kr: Momentum grid (rad/m) for carrier states.
   :type kr: ndarray (float), shape (Nk,)
   :param fe: Electron occupation numbers f_e(k).
   :type fe: ndarray (float), shape (Nk,)
   :param fh: Hole occupation numbers f_h(k).
   :type fh: ndarray (float), shape (Nk,)
   :param Ee: Electron energies E_e(k) (J).
   :type Ee: ndarray (float), shape (Nk,)
   :param Eh: Hole energies E_h(k) (J).
   :type Eh: ndarray (float), shape (Nk,)
   :param gap: Band gap energy E_g (J).
   :type gap: float
   :param area: Wire cross-sectional area A (m²).
   :type area: float
   :param game: Electron dephasing rates γ_e(k) (1/s).
   :type game: ndarray (float), shape (Nk,)
   :param gamh: Hole dephasing rates γ_h(k) (1/s).
   :type gamh: ndarray (float), shape (Nk,)
   :param dcv: Interband dipole matrix element d_cv (C·m).
   :type dcv: complex
   :param ind: File index for output filename generation.
   :type ind: int

   :returns: * *None* -- Data is written to files in 'dataQW/Wire/Xqw/' directory.
             * *Files Created*
             * *-------------*
             * **dataQW/Wire/Xqw/Xqw.{ind** (*06d}.dat :*) -- Contains three columns: ω (rad/s), Re[χ(q,ω)], Im[χ(q,ω)].
               Data is organized as nested loops: outer loop over ω, inner loop over q.
               Total size: (nwmax+1) × (Nk+1) rows, 3 columns.
             * *dataQW/Wire/Xqw/Xqw.params* -- Parameter file (written only once when _Xqwparams is True).
               Contains grid information: Nq, Nw, Δω, Δq, frequency range, momentum range.

   .. rubric:: Notes

   The frequency grid is automatically generated:
   - ω_max = 2·E_g/ℏ (twice the band gap frequency)
   - Δω = ω_max / 2000
   - Number of points: 2001 (from ω=0 to ω_max)

   The momentum grid uses indices iq from 0 to Nk:
   - q ranges from 0 to Nk·Δkr
   - Δkr = kr[1] - kr[0]

   The output format with three columns (ω, Re[χ], Im[χ]) facilitates plotting
   and analysis of the frequency-dependent response at each momentum.

   Computation time scales as O(Nω × Nq × Nk), which can be substantial for
   large grids. For Nω=2001, Nq=101, Nk=101, this requires ~20M function calls
   to CalcXqw.

   Physical applications:
   - Optical absorption/gain spectra vs. carrier density
   - Refractive index changes (via Kramers-Kronig)
   - Identification of excitonic resonances
   - Population inversion and lasing thresholds
   - Non-equilibrium optical response

   The inclusion of ω in the first column makes it easy to plot susceptibility
   vs. frequency for any given q value.

   Differences from RecordEpsLqw:
   - Uses CalcXqw (direct sum over occupations) vs. GetChi1Dqw (equilibrium)
   - Output format: 3 columns (ω, Re, Im) vs. 2 columns (Re, Im)
   - Single file vs. separate files for ε and χ

   .. seealso::

      :obj:`CalcXqw`
          Function used to calculate χ(q,ω)

      :obj:`RecordEpsLqw`
          Similar function using analytical RPA methods

      :obj:`QWChi1`
          Related susceptibility calculation from qwoptics module

   .. rubric:: Examples

   >>> # Record susceptibility after excitation at time step 1000
   >>> RecordXqw(kr, fe, fh, Ee, Eh, gap, area, game, gamh, dcv, ind=1000)
   >>> # File created: Xqw.001000.dat


.. py:function:: GetArrays(x, qx, kx)

   Initialize spatial and momentum arrays for the SBE solver.

   Sets up the fundamental coordinate and momentum space grids used throughout
   the semiconductor Bloch equation calculations. This includes:
   - Real-space positions x for field propagation
   - Momentum space qx for Fourier-transformed fields
   - Carrier momentum grid kx (offset by half grid spacing)

   The carrier momentum grid kx is offset by 0.5 grid spacing to avoid having
   a state exactly at k=0, which simplifies boundary conditions and symmetry.

   :param x: Real-space position array (m). Modified in-place.
   :type x: ndarray (float), shape (Nr,)
   :param qx: Momentum array for fields (rad/m). Modified in-place.
   :type qx: ndarray (float), shape (Nr,)
   :param kx: Carrier momentum array (rad/m). Modified in-place.
   :type kx: ndarray (float), shape (Nk,)

   :returns: Arrays x, qx, kx are modified in-place.
             Module-level variables _NK0 and _NQ0 are set.
   :rtype: None

   .. rubric:: Notes

   The carrier momentum grid kx is centered at k=0 with the formula:
   kx[k] = Δkr × (-dnk + k - 0.5)  for k = 0, 1, ..., Nk-1

   where dnk = (Nk-1)/2, so that:
   - kx is antisymmetric about the origin
   - The grid spacing is Δkr
   - No state sits exactly at k=0 (offset by 0.5)

   The field momentum array qx is obtained from GetKArray and then:
   1. Shifted by cshift(qx, Nr/2) to center the zero-frequency component
   2. The first element is negated: qx[0] = -qx[0]

   Module-level variables set:
   - _NK0: Index where kx ≈ 0 (central carrier momentum index)
   - _NQ0: Index where qx = 0 (zero field momentum index)

   These zero indices are crucial for the kkp mapping array and for properly
   handling momentum conservation in scattering processes.

   The real-space array x spans the domain [-L, L] (total length 2L).
   The momentum array qx corresponds to this spatial grid via FFT convention.

   .. seealso::

      :obj:`GetSpaceArray`
          Generate real-space position array (from usefulsubs)

      :obj:`GetKArray`
          Generate momentum array for FFT (from usefulsubs)

      :obj:`GetArray0Index`
          Find index where array value is closest to zero (from usefulsubs)

      :obj:`MakeKKP`
          Create momentum difference mapping using NQ0

   .. rubric:: Examples

   >>> x = np.zeros(Nr)
   >>> qx = np.zeros(Nr)
   >>> kx = np.zeros(Nk)
   >>> GetArrays(x, qx, kx)
   >>> # Now x, qx, kx are initialized and _NK0, _NQ0 are set


.. py:function:: MakeKKP()

   Create the momentum difference mapping array kkp.

   Constructs the index mapping array kkp[k, kp] that gives the field momentum
   index for the momentum difference q = k - kp. This is essential for evaluating
   matrix elements of Fourier-transformed fields in the semiconductor Bloch equations.

   The array satisfies:
   qx[kkp[k, kp]] ≈ kr[k] - kr[kp]

   where qx is the field momentum array and kr is the carrier momentum array.

   :returns: The module-level array _kkp is allocated and filled.
   :rtype: None

   .. rubric:: Notes

   The mapping is calculated as:
   kkp[k, kp] = round[(kr[k] - kr[kp]) / Δkr] + NQ0

   where:
   - kr[k] - kr[kp] is the momentum difference
   - Division by Δkr converts to grid index units
   - round() maps to nearest grid point
   - NQ0 is added to shift from centered indexing to array indexing

   This mapping is used extensively in the SBE Hamiltonian terms:
   - Dipole-field coupling: M_{k_e,k_h} ∝ E(q) where q = k_e - k_h
   - Coulomb interaction: V_{k1,k2} ∝ V(q) where q = k1 - k2
   - Screening: ε(q) where q is momentum transfer

   Physical interpretation:
   When an electron scatters from state kp to state k, the momentum transfer
   is q = k - kp. This momentum must be provided by (or absorbed into) a photon,
   phonon, or other field mode. The kkp array provides the field mode index
   corresponding to this momentum transfer.

   Memory: For Nk=101, kkp requires ~10,000 integers (~40 KB).

   The Fortran code includes commented-out bounds checking:
   - if(kr[0] <= q <= kr[Nr]): only map if q is in range
   - if(kkp < 1 or kkp > Nr): set kkp = 0 for out-of-range

   These checks are omitted in the current implementation, assuming that the
   momentum grids are compatible and all differences are in range.

   Global Variables Modified
   -------------------------
   _kkp : ndarray (int), shape (Nk, Nk)
       Momentum difference mapping array. Allocated and filled.

   .. seealso::

      :obj:`GetArrays`
          Must be called first to set _NQ0

      :obj:`CalcMeh`
          Uses kkp for dipole-field coupling

      :obj:`CalcWnn`
          Uses kkp for potential coupling

      :obj:`kindex`
          Convert continuous momentum to grid index

   .. rubric:: Examples

   >>> GetArrays(x, qx, kx)  # Initialize arrays first
   >>> MakeKKP()  # Now create mapping
   >>> # Access field at momentum difference k - kp:
   >>> q_idx = _kkp[k, kp]
   >>> field_at_q = Ex[q_idx]


.. py:function:: kindex(k)

   Convert a continuous momentum value to the nearest grid index.

   Maps a continuous momentum k (in rad/m) to the corresponding index in the
   carrier momentum array kr. Useful for finding which discrete momentum state
   corresponds to a given continuous momentum value.

   :param k: Momentum value (rad/m).
   :type k: float

   :returns: **idx** -- Index in the kr array closest to the given momentum k.
   :rtype: int

   .. rubric:: Notes

   The mapping formula is:
   idx = round(k / Δkr) + NK0

   where:
   - k / Δkr converts momentum to grid index units
   - round() finds nearest grid point
   - NK0 is added to shift from centered indexing to array indexing

   This function is the inverse of:
   k ≈ (idx - NK0) × Δkr

   Caution: No bounds checking is performed. If k is outside the range of the
   kr array, the returned index may be out of bounds [0, Nk-1].

   Physical applications:
   - Finding initial state indices for given carrier momenta
   - Mapping continuous momentum distributions to discrete grid
   - Identifying states near a specific momentum (e.g., Fermi surface)

   .. seealso::

      :obj:`GetArrays`
          Sets up kr array and NK0

      :obj:`MakeKKP`
          Creates momentum difference mapping

   .. rubric:: Examples

   >>> # Find index for momentum near Fermi momentum
   >>> k_fermi = 1e8  # rad/m
   >>> idx = kindex(k_fermi)
   >>> k_actual = _kr[idx]  # Actual momentum on grid


.. py:function:: InitializeSBE(q, rr, r0, Emaxxx, lam, Nw, QW)

   Initialize the SBE module for calculations.

   This function allocates all module-level arrays, initializes them to zero,
   calculates material constants, and sets up all subsystems required for
   solving the Semiconductor Bloch Equations. It must be called before any
   SBE calculations are performed.

   The initialization process includes:
   1. Reading physical parameters from parameter files
   2. Calculating momentum and spatial grids
   3. Allocating coherence matrices (YY, CC, DD) for all wires
   4. Computing material constants (dipole moment, screening lengths, etc.)
   5. Initializing subsystems (Coulomb, Phonons, DC field, Dephasing, Emission)
   6. Setting up output files
   7. Calculating initial carrier distributions

   :param q: Momentum array for fields (rad/m). Used for compatibility but not
             directly modified in this function.
   :type q: ndarray (float), shape (Nq,)
   :param rr: Spatial position array for propagation space (m). Used to determine
              the quantum wire window within the propagation domain.
   :type rr: ndarray (float), shape (Nr_prop,)
   :param r0: Reference position offset (m). Used to locate the quantum wire
              within the propagation spatial grid.
   :type r0: float
   :param Emaxxx: Initial peak electric field magnitude (V/m). Used to determine
                  when to activate quantum wire calculations (via _wireoff flag).
   :type Emaxxx: float
   :param lam: Laser wavelength (m). Used for calculating linear susceptibility
               and initializing QW optics.
   :type lam: float
   :param Nw: Number of quantum wires in the simulation. Each wire has its own
              set of coherence matrices (YY, CC, DD).
   :type Nw: int
   :param QW: Flag to enable quantum wire calculations. If False, only minimal
              initialization is performed.
   :type QW: bool

   :returns: All module-level arrays and variables are set.
   :rtype: None

   .. rubric:: Notes

   The function performs extensive setup:

   **Grid Calculation:**
   - Maximum momentum: kmax = sqrt(1.2 * gap * 2 * me / hbar²)
   - Momentum spacing: dkr = 2π / (2*L)
   - Number of k-points: Nk = floor(kmax/dkr) * 2 + 1, then Nk = Nk - 1
   - Number of r-points: Nr = Nk * 2

   **Material Constants:**
   - Dipole moment: dcv = sqrt((e0*hbar)² / (6*me0*gap) * (me0/me - 1))
   - Electron confinement: alphae = sqrt(me * HO) / hbar
   - Hole confinement: alphah = sqrt(mh * HO) / hbar
   - Overlap integral: ehint = sqrt(2 * alphae * alphah / (alphae² + alphah²))
   - Critical momentum: qc = 2 * alphae * alphah / (alphae + alphah)
   - Wire area: area = sqrt(2π) / sqrt(alphae² + alphah²) * Delta0

   **Initial Carrier Distribution:**
   - Electrons and holes initialized to Fermi-Dirac distribution at
     energy E = gap/2 (half the band gap)
   - All off-diagonal coherence elements set to zero

   **Subsystem Initialization:**
   - InitializeQWOptics: Sets up optical coupling matrices
   - InitializeCoulomb: Calculates screened Coulomb interactions
   - InitializePhonons: Sets up phonon scattering rates
   - InitializeDC: Prepares DC field transport calculations
   - InitializeDephasing: Sets up dephasing rate calculations
   - InitializeEmission: (if _Recomb=True) Sets up spontaneous emission

   **Output Files:**
   For each wire w:
   - dataQW/info.{w:02d}.t.dat - General information
   - dataQW/EP.{w:02d}.t.dat - Energy and polarization data
   - dataQW/XQ.{w:02d}.t.dat - Susceptibility data
   - dataQW/Etr.dat - Transition energies
   - dataQW/Wire/info/ETHz.t.dat - THz field data

   **Special Modes:**
   If _OBE=True (Optical Bloch Equations only):
   - Disables all many-body effects
   - Only optical coupling remains active
   - Useful for testing basic optical response

   **File I/O:**
   - Reads parameters from 'params/qw.params' and 'params/mb.params'
   - Optionally reads DC field from 'DC.txt' if _ReadDC=True
   - Writes initial arrays using WriteIt function

   The function sets the module-level flag _start to indicate that
   initialization is complete, allowing other functions to check if
   the module has been properly initialized.

   .. seealso::

      :obj:`ReadQWParams`
          Read quantum wire physical parameters

      :obj:`ReadMBParams`
          Read many-body physics flags

      :obj:`GetArrays`
          Set up spatial and momentum grids

      :obj:`MakeKKP`
          Create momentum difference mapping

      :obj:`InitializeQWOptics`
          Initialize optical coupling

      :obj:`InitializeCoulomb`
          Initialize Coulomb interactions

      :obj:`InitializePhonons`
          Initialize phonon scattering

      :obj:`InitializeDC`
          Initialize DC field transport

      :obj:`InitializeDephasing`
          Initialize dephasing rates

      :obj:`InitializeEmission`
          Initialize spontaneous emission

      :obj:`QWChi1`
          Calculate linear susceptibility

      :obj:`RecordXqw`
          Record susceptibility data

   .. rubric:: Examples

   >>> import numpy as np
   >>> q = np.linspace(-1e8, 1e8, 201)
   >>> rr = np.linspace(-500e-9, 500e-9, 201)
   >>> InitializeSBE(q, rr, r0=0.0, Emaxxx=1e6, lam=800e-9, Nw=1, QW=True)
   >>> # Module is now initialized and ready for SBE calculations


.. py:function:: SBECalculator(Ex, Ey, Ez, Vr, dt, Px, Py, Pz, Re, Rh, WriteFields, w)

   Solve the 1D Semiconductor Bloch Equations and calculate source terms.

   This is the main function that solves the Semiconductor Bloch Equations
   for the w'th quantum wire and calculates the source terms Px, Py, Pz, Re,
   and Rh that are used in Maxwell's equations for field propagation.

   The function performs a leapfrog time integration of the SBEs, including:
   - Electron-hole coherence (interband polarization) p
   - Electron-electron coherence C
   - Hole-hole coherence D
   - Many-body effects (Coulomb, phonons, dephasing)
   - DC transport effects
   - Charge density calculations

   :param Ex: X-component electric field in QW momentum space (modified in-place).
              The field is FFT'd to real space for calculations, then FFT'd back.
   :type Ex: ndarray (complex), shape (Nr,)
   :param Ey: Y-component electric field in QW momentum space (modified in-place).
   :type Ey: ndarray (complex), shape (Nr,)
   :param Ez: Z-component electric field in QW momentum space (modified in-place).
   :type Ez: ndarray (complex), shape (Nr,)
   :param Vr: Free charge potential (voltage) in QW momentum space (modified in-place).
   :type Vr: ndarray (complex), shape (Nr,)
   :param dt: Time step (s).
   :type dt: float
   :param Px: X-component QW polarization field (output, modified in-place).
   :type Px: ndarray (complex), shape (Nr,)
   :param Py: Y-component QW polarization field (output, modified in-place).
   :type Py: ndarray (complex), shape (Nr,)
   :param Pz: Z-component QW polarization field (output, modified in-place).
   :type Pz: ndarray (complex), shape (Nr,)
   :param Re: QW electron charge density (output, modified in-place).
   :type Re: ndarray (complex), shape (Nr,)
   :param Rh: QW hole charge density (output, modified in-place).
   :type Rh: ndarray (complex), shape (Nr,)
   :param WriteFields: Flag to record SBE solutions and write output files this time step.
   :type WriteFields: bool
   :param w: Quantum wire index (which wire to calculate for).
   :type w: int

   :returns: All output arrays (Px, Py, Pz, Re, Rh, Ex, Ey, Ez, Vr) are modified in-place.
   :rtype: None

   .. rubric:: Notes

   The function implements the following sequence:

   1. **Initialize source terms** to zero
   2. **Checkout coherence matrices** from module storage for wire w
   3. **Prepare arrays** (Hamiltonians, screening, dephasing) via Preparation()
   4. **Calculate time derivatives** dp/dt, dC/dt, dD/dt
   5. **Time evolve** using leapfrog scheme: X3 = X1 + dX/dt * 2*dt
   6. **Apply relaxation** (phonon/carrier-carrier scattering) if enabled
   7. **Apply DC transport** if enabled
   8. **Normalize populations** to ensure charge neutrality
   9. **Reshuffle** for stability (convert leapfrog to implicit Euler)
   10. **Calculate polarization** Px, Py, Pz from coherence p
   11. **Calculate charge densities** Re, Rh if longitudinal field enabled
   12. **Write output files** if WriteFields is True
   13. **Checkin updated matrices** to module storage

   **Time Integration Scheme:**
   The leapfrog scheme is:
   - X3 = X1 + dX/dt * 2*dt  (2nd order accurate but potentially unstable)
   - Then reshuffled to: X2 = (X1 + X3) / 2  (1st order accurate but stable)

   This converts the 2nd-order accurate (but unstable) leapfrog scheme into
   a 1st-order accurate (but stable) implicit Euler scheme.

   **Charge Neutrality:**
   The populations are normalized so that:
   - Total electrons = Total holes = (sum(ne) + sum(nh)) / 2
   This ensures charge neutrality in the system.

   **FFT Operations:**
   The electric fields and polarizations are FFT'd to real space for
   calculations, then FFT'd back to momentum space. This is done because:
   - Some calculations are easier in real space
   - The output is written in real space (at center point Nr/2)

   **Output Files:**
   If WriteFields is True:
   - WriteSBESolns: Writes coherence matrices and populations
   - WriteDephasing: Writes dephasing rates (if DiagDph enabled)
   - File (uw+w): Writes statistics (velocities, densities, energies, etc.)
   - File (2*uw+w): Writes fields and polarizations at center point

   **Module Variables Used:**
   - _YY1, _YY2, _YY3: Electron-hole coherence matrices
   - _CC1, _CC2, _CC3: Electron-electron coherence matrices
   - _DD1, _DD2, _DD3: Hole-hole coherence matrices
   - _Id, _Ia: Identity and anti-identity matrices
   - _kr, _Ee, _Eh: Momentum and energy arrays
   - _r, _Qr: Spatial and momentum arrays
   - _I0: Drift current array
   - _xxx, _jjj: Time step counters
   - _gap, _me, _mh, _L, _area, _ehint: Material parameters
   - _Optics, _EHs, _Phonon, _DCTrans, _LF, _DiagDph: Physics flags

   .. seealso::

      :obj:`Preparation`
          Prepare Hamiltonians and arrays for SBE time step

      :obj:`dpdt`
          Calculate time derivative of electron-hole coherence

      :obj:`dCdt`
          Calculate time derivative of electron-electron coherence

      :obj:`dDdt`
          Calculate time derivative of hole-hole coherence

      :obj:`Relaxation`
          Apply phonon and carrier-carrier scattering

      :obj:`Transport`
          Apply DC field transport effects

      :obj:`QWPolarization3`
          Calculate polarization from coherence

      :obj:`QWRho5`
          Calculate charge densities from coherence

      :obj:`Checkout`
          Retrieve coherence matrices from module storage

      :obj:`Checkin`
          Store coherence matrices to module storage


.. py:function:: FFTG(F)

   FFT with Gaussian normalization.

   Performs FFT and applies Gaussian normalization: F = -FFT(F) / Nf

   :param F: Input function (complex), modified in-place, 1D array
   :type F: ndarray

   :returns: F array is modified in-place.
   :rtype: None

   .. rubric:: Notes

   Uses pyfftw for FFT computation.
   The function performs: FFTC(F) then F = -F / Nf


.. py:function:: iFFTG(F)

   IFFT with Gaussian normalization.

   Performs IFFT and applies Gaussian normalization: F = -IFFT(F) * Nf

   :param F: Input function (complex), modified in-place, 1D array
   :type F: ndarray

   :returns: F array is modified in-place.
   :rtype: None

   .. rubric:: Notes

   Uses pyfftw for IFFT computation.
   The function performs: iFFTC(F) then F = -F * Nf


.. py:function:: printIT(Dx, z, n, file)

   Print field to file with index number.

   Writes a complex 1D field array to a file with index number in filename.

   :param Dx: Field array (complex), 1D array
   :type Dx: ndarray
   :param z: Spatial coordinates (real), 1D array
   :type z: ndarray
   :param n: Index number for filename
   :type n: int
   :param file: Base filename (without extension and index)
   :type file: str

   :rtype: None

   .. rubric:: Notes

   The file is written to 'dataQW/{file}{n:06d}.dat'.
   Each line contains: z(i), real(Dx(i)), imag(Dx(i))


.. py:function:: printIT2D(Dx, z, n, file)

   Print 2D complex field to file with index number.

   Writes a 2D complex field array to a file with index number in filename.

   :param Dx: Field array (complex), 2D array
   :type Dx: ndarray
   :param z: Spatial coordinates (real), 1D array (not used in output)
   :type z: ndarray
   :param n: Index number for filename
   :type n: int
   :param file: Base filename (without extension and index)
   :type file: str

   :rtype: None

   .. rubric:: Notes

   The file is written to 'dataQW/{file}{n:07d}.dat'.
   Each line contains: abs(Dx(i,j))
   The z parameter is kept for interface compatibility but not used.


.. py:function:: GetArray0Index(x)

   Get index of array element closest to zero.

   Finds the index where the array value is closest to zero
   by rounding and checking for zero.

   :param x: Input array (real), 1D array
   :type x: ndarray

   :returns: Index (1-based in Fortran, 0-based in Python) where value is closest to zero
   :rtype: int

   .. rubric:: Notes

   The function rounds array values and finds the first index
   where the rounded value is zero. Returns error message if not found.


.. py:data:: twopi

   

.. py:data:: c0

   

.. py:data:: hbar

   

.. py:data:: eps0

   

.. py:data:: ii
   :value: 1j

   

.. py:function:: Prop2QW(RR, Exx, Eyy, Ezz, Vrr, Edc, R, Ex, Ey, Ez, Vr, t, xxx)

   Convert Maxwell electric fields from propagation space to QW space.

   Converts the Maxwell electric fields (Exx, Eyy, Ezz, Vrr) in
   the propagation space (RR) into the QW electric fields (Ex, Ey, Ez, Vr)
   in the QW electric field space (R). After interpolating from the RR-space
   to the R-space, the FFT from the R- to Qr-space is taken.

   :param RR: Maxwell RR spatial array, 1D array
   :type RR: ndarray
   :param Exx: Maxwell X electric field, 1D array, complex
   :type Exx: ndarray
   :param Eyy: Maxwell Y electric field, 1D array, complex
   :type Eyy: ndarray
   :param Ezz: Maxwell Z electric field, 1D array, complex
   :type Ezz: ndarray
   :param Vrr: Maxwell free charge potential, 1D array, complex
   :type Vrr: ndarray
   :param Edc: QW spatial array (modified in-place, currently unused)
   :type Edc: float
   :param R: QW spatial array, 1D array
   :type R: ndarray
   :param Ex: QW X electric field (modified in-place), 1D array, complex
   :type Ex: ndarray
   :param Ey: QW Y electric field (modified in-place), 1D array, complex
   :type Ey: ndarray
   :param Ez: QW Z electric field (modified in-place), 1D array, complex
   :type Ez: ndarray
   :param Vr: QW free charge potential (modified in-place), 1D array, complex
   :type Vr: ndarray
   :param t: Current time (s)
   :type t: float
   :param xxx: Time index
   :type xxx: int

   :returns: Ex, Ey, Ez, Vr, Edc are modified in-place
   :rtype: None

   .. rubric:: Notes

   Uses module-level variable _QWWindow for windowing.
   Fields are made real before FFT.


.. py:function:: QW2Prop(r, Qr, Ex, Ey, Ez, Vr, Px, Py, Pz, re, rh, RR, Pxx, Pyy, Pzz, RhoE, RhoH, w, xxx, WriteFields, Plasmonics)

   Convert QW fields and polarizations back to propagation space.

   Converts QW electric fields, polarizations, and charge densities
   from QW space (r, Qr) back to propagation space (RR).

   :param r: QW Y-spaces, 1D array
   :type r: ndarray
   :param Qr: QW momentum space, 1D array
   :type Qr: ndarray
   :param Ex: QW X electric field (modified in-place), 1D array, complex
   :type Ex: ndarray
   :param Ey: QW Y electric field (modified in-place), 1D array, complex
   :type Ey: ndarray
   :param Ez: QW Z electric field (modified in-place), 1D array, complex
   :type Ez: ndarray
   :param Vr: QW free charge potential (modified in-place), 1D array, complex
   :type Vr: ndarray
   :param Px: QW X polarization (modified in-place), 1D array, complex
   :type Px: ndarray
   :param Py: QW Y polarization (modified in-place), 1D array, complex
   :type Py: ndarray
   :param Pz: QW Z polarization (modified in-place), 1D array, complex
   :type Pz: ndarray
   :param re: QW electron charge density (modified in-place), 1D array, complex
   :type re: ndarray
   :param rh: QW hole charge density (modified in-place), 1D array, complex
   :type rh: ndarray
   :param RR: Propagation Y-spaces, 1D array
   :type RR: ndarray
   :param Pxx: Propagation X polarization (modified in-place), 1D array, complex
   :type Pxx: ndarray
   :param Pyy: Propagation Y polarization (modified in-place), 1D array, complex
   :type Pyy: ndarray
   :param Pzz: Propagation Z polarization (modified in-place), 1D array, complex
   :type Pzz: ndarray
   :param RhoE: Propagation electron charge density (modified in-place), 1D array, complex
   :type RhoE: ndarray
   :param RhoH: Propagation hole charge density (modified in-place), 1D array, complex
   :type RhoH: ndarray
   :param w: Wire index
   :type w: int
   :param xxx: Time index
   :type xxx: int
   :param WriteFields: Record fields?
   :type WriteFields: bool
   :param Plasmonics: Calculate charge densities?
   :type Plasmonics: bool

   :returns: All input arrays are modified in-place
   :rtype: None

   .. rubric:: Notes

   Uses module-level variable _small for numerical stability.
   Charge densities are normalized if Plasmonics is True.


.. py:function:: QWPolarization3(y, ky, p, ehint, area, L, Px, Py, Pz, xxx, w)

   Calculate QW polarization in 3D.

   Computes the QW polarization components (Px, Py, Pz) from the
   density matrix p using the dipole matrix elements.

   :param y: Spatial coordinate array, 1D array
   :type y: ndarray
   :param ky: Momentum coordinate array, 1D array
   :type ky: ndarray
   :param p: Density matrix, shape (Nk, Nk), complex
   :type p: ndarray
   :param ehint: Electron-hole space integral
   :type ehint: float
   :param area: Area of wire (m^2)
   :type area: float
   :param L: Length of wire (m)
   :type L: float
   :param Px: QW X polarization (modified in-place), 1D array, complex
   :type Px: ndarray
   :param Py: QW Y polarization (modified in-place), 1D array, complex
   :type Py: ndarray
   :param Pz: QW Z polarization (modified in-place), 1D array, complex
   :type Pz: ndarray
   :param xxx: Time index
   :type xxx: int
   :param w: Wire index
   :type w: int

   :returns: Px, Py, Pz are modified in-place
   :rtype: None

   .. rubric:: Notes

   Uses module-level variables _Xvc0, _Yvc0, _Zvc0, _Expikr, _Expikrc, _QWWindow.
   Uses JIT compilation for performance-critical loops.


.. py:function:: yw(w)

   Calculate wire-dependent sign factor.

   Computes a sign factor based on the wire index.

   :param w: Wire index
   :type w: int

   :returns: Sign factor: (-1)**floor((w-1)/2)
   :rtype: int

   .. rubric:: Notes

   Used for alternating sign patterns in multi-wire systems.


.. py:function:: printITReal2(Dx, z, n, file)

   Print real part of complex field to file.

   Writes the real part of a complex field array to a file.
   On the first call, writes both the field and coordinate values.
   On subsequent calls, writes only the field values.

   :param Dx: Complex field array, 1D array
   :type Dx: ndarray
   :param z: Coordinate array, 1D array
   :type z: ndarray
   :param n: Time index
   :type n: int
   :param file: Base filename (without extension)
   :type file: str

   :rtype: None

   .. rubric:: Notes

   Uses module-level variable _firsttime to track first write.
   Files are written to 'dataQW/' directory.


.. py:function:: WriteSBESolns(ky, ne, nh, C, D, P, Ee, Eh, w, xxx)

   Write SBE (Semiconductor Bloch Equations) solutions to files.

   Writes quantum wire electron/hole occupation numbers, coherence matrices,
   and energies to output files.

   :param ky: QW momentum array, 1D array
   :type ky: ndarray
   :param ne: QW electron occupation numbers, 1D array, complex
   :type ne: ndarray
   :param nh: QW hole occupation numbers, 1D array, complex
   :type nh: ndarray
   :param C: QW electron/electron coherence matrix, 2D array, complex
   :type C: ndarray
   :param D: QW hole/hole coherence matrix, 2D array, complex
   :type D: ndarray
   :param P: QW electron/hole coherence matrix, 2D array, complex
   :type P: ndarray
   :param Ee: QW electron energies, 1D array, complex
   :type Ee: ndarray
   :param Eh: QW hole energies, 1D array, complex
   :type Eh: ndarray
   :param w: Wire index
   :type w: int
   :param xxx: Time index
   :type xxx: int

   :rtype: None

   .. rubric:: Notes

   Uses printIT and printIT2D from usefulsubs to write data files.


.. py:function:: WritePLSpectrum(hw, PLS, w, xxx)

   Write photoluminescence spectrum to file.

   Writes the photoluminescence spectrum as a function of photon energy
   to an output file.

   :param hw: Photon energy array (J), 1D array
   :type hw: ndarray
   :param PLS: Photoluminescence spectrum, 1D array
   :type PLS: ndarray
   :param w: Wire index
   :type w: int
   :param xxx: Time index
   :type xxx: int

   :rtype: None

   .. rubric:: Notes

   Converts photon energy from Joules to eV (divides by e0).
   Uses printIT from usefulsubs to write data file.


.. py:function:: WriteQWFields(QY, Ex, Ey, Ez, Vr, Px, Py, Pz, Re, Rh, sp, w, xxx)

   Write QW field arrays to files.

   Writes QW electric fields, polarizations, and charge densities
   to output files.

   :param QY: QY momentum/y-space array, 1D array
   :type QY: ndarray
   :param Ex: QW X electric field, 1D array, complex
   :type Ex: ndarray
   :param Ey: QW Y electric field, 1D array, complex
   :type Ey: ndarray
   :param Ez: QW Z electric field, 1D array, complex
   :type Ez: ndarray
   :param Vr: QW free charge potential, 1D array, complex
   :type Vr: ndarray
   :param Px: QW X polarization, 1D array, complex
   :type Px: ndarray
   :param Py: QW Y polarization, 1D array, complex
   :type Py: ndarray
   :param Pz: QW Z polarization, 1D array, complex
   :type Pz: ndarray
   :param Re: QW electron charge density, 1D array, complex
   :type Re: ndarray
   :param Rh: QW hole charge density, 1D array, complex
   :type Rh: ndarray
   :param sp: Domain label ('k' or 'r') for file name
   :type sp: str
   :param w: Wire index
   :type w: int
   :param xxx: Time index
   :type xxx: int

   :rtype: None

   .. rubric:: Notes

   Uses printIT from usefulsubs to write data files.


.. py:function:: WritePropFields(y, Ex, Ey, Ez, Vr, Px, Py, Pz, Re, Rh, sp, w, xxx)

   Write propagation field arrays to files.

   Writes propagation electric fields, polarizations, and charge densities
   to output files.

   :param y: Spatial coordinate array, 1D array
   :type y: ndarray
   :param Ex: Propagation X electric field, 1D array, complex
   :type Ex: ndarray
   :param Ey: Propagation Y electric field, 1D array, complex
   :type Ey: ndarray
   :param Ez: Propagation Z electric field, 1D array, complex
   :type Ez: ndarray
   :param Vr: Propagation free charge potential, 1D array, complex
   :type Vr: ndarray
   :param Px: Propagation X polarization, 1D array, complex
   :type Px: ndarray
   :param Py: Propagation Y polarization, 1D array, complex
   :type Py: ndarray
   :param Pz: Propagation Z polarization, 1D array, complex
   :type Pz: ndarray
   :param Re: Propagation electron charge density, 1D array, complex
   :type Re: ndarray
   :param Rh: Propagation hole charge density, 1D array, complex
   :type Rh: ndarray
   :param sp: Space label for file name
   :type sp: str
   :param w: Wire index
   :type w: int
   :param xxx: Time index
   :type xxx: int

   :rtype: None

   .. rubric:: Notes

   Uses printITReal2 to write real parts of complex fields.
   Uses printIT for charge density difference.


.. py:function:: QWRho5(Qr, kr, R, L, kkp, p, CC, DD, ne, nh, re, rh, xxx, jjj)

   Calculate quantum wire charge densities.

   Computes electron and hole charge densities in real space from
   coherence matrices CC and DD using Fourier transforms.

   :param Qr: QW momentum array, 1D array
   :type Qr: ndarray
   :param kr: QW momentum array, 1D array
   :type kr: ndarray
   :param R: QW spatial coordinate array, 1D array
   :type R: ndarray
   :param L: Length of wire (m)
   :type L: float
   :param kkp: Momentum difference index matrix, 2D array, integer
   :type kkp: ndarray
   :param p: Density matrix (unused, kept for interface compatibility), 2D array, complex
   :type p: ndarray
   :param CC: Electron/electron coherence matrix, 2D array, complex
   :type CC: ndarray
   :param DD: Hole/hole coherence matrix, 2D array, complex
   :type DD: ndarray
   :param ne: Electron occupation numbers, 1D array, complex
   :type ne: ndarray
   :param nh: Hole occupation numbers, 1D array, complex
   :type nh: ndarray
   :param re: Electron charge density (modified in-place), 1D array, complex
   :type re: ndarray
   :param rh: Hole charge density (modified in-place), 1D array, complex
   :type rh: ndarray
   :param xxx: Time index
   :type xxx: int
   :param jjj: Additional index (unused, kept for interface compatibility)
   :type jjj: int

   :returns: re and rh are modified in-place
   :rtype: None

   .. rubric:: Notes

   Uses module-level variables _Expikr, _Expikrc, _QWWindow, _small.
   Normalizes charge densities to match total electron/hole numbers.
   Removes boundary effects by subtracting average of first/last 10 points.


.. py:function:: printIT3D(Dx, z, n, file)

   Print 3D complex array to file.

   Writes a 3D complex array to a file, storing both real and imaginary parts.

   :param Dx: 3D complex array, shape (N1, N2, N3)
   :type Dx: ndarray
   :param z: Coordinate array (unused, kept for interface compatibility), 1D array
   :type z: ndarray
   :param n: Time index
   :type n: int
   :param file: Base filename (without extension)
   :type file: str

   :rtype: None

   .. rubric:: Notes

   Files are written to 'dataQW/' directory.
   Each line contains real and imaginary parts of one array element.


.. py:function:: printITReal(Dx, z, n, file)

   Print real part of complex field to file.

   Writes the coordinate and real part of a complex field array to a file.

   :param Dx: Complex field array, 1D array
   :type Dx: ndarray
   :param z: Coordinate array, 1D array
   :type z: ndarray
   :param n: Time index
   :type n: int
   :param file: Base filename (without extension)
   :type file: str

   :rtype: None

   .. rubric:: Notes

   Files are written to 'dataQW/' directory.
   Each line contains coordinate and real part of field.


.. py:function:: QWChi1(lam, dky, Ee, Eh, area, geh, dcv)

   Calculate quantum wire linear susceptibility.

   Computes the frequency-dependent linear susceptibility of the quantum wire.

   :param lam: Wavelength (m)
   :type lam: float
   :param dky: Momentum step (1/m)
   :type dky: float
   :param Ee: Electron energies, 1D array
   :type Ee: ndarray
   :param Eh: Hole energies, 1D array
   :type Eh: ndarray
   :param area: Area of wire (m^2)
   :type area: float
   :param geh: Electron-hole dephasing rate (1/s)
   :type geh: float
   :param dcv: Carrier dipole moment (C m)
   :type dcv: complex

   :returns: Linear susceptibility chi^(1)
   :rtype: complex

   .. rubric:: Notes

   Uses module-level constants twopi, c0, eps0, hbar, ii.
   Formula: chi^(1) = 4 * dcv^2 / (eps0 * area) * dky / (2*pi) *
            sum((Ee+Eh) / ((Ee+Eh - i*hbar*geh - hbar*w) * (Ee+Eh + i*hbar*geh + hbar*w)))


.. py:function:: CalcQWWindow(YY, L)

   Calculate quantum wire window function.

   Computes a window function that smoothly goes to zero outside
   the wire length L/2, using an exponential decay.

   :param YY: Spatial coordinate array, 1D array
   :type YY: ndarray
   :param L: Length of wire (m)
   :type L: float

   :rtype: None

   .. rubric:: Notes

   Modifies module-level variable _QWWindow.
   Window function: exp(-(YY/(L/2))^150)
   Values outside |YY| > L/2 are set to 0 before applying exponential.
   Uses printIT to write envelope to file.


.. py:function:: InitializeQWOptics(RR, L, dcv, kr, Qr, Ee, Eh, ehint, area, gap)

   Initialize quantum wire optics module.

   Sets up all necessary arrays and parameters for quantum wire optics
   calculations, including window functions, phase factors, and dipole
   matrix elements.

   :param RR: Spatial coordinate array, 1D array
   :type RR: ndarray
   :param L: Length of wire (m)
   :type L: float
   :param dcv: Carrier dipole moment (C m)
   :type dcv: complex
   :param kr: Momentum coordinate array, 1D array
   :type kr: ndarray
   :param Qr: Momentum coordinate array (unused, kept for interface compatibility), 1D array
   :type Qr: ndarray
   :param Ee: Electron energies, 1D array
   :type Ee: ndarray
   :param Eh: Hole energies, 1D array
   :type Eh: ndarray
   :param ehint: Electron-hole space integral
   :type ehint: float
   :param area: Area of wire (m^2)
   :type area: float
   :param gap: Band gap (J) (unused, kept for interface compatibility)
   :type gap: float

   :rtype: None

   .. rubric:: Notes

   Modifies module-level variables _QWWindow, _Expikr, _Expikrc, _dcv0, _Vol,
   _Xcv0, _Ycv0, _Zcv0, _Xvc0, _Yvc0, _Zvc0.
   Calculates dipole matrix elements Xcv0, Ycv0, Zcv0 and their conjugates.
   Uses module-level constants twopi.


.. py:function:: CalcExpikr(y, ky)

   Vectorized version (potentially faster than JIT for large arrays).


.. py:function:: Xcv(k, kp)

   Get X dipole matrix element.

   Returns the X component of the dipole matrix element at indices (k, kp).

   :param k: First index (0-based in Python)
   :type k: int
   :param kp: Second index (0-based in Python)
   :type kp: int

   :returns: X dipole matrix element value
   :rtype: complex

   .. rubric:: Notes

   Uses module-level variable _Xcv0.


.. py:function:: Ycv(k, kp)

   Get Y dipole matrix element.

   Returns the Y component of the dipole matrix element at indices (k, kp).

   :param k: First index (0-based in Python)
   :type k: int
   :param kp: Second index (0-based in Python)
   :type kp: int

   :returns: Y dipole matrix element value
   :rtype: complex

   .. rubric:: Notes

   Uses module-level variable _Ycv0.


.. py:function:: Zcv(k, kp)

   Get Z dipole matrix element.

   Returns the Z component of the dipole matrix element at indices (k, kp).

   :param k: First index (0-based in Python)
   :type k: int
   :param kp: Second index (0-based in Python)
   :type kp: int

   :returns: Z dipole matrix element value
   :rtype: complex

   .. rubric:: Notes

   Uses module-level variable _Zcv0.


.. py:function:: GetVn1n2(kr, rcv, Hcc, Hhh, Hcv, Vcc, Vvv, Vcv, Vvc)

   Calculate interaction matrices Vcc, Vvv, Vcv, Vvc.

   Computes the interaction matrices from Hamiltonian matrices and
   dipole moment arrays using the Heisenberg equation of motion.

   :param kr: Momentum coordinate array, 1D array
   :type kr: ndarray
   :param rcv: Conduction-valence dipole moment array, 1D array, complex
   :type rcv: ndarray
   :param Hcc: Conduction-conduction Hamiltonian matrix, 2D array, complex
   :type Hcc: ndarray
   :param Hhh: Hole-hole Hamiltonian matrix, 2D array, complex
   :type Hhh: ndarray
   :param Hcv: Conduction-valence Hamiltonian matrix, 2D array, complex
   :type Hcv: ndarray
   :param Vcc: Conduction-conduction interaction matrix (modified in-place), 2D array, complex
   :type Vcc: ndarray
   :param Vvv: Valence-valence interaction matrix (modified in-place), 2D array, complex
   :type Vvv: ndarray
   :param Vcv: Conduction-valence interaction matrix (modified in-place), 2D array, complex
   :type Vcv: ndarray
   :param Vvc: Valence-conduction interaction matrix (modified in-place), 2D array, complex
   :type Vvc: ndarray

   :returns: Vcc, Vvv, Vcv, Vvc are modified in-place
   :rtype: None

   .. rubric:: Notes

   Uses module-level constants ii, hbar.
   Formula: V = (-i/hbar) * [rcv * H - H * rcv]
   Uses JIT compilation for performance-critical loops.


.. py:data:: pi

   

.. py:data:: hbar

   

.. py:data:: ii
   :value: 1j

   

.. py:function:: GetKArray(Nk, L)

   (typespace.py should be there)
   Generate k-space array for Fourier transforms.

   :param Nk: Number of k-space points
   :type Nk: int
   :param L: Length of the spatial domain (m)
   :type L: float

   :returns: Array of k values (1/m), 1D array of length Nk
   :rtype: ndarray


.. py:function:: InitializeDC(ky, me, mh)

   Initialize the DC field module.

   Sets up all module-level arrays required for DC field calculations.
   Allocates and initializes Y, xe, xh, qinv arrays and opens output files.

   :param ky: Momentum coordinates of quantum wire (1/m), 1D array
   :type ky: ndarray
   :param me: Effective electron mass (kg)
   :type me: float
   :param mh: Effective hole mass (kg)
   :type mh: float

   :returns: All arrays are stored as module-level variables.
   :rtype: None


.. py:function:: CalcDCE2(DCTrans, ky, Cq2, Edc, me, ge, Ephn, N0, ne, Ee, Vee, n, j, DC)

   Calculate DC field contribution for electrons (version 2).

   Computes the DC field transport contribution to the electron distribution
   evolution. This version uses a finite difference derivative instead of FFT.

   :param DCTrans: Whether to include DC transport terms
   :type DCTrans: bool
   :param ky: Momentum coordinates (1/m), 1D array
   :type ky: ndarray
   :param Cq2: Coupling constant squared, 1D array
   :type Cq2: ndarray
   :param Edc: DC electric field (V/m)
   :type Edc: float
   :param me: Effective electron mass (kg)
   :type me: float
   :param ge: Inverse electron lifetime (Hz)
   :type ge: float
   :param Ephn: Average phonon energy (J)
   :type Ephn: float
   :param N0: Phonon occupation number
   :type N0: float
   :param ne: Electron occupation numbers (complex), 1D array
   :type ne: ndarray
   :param Ee: Electron energies (J), 1D array
   :type Ee: ndarray
   :param Vee: Electron-electron interaction matrix (J), 2D array
   :type Vee: ndarray
   :param n: Time step index
   :type n: int
   :param j: Iteration index
   :type j: int
   :param DC: Output DC field contribution (modified in-place), 1D array
   :type DC: ndarray

   :returns: DC array is modified in-place.
   :rtype: None


.. py:function:: CalcDCH2(DCTrans, ky, Cq2, Edc, mh, gh, Ephn, N0, nh, Eh, Vhh, n, j, DC)

   Calculate DC field contribution for holes (version 2).

   Computes the DC field transport contribution to the hole distribution
   evolution. This version uses a finite difference derivative instead of FFT.

   :param DCTrans: Whether to include DC transport terms
   :type DCTrans: bool
   :param ky: Momentum coordinates (1/m), 1D array
   :type ky: ndarray
   :param Cq2: Coupling constant squared, 1D array
   :type Cq2: ndarray
   :param Edc: DC electric field (V/m)
   :type Edc: float
   :param mh: Effective hole mass (kg)
   :type mh: float
   :param gh: Inverse hole lifetime (Hz)
   :type gh: float
   :param Ephn: Average phonon energy (J)
   :type Ephn: float
   :param N0: Phonon occupation number
   :type N0: float
   :param nh: Hole occupation numbers (complex), 1D array
   :type nh: ndarray
   :param Eh: Hole energies (J), 1D array
   :type Eh: ndarray
   :param Vhh: Hole-hole interaction matrix (J), 2D array
   :type Vhh: ndarray
   :param n: Time step index
   :type n: int
   :param j: Iteration index
   :type j: int
   :param DC: Output DC field contribution (modified in-place), 1D array
   :type DC: ndarray

   :returns: DC array is modified in-place.
   :rtype: None


.. py:function:: CalcDCE(DCTrans, ky, Cq2, Edc, me, ge, Ephn, N0, ne, Ee, Vee, DC)

   Calculate DC field contribution for electrons (original version).

   Computes the DC field transport contribution to the electron distribution
   evolution. This version uses FFT-based derivative.

   :param DCTrans: Whether to include DC transport terms
   :type DCTrans: bool
   :param ky: Momentum coordinates (1/m), 1D array
   :type ky: ndarray
   :param Cq2: Coupling constant squared, 1D array
   :type Cq2: ndarray
   :param Edc: DC electric field (V/m)
   :type Edc: float
   :param me: Effective electron mass (kg)
   :type me: float
   :param ge: Inverse electron lifetime (Hz)
   :type ge: float
   :param Ephn: Average phonon energy (J)
   :type Ephn: float
   :param N0: Phonon occupation number
   :type N0: float
   :param ne: Electron occupation numbers (complex), 1D array
   :type ne: ndarray
   :param Ee: Electron energies (J), 1D array
   :type Ee: ndarray
   :param Vee: Electron-electron interaction matrix (J), 2D array
   :type Vee: ndarray
   :param DC: Output DC field contribution (modified in-place), 1D array
   :type DC: ndarray

   :returns: DC array is modified in-place.
   :rtype: None


.. py:function:: CalcDCH(DCTrans, ky, Cq2, Edc, mh, gh, Ephn, N0, nh, Eh, Vhh, DC)

   Calculate DC field contribution for holes (original version).

   Computes the DC field transport contribution to the hole distribution
   evolution. This version uses FFT-based derivative.

   :param DCTrans: Whether to include DC transport terms
   :type DCTrans: bool
   :param ky: Momentum coordinates (1/m), 1D array
   :type ky: ndarray
   :param Cq2: Coupling constant squared, 1D array
   :type Cq2: ndarray
   :param Edc: DC electric field (V/m)
   :type Edc: float
   :param mh: Effective hole mass (kg)
   :type mh: float
   :param gh: Inverse hole lifetime (Hz)
   :type gh: float
   :param Ephn: Average phonon energy (J)
   :type Ephn: float
   :param N0: Phonon occupation number
   :type N0: float
   :param nh: Hole occupation numbers (complex), 1D array
   :type nh: ndarray
   :param Eh: Hole energies (J), 1D array
   :type Eh: ndarray
   :param Vhh: Hole-hole interaction matrix (J), 2D array
   :type Vhh: ndarray
   :param DC: Output DC field contribution (modified in-place), 1D array
   :type DC: ndarray

   :returns: DC array is modified in-place.
   :rtype: None


.. py:function:: CalcI0n(ne, me, ky)

   Calculate electron current.

   Computes the electron current from the electron distribution and momentum.

   :param ne: Electron occupation numbers (complex), 1D array
   :type ne: ndarray
   :param me: Effective electron mass (kg)
   :type me: float
   :param ky: Momentum coordinates (1/m), 1D array
   :type ky: ndarray

   :returns: Electron current (A)
   :rtype: float


.. py:function:: CalcI0(ne, nh, Ee, Eh, VC, dk, ky, I0)

   Calculate total current from electron and hole distributions.

   Computes the total current by calculating drift velocities for both
   electrons and holes, then combining them.

   :param ne: Electron occupation numbers (complex), 1D array
   :type ne: ndarray
   :param nh: Hole occupation numbers (complex), 1D array
   :type nh: ndarray
   :param Ee: Electron energies (J), 1D array
   :type Ee: ndarray
   :param Eh: Hole energies (J), 1D array
   :type Eh: ndarray
   :param VC: Interaction matrix (J), 3D array VC[:,:,2] for electrons, VC[:,:,3] for holes
   :type VC: ndarray
   :param dk: Momentum step size (1/m)
   :type dk: float
   :param ky: Momentum coordinates (1/m), 1D array (unused, kept for interface compatibility)
   :type ky: ndarray
   :param I0: Input value (unused, kept for interface compatibility)
   :type I0: float

   :returns: Total current (A)
   :rtype: float


.. py:function:: EkReNorm(n, En, V)

   Renormalize energy with many-body corrections.

   Computes the renormalized energy including Hartree-Fock corrections:
   Ec(k) = En(k) + sum(n(:) * (V(k,k) - V(k,:))) / 2

   :param n: Carrier occupation numbers, 1D array
   :type n: ndarray
   :param En: Single-particle energies (J), 1D array
   :type En: ndarray
   :param V: Interaction matrix (J), 2D array V[k1, k2]
   :type V: ndarray

   :returns: Renormalized energies (J), 1D array
   :rtype: ndarray


.. py:function:: DriftVt(n, Ec)

   Calculate drift velocity.

   Computes the average drift velocity from the energy gradient and
   carrier distribution: v = sum(dEcdk * n) / sum(n) / hbar

   :param n: Carrier occupation numbers, 1D array
   :type n: ndarray
   :param Ec: Renormalized energies (J), 1D array
   :type Ec: ndarray

   :returns: Drift velocity (m/s)
   :rtype: float

   .. rubric:: Notes

   Uses finite difference to compute dEcdk, with boundary extrapolation.


.. py:function:: Lrtz(a, b)

   Lorentzian function.

   Computes the Lorentzian line shape function: (b/pi) / (a^2 + b^2)

   :param a: Frequency offset or energy difference
   :type a: float or ndarray
   :param b: Half-width at half-maximum (HWHM)
   :type b: float or ndarray

   :returns: Lorentzian function value
   :rtype: float or ndarray


.. py:function:: theta(x)

   Heaviside step function (theta function).

   Computes the step function: (abs(x) + x) / 2 / (abs(x) + small)
   Returns 1 for x > 0, 0 for x <= 0.

   :param x: Input value
   :type x: float or ndarray

   :returns: Step function value (0 or 1, 0 at x=0)
   :rtype: float or ndarray


.. py:function:: FDrift2(Ephn, m, g, ky, n, Cq2, v, N0, x)

   Calculate drift force from phonon interactions.

   Computes the drift force due to phonon emission and absorption processes.

   :param Ephn: Average phonon energy (J)
   :type Ephn: float
   :param m: Carrier mass (kg)
   :type m: float
   :param g: Inverse lifetime (Hz)
   :type g: float
   :param ky: Momentum coordinates (1/m), 1D array
   :type ky: ndarray
   :param n: Carrier occupation numbers, 1D array
   :type n: ndarray
   :param Cq2: Coupling constant squared, 1D array
   :type Cq2: ndarray
   :param v: Drift velocity (m/s)
   :type v: float
   :param N0: Phonon occupation number
   :type N0: float
   :param x: k-dependent delta-function coefficients, 1D array (unused, kept for interface compatibility)
   :type x: ndarray

   :returns: Drift force (N), 1D array
   :rtype: ndarray


.. py:function:: FDrift(Ephn, m, q, dndk, Cq2, v, N0, x)

   Calculate drift force (alternative implementation).

   Computes the drift force using a different approach with dndk derivative.

   :param Ephn: Average phonon energy (J)
   :type Ephn: float
   :param m: Carrier mass (kg)
   :type m: float
   :param q: Momentum coordinates (1/m), 1D array
   :type q: ndarray
   :param dndk: Derivative of carrier occupation with respect to momentum, 1D array
   :type dndk: ndarray
   :param Cq2: Coupling constant squared, 1D array
   :type Cq2: ndarray
   :param v: Drift velocity (m/s)
   :type v: float
   :param N0: Phonon occupation number
   :type N0: float
   :param x: k-dependent delta-function coefficients, 1D array
   :type x: ndarray

   :returns: Drift force (N)
   :rtype: float


.. py:function:: ThetaEM(Ephn, m, g, ky, n, Cq2, v, N0, q, k)

   Calculate emission matrix element.

   Computes the emission rate matrix element for phonon-assisted transitions.

   :param Ephn: Average phonon energy (J)
   :type Ephn: float
   :param m: Carrier mass (kg)
   :type m: float
   :param g: Inverse lifetime (Hz)
   :type g: float
   :param ky: Momentum coordinates (1/m), 1D array
   :type ky: ndarray
   :param n: Carrier occupation numbers, 1D array
   :type n: ndarray
   :param Cq2: Coupling constant squared, 1D array
   :type Cq2: ndarray
   :param v: Drift velocity (m/s)
   :type v: float
   :param N0: Phonon occupation number
   :type N0: float
   :param q: Phonon momentum index (1-based, will be converted to 0-based)
   :type q: int
   :param k: Carrier momentum index (1-based, will be converted to 0-based)
   :type k: int

   :returns: Emission matrix element
   :rtype: float


.. py:function:: ThetaABS(Ephn, m, g, ky, n, Cq2, v, N0, q, k)

   Calculate absorption matrix element.

   Computes the absorption rate matrix element for phonon-assisted transitions.

   :param Ephn: Average phonon energy (J)
   :type Ephn: float
   :param m: Carrier mass (kg)
   :type m: float
   :param g: Inverse lifetime (Hz)
   :type g: float
   :param ky: Momentum coordinates (1/m), 1D array
   :type ky: ndarray
   :param n: Carrier occupation numbers, 1D array
   :type n: ndarray
   :param Cq2: Coupling constant squared, 1D array
   :type Cq2: ndarray
   :param v: Drift velocity (m/s)
   :type v: float
   :param N0: Phonon occupation number
   :type N0: float
   :param q: Phonon momentum index (1-based, will be converted to 0-based)
   :type q: int
   :param k: Carrier momentum index (1-based, will be converted to 0-based)
   :type k: int

   :returns: Absorption matrix element
   :rtype: float


.. py:function:: CalcAvgCoeff(ky, dk, k1, k2, i1, i2, x1, x2, x3, x4)

   Calculate average coefficients for interpolation.

   Computes interpolation coefficients for bilinear interpolation in k-space.
   The function extends the ky array with boundary points and calculates
   coefficients based on the positions k1, k2 and indices i1, i2.

   :param ky: Momentum coordinates (1/m), 1D array
   :type ky: ndarray
   :param dk: Momentum step size (1/m)
   :type dk: float
   :param k1: First momentum value for interpolation
   :type k1: float
   :param k2: Second momentum value for interpolation
   :type k2: float
   :param i1: First index (1-based, will be converted to 0-based)
   :type i1: int
   :param i2: Second index (1-based, will be converted to 0-based)
   :type i2: int
   :param x1: Output coefficient 1 (modified in-place, but Python can't modify floats in-place)
   :type x1: float
   :param x2: Output coefficient 2 (modified in-place, but Python can't modify floats in-place)
   :type x2: float
   :param x3: Output coefficient 3 (modified in-place, but Python can't modify floats in-place)
   :type x3: float
   :param x4: Output coefficient 4 (modified in-place, but Python can't modify floats in-place)
   :type x4: float

   :returns: Tuple containing (x1, x2, x3, x4) coefficients
   :rtype: tuple


.. py:function:: CalcVD(ky, m, n)

   Calculate drift velocity from distribution.

   Computes the average drift velocity from the carrier distribution
   and momentum: v = sum(real(n) * hbar * ky / m) / sum(real(n) + small)

   :param ky: Momentum coordinates (1/m), 1D array
   :type ky: ndarray
   :param m: Carrier mass (kg)
   :type m: float
   :param n: Carrier occupation numbers (complex), 1D array
   :type n: ndarray

   :returns: Drift velocity (m/s)
   :rtype: float


.. py:function:: CalcPD(ky, m, n)

   Calculate momentum from distribution.

   Computes the average momentum from the carrier distribution:
   p = sum(abs(n) * hbar * ky) / sum(abs(n) + small)

   :param ky: Momentum coordinates (1/m), 1D array
   :type ky: ndarray
   :param m: Carrier mass (kg) (unused, kept for interface compatibility)
   :type m: float
   :param n: Carrier occupation numbers (complex), 1D array
   :type n: ndarray

   :returns: Average momentum (kg·m/s)
   :rtype: float


.. py:function:: GetEDrift()

   Get electron drift rate.

   Returns the electron temperature damping rate.

   :returns: Electron temperature damping rate (Hz)
   :rtype: float


.. py:function:: GetHDrift()

   Get hole drift rate.

   Returns the hole temperature damping rate.

   :returns: Hole temperature damping rate (Hz)
   :rtype: float


.. py:function:: GetVEDrift()

   Get electron drift velocity.

   Returns the electron drift velocity.

   :returns: Electron drift velocity (m/s)
   :rtype: float


.. py:function:: GetVHDrift()

   Get hole drift velocity.

   Returns the hole drift velocity.

   :returns: Hole drift velocity (m/s)
   :rtype: float


.. py:function:: dndEk(Ephn, m, q, dndq)

   Calculate derivative of occupation with respect to energy.

   Computes the derivative dndEk from the derivative dndq with respect to
   momentum, using the relationship between energy and momentum.

   :param Ephn: Average phonon energy (J)
   :type Ephn: float
   :param m: Carrier mass (kg)
   :type m: float
   :param q: Momentum coordinates (1/m), 1D array
   :type q: ndarray
   :param dndq: Derivative of occupation with respect to momentum, 1D array
   :type dndq: ndarray

   :returns: Derivative of occupation with respect to energy, 1D array
   :rtype: ndarray


.. py:function:: ThetaEMABS(Ephn, m, q, dndk, Cq2, v)

   Calculate emission-absorption matrix element.

   Computes the combined emission-absorption rate matrix element
   for phonon-assisted transitions using the energy derivative.

   :param Ephn: Average phonon energy (J)
   :type Ephn: float
   :param m: Carrier mass (kg)
   :type m: float
   :param q: Momentum coordinates (1/m), 1D array
   :type q: ndarray
   :param dndk: Derivative of occupation with respect to momentum, 1D array
   :type dndk: ndarray
   :param Cq2: Coupling constant squared, 1D array
   :type Cq2: ndarray
   :param v: Drift velocity (m/s)
   :type v: float

   :returns: Emission-absorption matrix element, 1D array
   :rtype: ndarray


.. py:function:: DC_Step_Scale(ne, nh, ky, Edc, dt)

   DC step using scaling method (legacy code).

   Performs a DC field step by scaling the distribution functions.
   Uses rescale_1D to interpolate the distributions to shifted momentum grids.

   :param ne: Electron occupation numbers (complex), modified in-place, 1D array
   :type ne: ndarray
   :param nh: Hole occupation numbers (complex), modified in-place, 1D array
   :type nh: ndarray
   :param ky: Momentum coordinates (1/m), 1D array
   :type ky: ndarray
   :param Edc: DC electric field (V/m)
   :type Edc: float
   :param dt: Time step (s)
   :type dt: float

   :returns: ne and nh arrays are modified in-place.
   :rtype: None

   .. rubric:: Notes

   The function shifts the momentum grid by -e0*Edc/hbar*dt for electrons
   and +e0*Edc/hbar*dt for holes. This corresponds to the DC field accelerating
   electrons in the negative direction and holes in the positive direction.


.. py:function:: DC_Step_FD(ne, nh, nemid, nhmid, ky, Edc, dt, me, mh)

   DC step using finite difference method (legacy code).

   Performs a DC field step using finite difference derivatives.
   Updates the electron and hole distributions based on the DC field
   and momentum-dependent terms.

   :param ne: Electron occupation numbers (complex), modified in-place, 1D array
   :type ne: ndarray
   :param nh: Hole occupation numbers (complex), modified in-place, 1D array
   :type nh: ndarray
   :param nemid: Midpoint electron occupation numbers (complex), 1D array
   :type nemid: ndarray
   :param nhmid: Midpoint hole occupation numbers (complex), 1D array
   :type nhmid: ndarray
   :param ky: Momentum coordinates (1/m), 1D array
   :type ky: ndarray
   :param Edc: DC electric field (V/m)
   :type Edc: float
   :param dt: Time step (s)
   :type dt: float
   :param me: Effective electron mass (kg)
   :type me: float
   :param mh: Effective hole mass (kg)
   :type mh: float

   :returns: ne and nh arrays are modified in-place.
   :rtype: None


.. py:function:: ShiftN1D(ne, dk)

   Shift 1D distribution in momentum space (legacy code).

   Shifts the distribution function in momentum space by dk using FFT.
   This is equivalent to multiplying by exp(-ii * Y * dk) in Fourier space.

   :param ne: Carrier occupation numbers (complex), modified in-place, 1D array
   :type ne: ndarray
   :param dk: Momentum shift (1/m)
   :type dk: float

   :returns: ne array is modified in-place.
   :rtype: None

   .. rubric:: Notes

   Uses pyfftw for FFT operations.
   The function performs: FFT -> multiply by exp(-ii*Y*dk) -> IFFT


.. py:function:: ShiftN2D(C, dk)

   Shift 2D distribution in momentum space (legacy code).

   Shifts the 2D distribution function in momentum space by dk using FFT.
   This is equivalent to multiplying by exp(-ii * (Y(k1) + Y2(k2)) * dk) in Fourier space.

   :param C: Distribution matrix (complex), modified in-place, 2D array
   :type C: ndarray
   :param dk: Momentum shift (1/m)
   :type dk: float

   :returns: C array is modified in-place.
   :rtype: None

   .. rubric:: Notes

   Uses pyfftw for FFT operations.
   The function performs: FFT -> multiply by exp(-ii*(Y+Y2)*dk) -> IFFT


.. py:function:: Transport(C, Edc, Eac, dt, DCTrans, k1nek2)

   Transport step for distribution matrix (legacy code).

   Performs a transport step on the distribution matrix C by shifting
   in momentum space. Can operate on the full 2D matrix or just the diagonal.

   :param C: Distribution matrix (complex), modified in-place, 2D array
   :type C: ndarray
   :param Edc: DC electric field (V/m)
   :type Edc: float
   :param Eac: AC electric field (V/m)
   :type Eac: float
   :param dt: Time step (s)
   :type dt: float
   :param DCTrans: Whether to include DC transport terms
   :type DCTrans: bool
   :param k1nek2: If True, shift the full 2D matrix; if False, shift only the diagonal
   :type k1nek2: bool

   :returns: C array is modified in-place.
   :rtype: None


.. py:function:: K03(x)

   Modified Bessel function K0 for real argument.

   Computes K0(x) using the complex Bessel function routine.

   :param x: Real argument
   :type x: float

   :returns: Value of K0(x), or 0.0 if x > 100
   :rtype: float

   .. rubric:: Notes

   Returns 0.0 for large arguments (x > 100) to avoid overflow.


.. py:data:: pi

   

.. py:data:: twopi

   

.. py:data:: hbar

   

.. py:data:: eV
   :value: 1.602176634e-19

   

.. py:data:: ii
   :value: 1j

   

.. py:function:: InitializeCoulomb(y, ky, L, Delta0, me, mh, Ee, Eh, ge, gh, alphae, alphah, er, Qy, kkp, screened)

   Initialize the coulomb module and all of its needed quantities.

   This is the main initialization function that sets up all module-level arrays
   required for Coulomb interaction calculations. It calls the various setup functions
   in the correct order, checking if arrays are already initialized to avoid
   redundant calculations.

   :param y: Length coordinates of quantum wire (m), 1D array
   :type y: ndarray
   :param ky: Momentum coordinates of quantum wire (1/m), 1D array
   :type ky: ndarray
   :param L: Length of the quantum wire (m)
   :type L: float
   :param Delta0: Thickness of the quantum wire (m)
   :type Delta0: float
   :param me: Effective electron mass (kg)
   :type me: float
   :param mh: Effective hole mass (kg)
   :type mh: float
   :param Ee: Electron energies (J), 1D array
   :type Ee: ndarray
   :param Eh: Hole energies (J), 1D array
   :type Eh: ndarray
   :param ge: Inverse electron lifetime (Hz)
   :type ge: float
   :param gh: Inverse hole lifetime (Hz)
   :type gh: float
   :param alphae: Level separation between ground and 1st excited state for electrons (1/m)
   :type alphae: float
   :param alphah: Level separation between ground and 1st excited state for holes (1/m)
   :type alphah: float
   :param er: Background dielectric constant (dimensionless)
   :type er: float
   :param Qy: Momentum difference array (1/m), 1D array
   :type Qy: ndarray
   :param kkp: Index mapping array, 2D integer array. Maps (k,q) indices to Qy indices.
   :type kkp: ndarray
   :param screened: Whether to use screened interactions (not used in initialization, but passed through)
   :type screened: bool

   :returns: All arrays are stored as module-level variables (matching Fortran behavior).
   :rtype: None

   .. rubric:: Notes

   The function initializes arrays in the following order:
   1. UnDel - inverse delta function array
   2. k3 - momentum conservation indexing array
   3. qe, qh - momentum difference arrays
   4. Ceh, Cee, Chh - many-body interaction arrays (requires k3 and UnDel)
   5. Veh0, Vee0, Vhh0 - unscreened Coulomb arrays
   6. Chi1De, Chi1Dh - susceptibility arrays (requires qe and qh)

   Each array is only computed if it hasn't been initialized yet, allowing
   for incremental initialization or re-initialization with different parameters.


.. py:function:: Vint(Qyk, y, alphae, alphah, Delta0)

   Calculate the interaction integral for Coulomb potential.

   Computes the integral over spatial coordinates for the Coulomb interaction
   between particles with level separations alphae and alphah. This is used to
   calculate the unscreened Coulomb collision arrays.

   :param Qyk: Momentum difference (1/m)
   :type Qyk: float
   :param y: Length coordinates of quantum wire (m), 1D array
   :type y: ndarray
   :param alphae: Level separation between ground and 1st excited state for electrons (1/m)
   :type alphae: float
   :param alphah: Level separation between ground and 1st excited state for holes (1/m)
   :type alphah: float
   :param Delta0: Thickness of the quantum wire (m)
   :type Delta0: float

   :returns: Interaction integral value (dimensionless)
   :rtype: float

   .. rubric:: Notes

   The integration is performed over a central region of the y array
   (from Ny/4 to 3*Ny/4) to focus on the relevant quantum wire region.
   Uses the modified Bessel function K0 to represent the Coulomb interaction.

   Uses JIT compilation for performance with automatic fallback to pure Python.


.. py:function:: Vehint(k, q, y, ky, alphae, alphah, Delta0)

   Calculate electron-hole interaction integral.

   Computes the interaction integral between an electron at momentum index k
   and a hole at momentum index q. This is similar to Vint but uses the
   momentum difference from the ky array directly.

   :param k: Electron momentum index. Note: Fortran uses 1-based indexing, so if
             calling from Python with 0-based indices, pass k+1 and q+1, or adjust
             the indices before calling.
   :type k: int
   :param q: Hole momentum index. Note: Fortran uses 1-based indexing, so if
             calling from Python with 0-based indices, pass k+1 and q+1, or adjust
             the indices before calling.
   :type q: int
   :param y: Length coordinates of quantum wire (m), 1D array
   :type y: ndarray
   :param ky: Momentum coordinates of quantum wire (1/m), 1D array
   :type ky: ndarray
   :param alphae: Level separation between ground and 1st excited state for electrons (1/m)
   :type alphae: float
   :param alphah: Level separation between ground and 1st excited state for holes (1/m)
   :type alphah: float
   :param Delta0: Thickness of the quantum wire (m)
   :type Delta0: float

   :returns: Electron-hole interaction integral value (dimensionless)
   :rtype: float

   .. rubric:: Notes

   The function uses the momentum difference |ky(k) - ky(q)| to compute
   the interaction. The integration is performed over a central region
   of the y array (from Ny/4 to 3*Ny/4).

   Note on indexing: The Fortran version uses 1-based indexing. If k and q
   are passed as 1-based indices (matching Fortran), they will be converted
   to 0-based for array access. If passed as 0-based, subtract 1 is not needed.


.. py:function:: CalcCoulombArrays(y, ky, er, alphae, alphah, L, Delta0, Qy, kkp, ReadArrays=False, ScrewThis=False)

   Construct the unscreened Coulomb collision arrays.

   Calculates the electron-hole (Veh0), electron-electron (Vee0), and
   hole-hole (Vhh0) unscreened Coulomb interaction matrices for a quantum wire.
   These arrays are used in the Semiconductor Bloch Equations to compute
   many-body interactions.

   :param y: Length coordinates of quantum wire (m), 1D array
   :type y: ndarray
   :param ky: Momentum coordinates of quantum wire (1/m), 1D array
   :type ky: ndarray
   :param er: Background dielectric constant (dimensionless)
   :type er: float
   :param alphae: Level separation between ground and 1st excited state for electrons (1/m)
   :type alphae: float
   :param alphah: Level separation between ground and 1st excited state for holes (1/m)
   :type alphah: float
   :param L: Length of the quantum wire (m)
   :type L: float
   :param Delta0: Thickness of the quantum wire (m)
   :type Delta0: float
   :param Qy: Momentum difference array (1/m), 1D array
   :type Qy: ndarray
   :param kkp: Index mapping array, 2D integer array. Maps (k,q) indices to Qy indices.
               Values >= 0 indicate valid mappings, < 0 indicate invalid.
   :type kkp: ndarray
   :param ReadArrays: If True, read pre-calculated arrays from files (not implemented).
                      Default is False.
   :type ReadArrays: bool, optional
   :param ScrewThis: If True, skip calculation and return zero arrays. Default is False.
   :type ScrewThis: bool, optional

   :returns: (Veh0, Vee0, Vhh0) where:
             - Veh0: Electron-hole interaction matrix (J), shape (N, N)
             - Vee0: Electron-electron interaction matrix (J), shape (N, N)
             - Vhh0: Hole-hole interaction matrix (J), shape (N, N)
             where N = len(ky)
   :rtype: tuple of ndarray

   .. rubric:: Notes

   The function computes the interaction integrals for each momentum difference
   in Qy, then maps these to the (k,q) grid using the kkp index array.
   The calculation uses the Vint function to compute the spatial integrals.

   The interaction matrices are computed as:
   - Veh0(k,q) = (e0^2 / (2π * ε0 * er * L)) * Vint(Qy[kkp(k,q)], y, alphae, alphah, Delta0)
   - Vee0(k,q) = (e0^2 / (2π * ε0 * er * L)) * Vint(Qy[kkp(k,q)], y, alphae, alphae, Delta0)
   - Vhh0(k,q) = (e0^2 / (2π * ε0 * er * L)) * Vint(Qy[kkp(k,q)], y, alphah, alphah, Delta0)


.. py:function:: GaussDelta(a, b)

   (Was commented out in the Fortran code and had implications on the CalcMBArrays function)
   Gaussian delta function approximation.

   Computes a Gaussian approximation to the delta function, used in
   many-body interaction calculations when LorentzDelta is False.

   :param a: Energy difference argument (J)
   :type a: float
   :param b: Broadening parameter (J)
   :type b: float

   :returns: Gaussian delta function value (1/J)
   :rtype: float

   .. rubric:: Notes

   The function implements: 1 / (sqrt(pi) * b) * exp(-(a/b)^2)
   This is a smooth approximation to the delta function with width b.


.. py:function:: MakeK3(ky)

   Construct the k3 indexing array for momentum conservation.

   Creates a 3D array k3 where k3(k1, k2, k4) represents the index k3
   that satisfies the momentum conservation relation: k1 + k2 = k3 + k4.
   This is used in many-body interaction calculations.

   :param ky: Momentum coordinates of quantum wire (1/m), 1D array
   :type ky: ndarray

   :returns: 3D integer array of shape (N, N, N) where N = len(ky).
             Values are 1-based indices (matching Fortran) if valid,
             or 0 if the momentum combination is invalid (out of bounds).
   :rtype: ndarray

   .. rubric:: Notes

   The array is computed as: k3i = k1 + k2 - k4
   If k3i is outside the valid range [1, N], it is set to 0.
   The returned array uses 1-based indexing to match Fortran behavior,
   so valid indices are in the range [1, N], with 0 indicating invalid.


.. py:function:: MakeQs(ky, ae, ah)

   Construct the qe and qh momentum difference arrays.

   Creates arrays representing the momentum differences between states,
   with minimum values set by the level separation parameters ae and ah.
   These arrays are used in screening and interaction calculations.

   :param ky: Momentum coordinates of quantum wire (1/m), 1D array
   :type ky: ndarray
   :param ae: Level separation parameter for electrons (1/m)
   :type ae: float
   :param ah: Level separation parameter for holes (1/m)
   :type ah: float

   :returns: (qe, qh) where:
             - qe: Electron momentum difference array (1/m), shape (N, N)
             - qh: Hole momentum difference array (1/m), shape (N, N)
             where N = len(ky)
   :rtype: tuple of ndarray

   .. rubric:: Notes

   The arrays are computed as:
   - qe(k1, k2) = max(|ky(k2) - ky(k1)|, ae/2)
   - qh(k1, k2) = max(|ky(k2) - ky(k1)|, ah/2)
   This ensures a minimum momentum difference to avoid singularities.


.. py:function:: MakeUnDel(ky)

   Construct the UnDel (1 - delta) array.

   Creates an array representing (1 - delta_ij) where delta_ij is the
   Kronecker delta. This is used to exclude self-interaction terms
   in many-body calculations.

   :param ky: Momentum coordinates of quantum wire (1/m), 1D array
   :type ky: ndarray

   :returns: 2D array of shape (N+1, N+1) where N = len(ky).
             Values are 1.0 except:
             - Row 0 and column 0 are all 0.0
             - Diagonal elements (i, i) for i=1..N are 0.0
   :rtype: ndarray

   .. rubric:: Notes

   The array has an extra row and column (index 0) compared to the
   momentum array size, matching the Fortran implementation which uses
   0-based indexing for the first row/column.


.. py:function:: SetLorentzDelta(boolean)

   Set the LorentzDelta flag for many-body array calculations.

   This function sets a module-level flag that determines whether to use
   Lorentzian broadening (True) or Gaussian delta function (False) in
   the CalcMBArrays function.

   :param boolean: If True, use Lorentzian broadening. If False, use Gaussian delta function.
   :type boolean: bool

   .. rubric:: Notes

   This matches the Fortran interface where SetLorentzDelta sets a module-level
   variable. The flag affects the behavior of CalcMBArrays when called without
   explicitly specifying the LorentzDelta parameter.


.. py:function:: CalcMBArrays(ky, Ee, Eh, ge, gh, k3, UnDel, LorentzDelta=None)

   Calculate the many-body interaction arrays.

   Computes the electron-hole (Ceh), electron-electron (Cee), and
   hole-hole (Chh) many-body interaction arrays used in the Semiconductor
   Bloch Equations. These arrays represent the collision integrals for
   carrier-carrier interactions.

   :param ky: Momentum coordinates of quantum wire (1/m), 1D array
   :type ky: ndarray
   :param Ee: Electron energies (J), 1D array
   :type Ee: ndarray
   :param Eh: Hole energies (J), 1D array
   :type Eh: ndarray
   :param ge: Electron inverse lifetime (Hz)
   :type ge: float
   :param gh: Hole inverse lifetime (Hz)
   :type gh: float
   :param k3: 3D indexing array from MakeK3, shape (N, N, N)
   :type k3: ndarray
   :param UnDel: 2D array from MakeUnDel, shape (N+1, N+1)
   :type UnDel: ndarray
   :param LorentzDelta: If True, use Lorentzian broadening. If False, use Gaussian delta function.
                        If None (default), uses the module-level value set by SetLorentzDelta.
   :type LorentzDelta: bool, optional

   :returns: (Ceh, Cee, Chh) where:
             - Ceh: Electron-hole interaction array (1/J), shape (N+1, N+1, N+1)
             - Cee: Electron-electron interaction array (1/J), shape (N+1, N+1, N+1)
             - Chh: Hole-hole interaction array (1/J), shape (N+1, N+1, N+1)
             where N = len(ky). The arrays use 0-based indexing for the first dimension
             to match Fortran's 0:N range.
   :rtype: tuple of ndarray

   .. rubric:: Notes

   The function computes interaction rates using either:
   - Lorentzian broadening: 2*gamma * UnDel / ((E_diff)^2 + (hbar*gamma)^2)
   - Gaussian delta function: (2π/hbar) * UnDel * GaussDelta(E_diff, hbar*gamma)

   The arrays are indexed with 0-based first index (0..N) to match Fortran's
   allocation of arrays with bounds (0:N, 0:N, 0:N).


.. py:function:: GetChi1Dqw(alphae, alphah, Delta0, epsr, game, gamh, ky, Ee, Eh, ne, nh, qq, w)

   Calculate the 1D quantum wire susceptibility (chi) for a given momentum and frequency.

   Computes the real and imaginary parts of the susceptibility chi(q, w) for a quantum wire,
   which describes the response of the system to external perturbations. This is used in
   screening calculations.

   :param alphae: Level separation parameter for electrons (1/m)
   :type alphae: float
   :param alphah: Level separation parameter for holes (1/m)
   :type alphah: float
   :param Delta0: Thickness of the quantum wire (m)
   :type Delta0: float
   :param L: Length of the quantum wire (m)
   :type L: float
   :param epsr: Background dielectric constant (dimensionless)
   :type epsr: float
   :param game: Electron inverse lifetime array (Hz), 1D array
   :type game: ndarray
   :param gamh: Hole inverse lifetime array (Hz), 1D array
   :type gamh: ndarray
   :param ky: Momentum coordinates of quantum wire (1/m), 1D array
   :type ky: ndarray
   :param Ee: Electron energies (J), 1D array
   :type Ee: ndarray
   :param Eh: Hole energies (J), 1D array
   :type Eh: ndarray
   :param ne: Electron population array, 1D array
   :type ne: ndarray
   :param nh: Hole population array, 1D array
   :type nh: ndarray
   :param qq: Momentum value (1/m)
   :type qq: float
   :param w: Frequency (rad/s)
   :type w: float

   :returns: (chir, chii) where:
             - chir: Real part of susceptibility (dimensionless)
             - chii: Imaginary part of susceptibility (dimensionless)
   :rtype: tuple of float

   .. rubric:: Notes

   The function computes the susceptibility by summing over momentum states,
   taking into account the energy differences and broadening due to lifetimes.
   The calculation uses the K03 Bessel function for the interaction kernel.


.. py:function:: GetEps1Dqw(alphae, alphah, Delta0, epsr, me, mh, n1D, q, w)

   Calculate the 1D quantum wire dielectric function epsilon(q, w).

   Computes the real and imaginary parts of the dielectric function for a quantum wire,
   which describes how the system responds to electromagnetic fields. This is used in
   screening calculations.

   :param alphae: Level separation parameter for electrons (1/m)
   :type alphae: float
   :param alphah: Level separation parameter for holes (1/m)
   :type alphah: float
   :param Delta0: Thickness of the quantum wire (m)
   :type Delta0: float
   :param L: Length of the quantum wire (m)
   :type L: float
   :param epsr: Background dielectric constant (dimensionless)
   :type epsr: float
   :param me: Electron effective mass (kg)
   :type me: float
   :param mh: Hole effective mass (kg)
   :type mh: float
   :param n1D: 1D carrier density (1/m)
   :type n1D: float
   :param q: Momentum (1/m)
   :type q: float
   :param w: Frequency (rad/s)
   :type w: float

   :returns: (epr, epi) where:
             - epr: Real part of dielectric function (dimensionless)
             - epi: Imaginary part of dielectric function (dimensionless)
   :rtype: tuple of float

   .. rubric:: Notes

   The function computes the dielectric function using the Lindhard formula
   for a 1D system, with contributions from both electrons and holes.


.. py:function:: CalcChi1D(ky, alphae, alphah, Delta0, epsr, me, mh, qe, qh)

   Calculate the 1D susceptibility arrays Chi1De and Chi1Dh.

   Computes the electron and hole susceptibility matrices used in screening calculations.
   These arrays are stored as module-level variables for use in other functions.

   :param ky: Momentum coordinates of quantum wire (1/m), 1D array
   :type ky: ndarray
   :param alphae: Level separation parameter for electrons (1/m)
   :type alphae: float
   :param alphah: Level separation parameter for holes (1/m)
   :type alphah: float
   :param Delta0: Thickness of the quantum wire (m)
   :type Delta0: float
   :param epsr: Background dielectric constant (dimensionless)
   :type epsr: float
   :param me: Electron effective mass (kg)
   :type me: float
   :param mh: Hole effective mass (kg)
   :type mh: float
   :param qe: Electron momentum difference array from MakeQs, shape (N, N)
   :type qe: ndarray
   :param qh: Hole momentum difference array from MakeQs, shape (N, N)
   :type qh: ndarray

   :returns: (Chi1De, Chi1Dh) where:
             - Chi1De: Electron susceptibility array, shape (N, N)
             - Chi1Dh: Hole susceptibility array, shape (N, N)
             where N = len(ky)
   :rtype: tuple of ndarray

   .. rubric:: Notes

   The arrays are also stored as module-level variables _Chi1De and _Chi1Dh
   for compatibility with Fortran module behavior.


.. py:function:: Eps1D(n1D, Nk)

   Calculate the 1D dielectric function matrix.

   Computes the dielectric function matrix Eps1D for a given 1D carrier density,
   using the pre-computed module-level susceptibility arrays Chi1De and Chi1Dh.

   :param n1D: 1D carrier density (1/m)
   :type n1D: float
   :param Nk: Size of momentum grid (should match size of module-level arrays)
   :type Nk: int

   :returns: 2D array of shape (Nk, Nk) representing the dielectric function matrix.
   :rtype: ndarray

   .. rubric:: Notes

   The function computes: Eps1D = 1 - Chi1De * 2*log(...) - Chi1Dh * 2*log(...)
   where the logarithms involve momentum-dependent terms.
   Uses module-level variables _Chi1De, _Chi1Dh, _qe, _qh (matching Fortran behavior).


.. py:function:: CalcScreenedArrays(screened, L, ne, nh, VC, E1D)

   Calculate screened Coulomb interaction arrays.

   Computes the screened version of the Coulomb interaction matrices by dividing
   by the dielectric function. If screening is disabled, returns the unscreened arrays.

   :param screened: If True, apply screening. If False, return unscreened arrays.
   :type screened: bool
   :param L: Length of the quantum wire (m)
   :type L: float
   :param ne: Electron population array, 1D array
   :type ne: ndarray
   :param nh: Hole population array, 1D array
   :type nh: ndarray
   :param VC: Input/output array for interaction matrices, shape (N, N, 3).
              On input: should contain unscreened arrays (or will be filled from module-level).
              On output: contains screened arrays if screened=True, unscreened otherwise.
   :type VC: ndarray
   :param E1D: Input/output array for dielectric function, shape (N, N).
               On input: can be any array (will be overwritten).
               On output: contains dielectric function matrix if screened=True, ones otherwise.
   :type E1D: ndarray

   :returns: Arrays are modified in-place (matching Fortran intent(inout) behavior).
   :rtype: None

   .. rubric:: Notes

   The function uses module-level variables _Veh0, _Vee0, _Vhh0, _qe, _qh
   (matching Fortran module behavior). If screening is enabled, computes the
   dielectric function and divides the interaction matrices by it.


.. py:function:: CalcMVeh(p, VC, MVeh, k3=None, UnDel=None)

   Calculate the MVeh array for Semiconductor Bloch Equations.

   Computes the many-body electron-hole interaction term MVeh used in the
   Semiconductor Bloch Equations. This represents the Coulomb interaction
   contribution to the polarization dynamics.

   :param p: Polarization array, shape (N, N, Nf) where N is momentum grid size
             and Nf is number of frequency/time points
   :type p: ndarray
   :param VC: Screened Coulomb interaction matrices, shape (N, N, 3)
              VC[:, :, 0] = Veh (electron-hole)
              VC[:, :, 1] = Vee (electron-electron)
              VC[:, :, 2] = Vhh (hole-hole)
   :type VC: ndarray
   :param MVeh: Output array for MVeh calculation, shape (N, N, Nf).
                Will be modified in-place (matching Fortran intent(inout)).
   :type MVeh: ndarray
   :param k3: 3D indexing array from MakeK3, shape (N, N, N).
              If None, uses module-level _k3.
   :type k3: ndarray, optional
   :param UnDel: 2D array from MakeUnDel, shape (N+1, N+1).
                 If None, uses module-level _UnDel.
   :type UnDel: ndarray, optional

   :returns: MVeh is modified in-place (matching Fortran intent(inout) behavior).
   :rtype: None

   .. rubric:: Notes

   The calculation sums over momentum states q, using the momentum conservation
   relation k3(kp, q, k) to find qp. The UnDel factors exclude self-interaction terms.
   Uses JIT compilation with parallel execution (matching Fortran OpenMP behavior).


.. py:function:: undell(k, q)

   Wrapper function for UnDel array access.

   Provides a simple interface to access the UnDel (1 - delta) array.
   This is a convenience function matching the Fortran interface.

   :param k: First index (1-based, matching Fortran)
   :type k: int
   :param q: Second index (1-based, matching Fortran)
   :type q: int

   :returns: Value of UnDel(k, q) from module-level array.
   :rtype: float

   .. rubric:: Notes

   This function accesses the module-level _UnDel array. The indices
   are expected to be 1-based to match Fortran behavior.


.. py:function:: BGRenorm(C, D, VC, BGR, UnDel=None)

   Calculate band gap renormalization.

   Computes the band gap renormalization BGR due to many-body Coulomb interactions.
   This accounts for the shift in band gap energy due to carrier-carrier interactions.

   :param C: Electron density matrix, shape (N, N), complex
   :type C: ndarray
   :param D: Hole density matrix, shape (N, N), complex
   :type D: ndarray
   :param VC: Screened Coulomb interaction matrices, shape (N, N, 3)
              VC[:, :, 0] = Veh (electron-hole)
              VC[:, :, 1] = Vee (electron-electron)
              VC[:, :, 2] = Vhh (hole-hole)
   :type VC: ndarray
   :param BGR: Output array for band gap renormalization, shape (N, N), complex.
               Will be modified in-place (matching Fortran intent(inout)).
   :type BGR: ndarray
   :param UnDel: 2D array from MakeUnDel, shape (N+1, N+1).
                 If None, uses module-level _UnDel.
   :type UnDel: ndarray, optional

   :returns: BGR is modified in-place (matching Fortran intent(inout) behavior).
   :rtype: None

   .. rubric:: Notes

   The function extracts diagonal elements from C and D to get carrier populations,
   then computes the renormalization using hole-hole and electron-electron interactions.
   The UnDel factors exclude self-interaction terms.
   Uses JIT compilation with parallel execution (matching Fortran OpenMP behavior).


.. py:function:: EeRenorm(ne, VC, BGR, UnDel=None)

   Calculate electron energy renormalization.

   Computes the electron energy renormalization due to many-body Coulomb interactions.
   This accounts for the shift in electron energy levels due to electron-electron interactions.

   :param ne: Electron population array, shape (N,), complex
   :type ne: ndarray
   :param VC: Screened Coulomb interaction matrices, shape (N, N, 3)
              VC[:, :, 1] = Vee (electron-electron) is used
   :type VC: ndarray
   :param BGR: Output array for electron energy renormalization, shape (N, N), complex.
               Will be modified in-place (matching Fortran intent(inout)).
   :type BGR: ndarray
   :param UnDel: 2D array from MakeUnDel, shape (N+1, N+1).
                 If None, uses module-level _UnDel.
   :type UnDel: ndarray, optional

   :returns: BGR is modified in-place (matching Fortran intent(inout) behavior).
   :rtype: None

   .. rubric:: Notes

   The function computes the electron energy shift using electron-electron
   interactions, with terms that include both direct and exchange contributions.
   The UnDel factors exclude self-interaction terms.
   Uses JIT compilation with parallel execution (matching Fortran OpenMP behavior).


.. py:function:: EhRenorm(nh, VC, BGR, UnDel=None)

   Calculate hole energy renormalization.

   Computes the hole energy renormalization due to many-body Coulomb interactions.
   This accounts for the shift in hole energy levels due to hole-hole interactions.

   :param nh: Hole population array, shape (N,), complex
   :type nh: ndarray
   :param VC: Screened Coulomb interaction matrices, shape (N, N, 3)
              VC[:, :, 2] = Vhh (hole-hole) is used
   :type VC: ndarray
   :param BGR: Output array for hole energy renormalization, shape (N, N), complex.
               Will be modified in-place (matching Fortran intent(inout)).
   :type BGR: ndarray
   :param UnDel: 2D array from MakeUnDel, shape (N+1, N+1).
                 If None, uses module-level _UnDel.
   :type UnDel: ndarray, optional

   :returns: BGR is modified in-place (matching Fortran intent(inout) behavior).
   :rtype: None

   .. rubric:: Notes

   The function computes the hole energy shift using hole-hole interactions,
   with terms that include both direct and exchange contributions.
   The UnDel factors exclude self-interaction terms.
   Uses JIT compilation with parallel execution (matching Fortran OpenMP behavior).


.. py:function:: MBCE2(ne0, nh0, ky, Ee, Eh, VC, geh, ge, Win, Wout, k3=None, Ceh=None, Cee=None)

   Calculate the Many-body Coulomb In/Out rates for electrons (version 2).

   Computes the many-body relaxation rates Win and Wout for electrons due to
   electron-hole and electron-electron Coulomb interactions. These represent
   non-Hartree-Fock terms in the many-body dynamics.

   :param ne0: Electron population array, shape (Nk,), real
   :type ne0: ndarray
   :param nh0: Hole population array, shape (Nk,), real
   :type nh0: ndarray
   :param ky: Momentum coordinates (not used in calculation but kept for interface compatibility)
   :type ky: ndarray
   :param Ee: Electron energies (not used in calculation but kept for interface compatibility)
   :type Ee: ndarray
   :param Eh: Hole energies (not used in calculation but kept for interface compatibility)
   :type Eh: ndarray
   :param VC: Screened Coulomb interaction matrices, shape (Nk, Nk, 3)
              VC[:, :, 0] = Veh (electron-hole)
              VC[:, :, 1] = Vee (electron-electron)
   :type VC: ndarray
   :param geh: Electron-hole inverse lifetime (not used in calculation but kept for interface)
   :type geh: float
   :param ge: Electron inverse lifetime (not used in calculation but kept for interface)
   :type ge: float
   :param Win: Input/output array for in-scattering rates, shape (Nk,), real.
               Will be modified in-place (matching Fortran intent(inout)).
   :type Win: ndarray
   :param Wout: Input/output array for out-scattering rates, shape (Nk,), real.
                Will be modified in-place (matching Fortran intent(inout)).
   :type Wout: ndarray
   :param k3: 3D indexing array from MakeK3, shape (Nk, Nk, Nk).
              If None, uses module-level _k3.
   :type k3: ndarray, optional
   :param Ceh: Electron-hole many-body interaction array, shape (Nk, Nk, Nk).
               If None, uses module-level _Ceh.
   :type Ceh: ndarray, optional
   :param Cee: Electron-electron many-body interaction array, shape (Nk, Nk, Nk).
               If None, uses module-level _Cee.
   :type Cee: ndarray, optional

   :returns: Win and Wout are modified in-place (matching Fortran intent(inout) behavior).
   :rtype: None

   .. rubric:: Notes

   Uses JIT compilation with parallel execution (matching Fortran OpenMP behavior).
   The function computes scattering rates due to electron-hole and electron-electron
   interactions, accounting for Pauli blocking factors (1 - n) and occupation factors n.


.. py:function:: MBCE(ne0, nh0, ky, Ee, Eh, VC, geh, ge, Win, Wout, k3=None, Ceh=None, Cee=None)

   Calculate the Many-body Coulomb In/Out rates for electrons.

   Computes the many-body relaxation rates Win and Wout for electrons due to
   electron-hole and electron-electron Coulomb interactions. This is identical
   to MBCE2 but kept as a separate function to match Fortran structure.

   :param ne0: Electron population array, shape (Nk,), real
   :type ne0: ndarray
   :param nh0: Hole population array, shape (Nk,), real
   :type nh0: ndarray
   :param ky: Momentum coordinates (not used in calculation but kept for interface compatibility)
   :type ky: ndarray
   :param Ee: Electron energies (not used in calculation but kept for interface compatibility)
   :type Ee: ndarray
   :param Eh: Hole energies (not used in calculation but kept for interface compatibility)
   :type Eh: ndarray
   :param VC: Screened Coulomb interaction matrices, shape (Nk, Nk, 3)
              VC[:, :, 0] = Veh (electron-hole)
              VC[:, :, 1] = Vee (electron-electron)
   :type VC: ndarray
   :param geh: Electron-hole inverse lifetime (not used in calculation but kept for interface)
   :type geh: float
   :param ge: Electron inverse lifetime (not used in calculation but kept for interface)
   :type ge: float
   :param Win: Input/output array for in-scattering rates, shape (Nk,), real.
               Will be modified in-place (matching Fortran intent(inout)).
   :type Win: ndarray
   :param Wout: Input/output array for out-scattering rates, shape (Nk,), real.
                Will be modified in-place (matching Fortran intent(inout)).
   :type Wout: ndarray
   :param k3: 3D indexing array from MakeK3, shape (Nk, Nk, Nk).
              If None, uses module-level _k3.
   :type k3: ndarray, optional
   :param Ceh: Electron-hole many-body interaction array, shape (Nk, Nk, Nk).
               If None, uses module-level _Ceh.
   :type Ceh: ndarray, optional
   :param Cee: Electron-electron many-body interaction array, shape (Nk, Nk, Nk).
               If None, uses module-level _Cee.
   :type Cee: ndarray, optional

   :returns: Win and Wout are modified in-place (matching Fortran intent(inout) behavior).
   :rtype: None

   .. rubric:: Notes

   Uses JIT compilation with parallel execution (matching Fortran OpenMP behavior).
   This function is identical to MBCE2 but kept separate to match Fortran code structure.


.. py:function:: MBCH(ne0, nh0, ky, Ee, Eh, VC, geh, gh, Win, Wout, k3=None, Ceh=None, Chh=None)

   Calculate the Many-body Coulomb In/Out rates for holes.

   Computes the many-body relaxation rates Win and Wout for holes due to
   electron-hole and hole-hole Coulomb interactions. These represent
   non-Hartree-Fock terms in the many-body dynamics.

   :param ne0: Electron population array, shape (Nk,), real
   :type ne0: ndarray
   :param nh0: Hole population array, shape (Nk,), real
   :type nh0: ndarray
   :param ky: Momentum coordinates (not used in calculation but kept for interface compatibility)
   :type ky: ndarray
   :param Ee: Electron energies (not used in calculation but kept for interface compatibility)
   :type Ee: ndarray
   :param Eh: Hole energies (not used in calculation but kept for interface compatibility)
   :type Eh: ndarray
   :param VC: Screened Coulomb interaction matrices, shape (Nk, Nk, 3)
              VC[:, :, 0] = Veh (electron-hole)
              VC[:, :, 2] = Vhh (hole-hole)
   :type VC: ndarray
   :param geh: Electron-hole inverse lifetime (not used in calculation but kept for interface)
   :type geh: float
   :param gh: Hole inverse lifetime (not used in calculation but kept for interface)
   :type gh: float
   :param Win: Input/output array for in-scattering rates, shape (Nk,), real.
               Will be modified in-place (matching Fortran intent(inout)).
   :type Win: ndarray
   :param Wout: Input/output array for out-scattering rates, shape (Nk,), real.
                Will be modified in-place (matching Fortran intent(inout)).
   :type Wout: ndarray
   :param k3: 3D indexing array from MakeK3, shape (Nk, Nk, Nk).
              If None, uses module-level _k3.
   :type k3: ndarray, optional
   :param Ceh: Electron-hole many-body interaction array, shape (Nk, Nk, Nk).
               If None, uses module-level _Ceh.
   :type Ceh: ndarray, optional
   :param Chh: Hole-hole many-body interaction array, shape (Nk, Nk, Nk).
               If None, uses module-level _Chh.
   :type Chh: ndarray, optional

   :returns: Win and Wout are modified in-place (matching Fortran intent(inout) behavior).
   :rtype: None

   .. rubric:: Notes

   Uses JIT compilation with parallel execution (matching Fortran OpenMP behavior).
   The function computes scattering rates due to electron-hole and hole-hole
   interactions, accounting for Pauli blocking factors (1 - n) and occupation factors n.


.. py:data:: hbar

   

.. py:data:: kB

   

.. py:data:: ii
   :value: 1j

   

.. py:function:: InitializePhonons(ky, Ee, Eh, L, epsr, Gph, Oph)

   Initialize phonon interaction matrices (Unecessary the jit version?).

   Sets up the electron and hole phonon interaction matrices EP, HP
   and their transposes EPT, HPT. Also calculates the scaling factor Vscale.

   :param ky: Momentum coordinates (1/m), 1D array
   :type ky: ndarray
   :param Ee: Electron energies (J), 1D array
   :type Ee: ndarray
   :param Eh: Hole energies (J), 1D array
   :type Eh: ndarray
   :param L: Length parameter (unused, kept for interface compatibility)
   :type L: float
   :param epsr: Dielectric constant
   :type epsr: float
   :param Gph: Phonon damping rate (Hz)
   :type Gph: float
   :param Oph: Phonon frequency (Hz)
   :type Oph: float

   :rtype: None

   .. rubric:: Notes

   Sets module-level variables:
   - _NO: Bose distribution for phonons
   - _idel: Identity exclusion matrix (1 where k != k1, 0 where k == k1)
   - _EP, _EPT: Electron phonon interaction matrix and its transpose
   - _HP, _HPT: Hole phonon interaction matrix and its transpose
   - _Vscale: Scaling constant for Coulomb interactions


.. py:function:: MBPE(ne, VC, E1D, Win, Wout)

   Many-body phonon-electron interaction.

   Calculates the in-scattering and out-scattering rates for electrons
   due to phonon interactions.

   :param ne: Electron carrier populations, 1D array
   :type ne: ndarray
   :param VC: Coulomb interaction array, shape (Nk, Nk, 3)
              Uses VC[:, :, 1] for electron-electron interaction (Fortran uses VC(:,:,2) which is 1-based)
   :type VC: ndarray
   :param E1D: 1D energy array, shape (Nk, Nk)
   :type E1D: ndarray
   :param Win: In-scattering rates (modified in-place), 1D array
   :type Win: ndarray
   :param Wout: Out-scattering rates (modified in-place), 1D array
   :type Wout: ndarray

   :rtype: None

   .. rubric:: Notes

   Modifies Win and Wout in-place.
   Uses module-level variables _EPT, _EP, _Vscale.


.. py:function:: MBPH(nh, VC, E1D, Win, Wout)

   Many-body phonon-hole interaction.

   Calculates the in-scattering and out-scattering rates for holes
   due to phonon interactions.

   :param nh: Hole carrier populations, 1D array
   :type nh: ndarray
   :param VC: Coulomb interaction array, shape (Nk, Nk, 3)
              Uses VC[:, :, 2] for hole-hole interaction (Fortran uses VC(:,:,3) which is 1-based)
   :type VC: ndarray
   :param E1D: 1D energy array, shape (Nk, Nk)
   :type E1D: ndarray
   :param Win: In-scattering rates (modified in-place), 1D array
   :type Win: ndarray
   :param Wout: Out-scattering rates (modified in-place), 1D array
   :type Wout: ndarray

   :rtype: None

   .. rubric:: Notes

   Modifies Win and Wout in-place.
   Uses module-level variables _HPT, _HP, _Vscale.


.. py:function:: Cq2(q, V, E1D)

   Calculate Cq for use in the DC Field module.

   Computes the phonon coupling constant Cq for a given momentum array.

   :param q: Momentum coordinates (1/m), 1D array
   :type q: ndarray
   :param V: Interaction potential array, shape (Nk, Nk)
   :type V: ndarray
   :param E1D: 1D energy array, shape (Nk, Nk)
   :type E1D: ndarray

   :returns: Cq values, 1D array of same length as q
   :rtype: ndarray

   .. rubric:: Notes

   Uses module-level variable _Vscale for scaling.
   The function maps q values to indices in V and E1D arrays.


.. py:function:: FermiDistr(En)

   Calculate Fermi-Dirac distribution.

   Computes the Fermi-Dirac distribution assuming host temperature
   and Fermi Energy = 0.

   :param En: Energy (J)
   :type En: float or ndarray

   :returns: Fermi-Dirac distribution value: 1 / (exp(En / (kB * T)) + 1)
   :rtype: float or ndarray

   .. rubric:: Notes

   Uses module-level variable _Temp for temperature.
   Note: Fortran returns complex type, but the value is always real, so Python returns float.


.. py:function:: BoseDistr(En)

   Calculate Bose-Einstein distribution.

   Computes the Bose-Einstein distribution for phonons.

   :param En: Energy (J)
   :type En: float or ndarray

   :returns: Bose-Einstein distribution value: 1 / (exp(En / (kB * T)) - 1)
   :rtype: float or ndarray

   .. rubric:: Notes

   Uses module-level variable _Temp for temperature.


.. py:function:: N00()

   Get the Bose distribution value for phonons.

   Returns the module-level variable _NO which is the Bose function
   for thermal equilibrium longitudinal-optical phonons in host.

   :returns: Bose distribution value NO
   :rtype: float


