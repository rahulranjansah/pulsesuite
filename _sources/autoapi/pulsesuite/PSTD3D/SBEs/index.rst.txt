pulsesuite.PSTD3D.SBEs
======================

.. py:module:: pulsesuite.PSTD3D.SBEs

.. autoapi-nested-parse::

   Semiconductor Bloch Equations (SBEs) solver for quantum wire simulations.

   This module solves the 1D Semiconductor Bloch equations in support of
   propagation simulations for a quantum wire.



Attributes
----------

.. autoapisummary::

   pulsesuite.PSTD3D.SBEs.eV
   pulsesuite.PSTD3D.SBEs.me0
   pulsesuite.PSTD3D.SBEs.hbar
   pulsesuite.PSTD3D.SBEs.e0
   pulsesuite.PSTD3D.SBEs.eps0
   pulsesuite.PSTD3D.SBEs.pi
   pulsesuite.PSTD3D.SBEs.twopi
   pulsesuite.PSTD3D.SBEs.ii


Classes
-------

.. autoapisummary::

   pulsesuite.PSTD3D.SBEs.SBESolver


Functions
---------

.. autoapisummary::

   pulsesuite.PSTD3D.SBEs.QWCalculator
   pulsesuite.PSTD3D.SBEs.Checkout
   pulsesuite.PSTD3D.SBEs.Checkin
   pulsesuite.PSTD3D.SBEs.Preparation
   pulsesuite.PSTD3D.SBEs.CalcH
   pulsesuite.PSTD3D.SBEs.chiqw
   pulsesuite.PSTD3D.SBEs.getqc
   pulsesuite.PSTD3D.SBEs.QWArea
   pulsesuite.PSTD3D.SBEs.ShutOffOptics
   pulsesuite.PSTD3D.SBEs.ReadQWParams
   pulsesuite.PSTD3D.SBEs.ReadMBParams
   pulsesuite.PSTD3D.SBEs.WriteSBEsData
   pulsesuite.PSTD3D.SBEs.ReadSBEsData
   pulsesuite.PSTD3D.SBEs.Relaxation
   pulsesuite.PSTD3D.SBEs.RelaxationE
   pulsesuite.PSTD3D.SBEs.RelaxationH
   pulsesuite.PSTD3D.SBEs.dpdt
   pulsesuite.PSTD3D.SBEs.dCdt
   pulsesuite.PSTD3D.SBEs.dDdt
   pulsesuite.PSTD3D.SBEs.write_statistics
   pulsesuite.PSTD3D.SBEs.CalcMeh
   pulsesuite.PSTD3D.SBEs.CalcWnn
   pulsesuite.PSTD3D.SBEs.CalcXqw
   pulsesuite.PSTD3D.SBEs.RecordEpsLqw
   pulsesuite.PSTD3D.SBEs.RecordXqw
   pulsesuite.PSTD3D.SBEs.GetArrays
   pulsesuite.PSTD3D.SBEs.MakeKKP
   pulsesuite.PSTD3D.SBEs.kindex
   pulsesuite.PSTD3D.SBEs.InitializeSBE
   pulsesuite.PSTD3D.SBEs.SBECalculator
   pulsesuite.PSTD3D.SBEs.InitializeSBE
   pulsesuite.PSTD3D.SBEs.QWCalculator
   pulsesuite.PSTD3D.SBEs.chiqw
   pulsesuite.PSTD3D.SBEs.getqc
   pulsesuite.PSTD3D.SBEs.QWArea
   pulsesuite.PSTD3D.SBEs.ShutOffOptics
   pulsesuite.PSTD3D.SBEs.WriteSBEsData
   pulsesuite.PSTD3D.SBEs.ReadSBEsData


Module Contents
---------------

.. py:data:: eV
   :value: 1.602176634e-19


.. py:data:: me0

.. py:data:: hbar

.. py:data:: e0

.. py:data:: eps0

.. py:data:: pi

.. py:data:: twopi

.. py:data:: ii
   :value: 1j


.. py:function:: QWCalculator(Exx, Eyy, Ezz, Vrr, rr, q, dt, w, Pxx, Pyy, Pzz, Rho, DoQWP, DoQWDl)

   Time-evolve the source terms of the quantum wire for Maxwell's equations.

   Solves the 1D Semiconductor Bloch equations and calculates polarization
   and charge density source terms for propagation simulations.

   :param Exx: X-component total electric field in propagation space
   :type Exx: ndarray (complex)
   :param Eyy: Y-component total electric field in propagation space
   :type Eyy: ndarray (complex)
   :param Ezz: Z-component electric field in propagation space
   :type Ezz: ndarray (complex)
   :param Vrr: Potential electric field in propagation space
   :type Vrr: ndarray (complex)
   :param rr: QW spatial array (m)
   :type rr: ndarray (float)
   :param q: QW momentum array (1/m)
   :type q: ndarray (float)
   :param dt: Time step (s)
   :type dt: float
   :param w: Wire index (which wire to calculate for)
   :type w: int
   :param Pxx: X polarization output (modified in-place)
   :type Pxx: ndarray (complex)
   :param Pyy: Y polarization output (modified in-place)
   :type Pyy: ndarray (complex)
   :param Pzz: Z polarization output (modified in-place)
   :type Pzz: ndarray (complex)
   :param Rho: Free charge density output (modified in-place)
   :type Rho: ndarray (complex)
   :param DoQWP: Boolean flag [should propagator use QW polarization] (modified in-place)
   :type DoQWP: list
   :param DoQWDl: Boolean flag [should propagator use longitudinal field] (modified in-place)
   :type DoQWDl: list

   :returns: All outputs are modified in-place
   :rtype: None

   .. rubric:: Notes

   This function:
   - Updates module-level time counters (xxx, jjj, t)
   - Allocates arrays on first call
   - Calls Prop2QW to convert propagation fields to QW fields
   - Calls SBECalculator to solve the SBEs
   - Calls QW2Prop to convert back to propagation space
   - Calculates energy transfer and writes to files
   - Only activates when field is strong enough (controlled by _wireoff)


.. py:function:: Checkout(p1, p2, C1, C2, D1, D2, w)

   Check out coherence matrices from module storage for wire w.

   Retrieves previous time steps from module-level arrays for processing.


.. py:function:: Checkin(p1, p2, p3, C1, C2, C3, D1, D2, D3, w)

   Check in updated coherence matrices to module storage for wire w.

   Stores current and future time steps to module-level arrays.


.. py:function:: Preparation(p2, C2, D2, Ex, Ey, Ez, Vr, w, Heh, Hee, Hhh, VC, E1D, GamE, GamH, OffG, Rsp)

   Prepare Hamiltonians, screening, and dephasing arrays for SBE time step.

   This function calculates all the arrays needed for one time step of the
   semiconductor Bloch equations:
   - Dipole coupling matrix M^{eh} (light-matter interaction)
   - Monopole coupling matrices W^{ee}, W^{hh} (free-carrier potentials)
   - Hamiltonian matrices H^{eh}, H^{ee}, H^{hh} (including many-body effects)
   - Screened Coulomb interaction arrays VC, E1D
   - Diagonal dephasing rates γ_e, γ_h
   - Off-diagonal dephasing rates Γ^{off}
   - Spontaneous emission rates R_sp

   :param p2: Electron-hole coherence matrix at previous time step
   :type p2: ndarray (complex), shape (Nk, Nk)
   :param C2: Electron-electron coherence matrix at previous time step
   :type C2: ndarray (complex), shape (Nk, Nk)
   :param D2: Hole-hole coherence matrix at previous time step
   :type D2: ndarray (complex), shape (Nk, Nk)
   :param Ex: Electric field components in momentum space
   :type Ex: ndarray (complex), shape (Nr,)
   :param Ey: Electric field components in momentum space
   :type Ey: ndarray (complex), shape (Nr,)
   :param Ez: Electric field components in momentum space
   :type Ez: ndarray (complex), shape (Nr,)
   :param Vr: Electric potential from free charge in momentum space
   :type Vr: ndarray (complex), shape (Nr,)
   :param w: Wire index
   :type w: int
   :param Heh: Electron-hole Hamiltonian (output, modified in-place)
   :type Heh: ndarray (complex), shape (Nk, Nk)
   :param Hee: Electron-electron Hamiltonian (output, modified in-place)
   :type Hee: ndarray (complex), shape (Nk, Nk)
   :param Hhh: Hole-hole Hamiltonian (output, modified in-place)
   :type Hhh: ndarray (complex), shape (Nk, Nk)
   :param VC: Screened Coulomb arrays (output, modified in-place)
   :type VC: ndarray (float), shape (Nr, Nr, 3)
   :param E1D: 1D dielectric screening array (output, modified in-place)
   :type E1D: ndarray (float), shape (Nk, Nk)
   :param GamE: Electron diagonal dephasing rates (output, modified in-place)
   :type GamE: ndarray (float), shape (Nk,)
   :param GamH: Hole diagonal dephasing rates (output, modified in-place)
   :type GamH: ndarray (float), shape (Nk,)
   :param OffG: Off-diagonal dephasing arrays (output, modified in-place)
   :type OffG: ndarray (complex), shape (Nk, Nk, 3)
   :param Rsp: Spontaneous emission rates (output, modified in-place)
   :type Rsp: ndarray (float), shape (Nk,)

   :returns: All output arrays are modified in-place.
   :rtype: None

   .. rubric:: Notes

   The preparation sequence:
   1. Initialize all arrays to zero/defaults
   2. Extract carrier populations ne, nh from diagonal of C, D
   3. Calculate dipole coupling M^{eh} if optics enabled
   4. Calculate monopole coupling W^{ee}, W^{hh} if longitudinal field enabled
   5. Calculate screened Coulomb arrays VC, E1D
   6. Calculate Hamiltonian matrices H^{eh}, H^{ee}, H^{hh}
   7. Calculate diagonal dephasing γ_e, γ_h if enabled
   8. Calculate off-diagonal dephasing Γ^{off} if enabled
   9. Calculate spontaneous emission rates R_sp if enabled

   The Hamiltonian includes:
   - Single-particle energies (diagonal)
   - Light-matter coupling (via M^{eh})
   - Coulomb many-body effects (via VC)
   - Excitonic correlations (if _Excitons=True)

   Module flags control which effects are included:
   - _Optics: optical field coupling
   - _LF: longitudinal field effects
   - _FreePot: free potential effects
   - _Excitons: excitonic correlations
   - _DiagDph: diagonal dephasing
   - _OffDiagDph: off-diagonal dephasing
   - _Recomb: spontaneous recombination

   .. seealso::

      :py:obj:`CalcMeh`
          Dipole coupling matrix

      :py:obj:`CalcWnn`
          Monopole coupling matrix

      :py:obj:`CalcH`
          Hamiltonian calculation

      :py:obj:`CalcScreenedArrays`
          Screened Coulomb arrays

      :py:obj:`CalcGammaE`, :py:obj:`CalcGammaH`

      :py:obj:`OffDiagDephasing2`
          Off-diagonal dephasing

      :py:obj:`SpontEmission`
          Spontaneous emission rates


.. py:function:: CalcH(Meh, Wee, Whh, C, D, p, VC, Heh, Hee, Hhh)

   Calculate the Hamiltonian matrices for the semiconductor Bloch equations.

   Constructs the effective Hamiltonian matrices that appear in the SBEs,
   including single-particle energies, light-matter coupling, Coulomb many-body
   effects, and excitonic correlations.

   The Hamiltonians govern the coherent dynamics:
   - H^{eh}: electron-hole Hamiltonian (drives optical polarization)
   - H^{ee}: electron-electron Hamiltonian (drives electron coherence)
   - H^{hh}: hole-hole Hamiltonian (drives hole coherence)

   :param Meh: Dipole-field coupling matrix M^{eh}_{k_e,k_h}
   :type Meh: ndarray (complex), shape (Nk, Nk)
   :param Wee: Electron monopole-potential coupling W^{ee}_{k1,k2}
   :type Wee: ndarray (complex), shape (Nk, Nk)
   :param Whh: Hole monopole-potential coupling W^{hh}_{k1,k2}
   :type Whh: ndarray (complex), shape (Nk, Nk)
   :param C: Electron-electron coherence matrix
   :type C: ndarray (complex), shape (Nk, Nk)
   :param D: Hole-hole coherence matrix
   :type D: ndarray (complex), shape (Nk, Nk)
   :param p: Electron-hole coherence matrix (interband polarization)
   :type p: ndarray (complex), shape (Nk, Nk)
   :param VC: Screened Coulomb interaction arrays
   :type VC: ndarray (float), shape (Nr, Nr, 3)
   :param Heh: Output: electron-hole Hamiltonian (modified in-place)
   :type Heh: ndarray (complex), shape (Nk, Nk)
   :param Hee: Output: electron-electron Hamiltonian (modified in-place)
   :type Hee: ndarray (complex), shape (Nk, Nk)
   :param Hhh: Output: hole-hole Hamiltonian (modified in-place)
   :type Hhh: ndarray (complex), shape (Nk, Nk)

   :returns: Hamiltonians Heh, Hee, Hhh are modified in-place.
   :rtype: None

   .. rubric:: Notes

   The Hamiltonians are constructed as:

   H^{eh}_{k_e,k_h} = M^{eh}_{k_e,k_h} + Σ_q V(q) p^†_{k_e+q,k_h+q}

   H^{ee}_{k1,k2} = E_e(k1)δ_{k1,k2} + W^{ee}_{k1,k2}
                   - Σ_q V_ee(q) C^†_{k1+q,k2+q}
                   + Σ_k [V_ee(q)C_{k,k+q} - V_eh(q)D_{k+q,k}] (q = k1-k2)

   H^{hh}_{k1,k2} = E_h(k1)δ_{k1,k2} + W^{hh}_{k1,k2}
                   - Σ_q V_hh(q) D^†_{k1+q,k2+q}
                   + Σ_k [V_hh(q)D_{k,k+q} - V_eh(q)C_{k+q,k}] (q = k1-k2)

   where:
   - V(q) is the screened Coulomb interaction
   - q is momentum transfer
   - † denotes transpose (not conjugate transpose here)

   The excitonic terms (involving V and coherence matrices) are included
   only if _Excitons=True.

   If _LF=True (longitudinal field), off-diagonal Coulomb exchange terms
   are included. If _LF=False, only diagonal terms (k1=k2) are included,
   which is the Hartree-Fock approximation.

   The noq0 array excludes q=0 terms to avoid divergences in the Coulomb
   interaction.

   Loop ranges max(1-k1, 1-k2) to min(Nk-k1, Nk-k2) ensure that k+q
   stays within array bounds [1, Nk] in Fortran (or [0, Nk-1] in Python).

   .. seealso::

      :py:obj:`Preparation`
          Calls this function to set up Hamiltonians

      :py:obj:`CalcMeh`
          Calculates dipole coupling M^{eh}

      :py:obj:`CalcWnn`
          Calculates monopole coupling W^{nn}

      :py:obj:`dpdt`, :py:obj:`dCdt`, :py:obj:`dDdt`


.. py:function:: chiqw()

   Get the current linear optical susceptibility χ(ω).

   Returns the module-level variable _chiw which stores the linear
   susceptibility at the current frequency.

   :returns: **chi** -- Linear optical susceptibility χ(ω) (dimensionless).
   :rtype: complex

   .. rubric:: Notes

   This is a simple accessor function that returns the stored value.
   The susceptibility is calculated elsewhere (e.g., in QWChi1 or CalcXqw)
   and stored in _chiw.

   .. seealso::

      :py:obj:`getqc`
          Get critical momentum

      :py:obj:`QWChi1`
          Calculate linear susceptibility (qwoptics module)

      :py:obj:`CalcXqw`
          Calculate susceptibility at given (q,ω)


.. py:function:: getqc()

   Get the critical momentum q_c.

   Returns the module-level variable _qc which stores the critical
   momentum for some physical process (e.g., plasmon cutoff, screening length).

   :returns: **qc** -- Critical momentum q_c (rad/m).
   :rtype: float

   .. rubric:: Notes

   This is a simple accessor function that returns the stored value.
   The critical momentum is calculated elsewhere and stored in _qc.

   Physical interpretation depends on context:
   - Plasmon physics: momentum where plasmon dispersion changes character
   - Screening: inverse screening length (q_c ≈ 1/λ_screen)
   - Phase transitions: critical wave vector

   .. seealso::

      :py:obj:`chiqw`
          Get linear susceptibility


.. py:function:: QWArea()

   Get the quantum wire cross-sectional area.

   Returns the module-level variable _area which stores the quantum wire
   cross-sectional area.

   :returns: **area** -- Quantum wire cross-sectional area (m²).
   :rtype: float

   .. rubric:: Notes

   This is a simple accessor function. The area is set during initialization
   and represents the effective cross-sectional area of the quantum wire.

   The area affects:
   - Carrier density normalization
   - Optical transition strengths
   - Coulomb interaction strengths

   .. seealso::

      :py:obj:`ReadQWParams`
          Reads quantum wire parameters including area


.. py:function:: ShutOffOptics()

   Disable optical coupling in the SBE calculations.

   Sets the module-level flag _Optics to False, which disables the
   light-matter interaction terms in the Hamiltonian. This is useful
   for studying purely electronic dynamics without optical fields.

   :rtype: None

   .. rubric:: Notes

   When _Optics is False:
   - Dipole coupling matrix M^{eh} is not calculated
   - Only electronic Coulomb interactions remain
   - Useful for equilibration or dark dynamics

   To re-enable optics, set _Optics = True directly.

   .. seealso::

      :py:obj:`Preparation`
          Uses _Optics flag to conditionally calculate coupling

      :py:obj:`CalcMeh`
          Dipole coupling (only called if _Optics=True)


.. py:function:: ReadQWParams()

   Read quantum wire parameters from 'params/qw.params' file.

   Loads fundamental physical parameters of the quantum wire system from
   a parameter file and converts units where necessary. Sets module-level
   variables used throughout the SBE calculations.

   File Format
   -----------
   params/qw.params should contain one parameter per line:
       L       - Wire length (m)
       Delta0  - Wire thickness (m)
       gap     - Band gap (eV, converted to J)
       me      - Electron effective mass (units of me0)
       mh      - Hole effective mass (units of me0)
       HO      - Energy level separation (eV, converted to J)
       gam_e   - Electron dephasing rate (Hz)
       gam_h   - Hole dephasing rate (Hz)
       gam_eh  - Interband dephasing rate (Hz)
       epsr    - Relative permittivity (dimensionless)
       Oph     - Phonon energy (eV, converted to Hz)
       Gph     - Phonon damping rate (eV, converted to Hz)
       Edc     - DC electric field (V/m)
       jmax    - Output interval (time steps)
       ntmax   - Maximum time steps

   :returns: Module-level variables are set.
   :rtype: None

   .. rubric:: Notes

   Unit conversions performed:
   - gap: eV → J (multiply by e0)
   - me, mh: units of me0 → kg (multiply by me0)
   - HO: eV → J (multiply by e0)
   - Oph: eV → Hz (multiply by e0/hbar)
   - Gph: eV → Hz (multiply by e0/hbar)

   Module variables set:
   _L, _Delta0, _gap, _me, _mh, _HO, _gam_e, _gam_h, _gam_eh,
   _epsr, _Oph, _Gph, _Edc, _jmax, _ntmax

   .. seealso::

      :py:obj:`ReadMBParams`
          Read many-body physics flags


.. py:function:: ReadMBParams()

   Read many-body physics control flags from 'params/mb.params' file.

   Loads boolean flags that control which physical effects are included
   in the many-body semiconductor Bloch equation calculations. Also sets
   the Lorentzian delta function flag for numerical integration.

   File Format
   -----------
   params/mb.params should contain one flag per line (T/F or 1/0):
       Optics       - Include optical field coupling
       Excitons     - Include excitonic correlations
       EHs          - Include carrier-carrier scattering
       Screened     - Use screened Coulomb interaction
       Phonon       - Include phonon scattering
       DCTrans      - Include DC transport
       LF           - Include longitudinal field
       FreePot      - Include free potential
       DiagDph      - Include diagonal dephasing
       OffDiagDph   - Include off-diagonal dephasing
       Recomb       - Include spontaneous recombination
       PLSpec       - Calculate photoluminescence spectrum
       ignorewire   - Ignore wire effects
       Xqwparams    - Write susceptibility parameters
       LorentzDelta - Use Lorentzian delta function

   :returns: Module-level flags are set.
   :rtype: None

   .. rubric:: Notes

   These flags provide fine-grained control over the physics:

   - _Optics: Enable/disable light-matter interaction
   - _Excitons: Include excitonic Coulomb correlations in Hamiltonian
   - _EHs: Include carrier-carrier scattering (MBCE, MBCH)
   - _screened: Use screened vs bare Coulomb interaction
   - _Phonon: Include carrier-phonon scattering (MBPE, MBPH)
   - _DCTrans: Include DC transport and drift
   - _LF: Include longitudinal field (plasmons, screening)
   - _FreePot: Include free-carrier potential
   - _DiagDph: Momentum-dependent dephasing rates
   - _OffDiagDph: Off-diagonal dephasing (correlations)
   - _Recomb: Spontaneous electron-hole recombination
   - _PLSpec: Track photoluminescence
   - _ignorewire: Single-wire approximation
   - _Xqwparams: Write χ(q,ω) parameter file

   The LorentzDelta flag is passed to SetLorentzDelta in the coulomb module
   to control numerical delta function representation.

   .. seealso::

      :py:obj:`ReadQWParams`
          Read physical parameters

      :py:obj:`SetLorentzDelta`
          Set delta function representation (coulomb module)


.. py:function:: WriteSBEsData(n)

   Write SBE coherence matrices to backup files.

   Saves the current state of all coherence matrices (electron-hole,
   electron-electron, hole-hole) at three time steps to disk for backup
   or restart purposes.

   :param n: File index for output filenames (e.g., n=100 creates CC1.100.dat)
   :type n: int

   :returns: * *None* -- Data is written to files in 'dataQW/backup/' directory.
             * *Files Created*
             * *-------------*
             * *For each time step (1, 2, 3) and each matrix type (CC, DD, YY)* -- dataQW/backup/CC1.{n}.dat - Electron coherence, step 1
               dataQW/backup/CC2.{n}.dat - Electron coherence, step 2
               dataQW/backup/CC3.{n}.dat - Electron coherence, step 3
               dataQW/backup/DD1.{n}.dat - Hole coherence, step 1
               dataQW/backup/DD2.{n}.dat - Hole coherence, step 2
               dataQW/backup/DD3.{n}.dat - Hole coherence, step 3
               dataQW/backup/YY1.{n}.dat - e-h coherence, step 1
               dataQW/backup/YY2.{n}.dat - e-h coherence, step 2
               dataQW/backup/YY3.{n}.dat - e-h coherence, step 3
             * *Data Format*
             * *-----------*
             * *Each file contains complex values written as* -- real_part imaginary_part
             * *One matrix element per line, nested loops over wire, k2, k1.*

   .. rubric:: Notes

   The three time steps correspond to the leapfrog integration scheme:
   - Step 1: Previous time (t - dt)
   - Step 2: Current time (t)
   - Step 3: Next time (t + dt)

   Data is written for all wires and all momentum indices.

   File size scales as: Nwires × Nk × Nk × 2 (complex) × 3 (time steps) × 9 (matrices)

   .. seealso::

      :py:obj:`ReadSBEsData`
          Read coherence matrices from backup files

      :py:obj:`Checkin`, :py:obj:`Checkout`


.. py:function:: ReadSBEsData(Nt)

   Read SBE coherence matrices from backup files.

   Loads the saved state of all coherence matrices (electron-hole,
   electron-electron, hole-hole) at three time steps from disk for
   restart or analysis purposes.

   :param Nt: File index for input filenames (e.g., Nt=100 reads CC1.100.dat)
   :type Nt: int

   :returns: * *None* -- Module-level arrays _CC1, _CC2, _CC3, _DD1, _DD2, _DD3,
               _YY1, _YY2, _YY3 are updated.
             * *Files Read*
             * *----------*
             * *For each time step (1, 2, 3) and each matrix type (CC, DD, YY)* -- dataQW/backup/CC1.{Nt}.dat - Electron coherence, step 1
               dataQW/backup/CC2.{Nt}.dat - Electron coherence, step 2
               dataQW/backup/CC3.{Nt}.dat - Electron coherence, step 3
               dataQW/backup/DD1.{Nt}.dat - Hole coherence, step 1
               dataQW/backup/DD2.{Nt}.dat - Hole coherence, step 2
               dataQW/backup/DD3.{Nt}.dat - Hole coherence, step 3
               dataQW/backup/YY1.{Nt}.dat - e-h coherence, step 1
               dataQW/backup/YY2.{Nt}.dat - e-h coherence, step 2
               dataQW/backup/YY3.{Nt}.dat - e-h coherence, step 3
             * *Data Format*
             * *-----------*
             * *Each file contains complex values as* -- real_part imaginary_part
             * *One matrix element per line, nested loops over wire, k2, k1.*

   .. rubric:: Notes

   This function is used to restart simulations from a saved state.
   The data must match the current grid dimensions (Nk, Nwires).

   The three time steps enable continuation of the leapfrog integration
   without loss of temporal accuracy.

   After reading, the simulation can continue from time Nt·dt using
   the loaded coherence matrices.

   .. seealso::

      :py:obj:`WriteSBEsData`
          Write coherence matrices to backup files

      :py:obj:`Checkin`, :py:obj:`Checkout`


.. py:function:: Relaxation(ne, nh, VC, E1D, Rsp, dt, w, WriteFields)

   Apply phonon scattering and carrier-carrier relaxation to electron and hole populations.

   This function calculates the time evolution of carrier populations due to
   many-body scattering processes including:
   - Electron-electron scattering
   - Hole-hole scattering
   - Electron-hole scattering
   - Electron-phonon scattering
   - Hole-phonon scattering
   - Spontaneous electron-hole recombination

   The scattering rates are calculated using many-body perturbation theory
   and applied using an exact exponential solution to the rate equations.

   :param ne: Electron occupation numbers for each momentum state k.
              Modified in-place to apply relaxation effects.
   :type ne: ndarray (complex), shape (Nk,)
   :param nh: Hole occupation numbers for each momentum state k.
              Modified in-place to apply relaxation effects.
   :type nh: ndarray (complex), shape (Nk,)
   :param VC: Real-time screened Coulomb interaction arrays.
              VC[:,:,0] - electron-hole interaction
              VC[:,:,1] - electron-electron interaction
              VC[:,:,2] - hole-hole interaction
   :type VC: ndarray (float), shape (Nk, Nk, 3)
   :param E1D: Real-time 1D dielectric screening array used for carrier-photon
               coupling calculations.
   :type E1D: ndarray (float), shape (Nk, Nk)
   :param Rsp: Spontaneous emission rate for each momentum state (Hz).
               Used if _Recomb is True.
   :type Rsp: ndarray (float), shape (Nk,)
   :param dt: Time step for integration (seconds).
   :type dt: float
   :param w: Wire index identifying which quantum wire is being calculated.
   :type w: int
   :param WriteFields: If True, write scattering rates to output files via printITR.
   :type WriteFields: bool

   :returns: ne and nh are modified in-place.
   :rtype: None

   .. rubric:: Notes

   The carrier population evolution is governed by:

   dn_e/dt = W_in^e * (1 - n_e) - W_out^e * n_e
   dn_h/dt = W_in^h * (1 - n_h) - W_out^h * n_h

   where W_in and W_out are the in-scattering and out-scattering rates.

   This is solved exactly as:
   n(t+dt) = exp(-W*dt) * [(-1 + exp(W*dt) + n)*W_in + n*W_out] / W
   where W = W_in + W_out

   This exponential solution is more accurate than a simple Euler step and
   remains stable even for large time steps or scattering rates.

   If spontaneous recombination is enabled (_Recomb=True), an additional
   decay is applied:
   n_e(t+dt) = n_e * exp(-R_sp * n_h * dt)
   n_h(t+dt) = n_h * exp(-R_sp * n_e * dt)

   The scattering rates are calculated by RelaxationE and RelaxationH which
   call the many-body perturbation theory functions MBPE and MBPH from the
   phonons module.

   .. note::
       **Possible Modifications:** WinE, WoutE, WinH, WoutH could be inplace arguments.

   .. rubric:: Examples

   >>> ne = np.array([0.1, 0.2, 0.3], dtype=complex)
   >>> nh = np.array([0.1, 0.2, 0.3], dtype=complex)
   >>> VC = np.zeros((3, 3, 3))
   >>> E1D = np.zeros((3, 3))
   >>> Rsp = np.zeros(3)
   >>> Relaxation(ne, nh, VC, E1D, Rsp, 1e-15, 0, False)


.. py:function:: RelaxationE(ne, nh, VC, E1D)

   Calculate electron relaxation rates using many-body perturbation theory.

   Computes in-scattering (W_in) and out-scattering (W_out) rates for electrons
   due to:
   - Carrier-carrier scattering (electron-electron, electron-hole)
   - Carrier-phonon scattering (electron-LO phonon, electron-acoustic phonon)

   The rates are calculated using second-order Born approximation within the
   screened Hartree-Fock approximation, accounting for Pauli blocking factors.

   :param ne: Electron occupation numbers for each momentum state
   :type ne: ndarray (complex), shape (Nk,)
   :param nh: Hole occupation numbers for each momentum state
   :type nh: ndarray (complex), shape (Nk,)
   :param VC: Screened Coulomb interaction matrices
   :type VC: ndarray (float), shape (Nk, Nk, 3)
   :param E1D: One-dimensional dielectric screening array
   :type E1D: ndarray (float), shape (Nk, Nk)

   :returns: * **WinE** (*ndarray (float), shape (Nk,)*) -- In-scattering rate into each electron state (Hz).
               W_in^e(k) represents the rate of scattering INTO state k.
             * **WoutE** (*ndarray (float), shape (Nk,)*) -- Out-scattering rate from each electron state (Hz).
               W_out^e(k) represents the rate of scattering OUT OF state k.

   .. rubric:: Notes

   The scattering rates satisfy detailed balance and ensure proper
   thermalization. Pauli exclusion is enforced through (1-n_e) factors.

   Calls MBPE (Many-Body Perturbation theory for Electrons) from the phonons
   module, which implements the full quantum kinetic theory calculation.

   .. note::
       **Possible Modifications:** WinE and WoutE could be inplace arguments.

   .. seealso::

      :py:obj:`RelaxationH`
          Equivalent calculation for holes

      :py:obj:`MBPE`
          The underlying many-body calculation (in phonons module)


.. py:function:: RelaxationH(ne, nh, VC, E1D)

   Calculate hole relaxation rates using many-body perturbation theory.

   Computes in-scattering (W_in) and out-scattering (W_out) rates for holes
   due to:
   - Carrier-carrier scattering (hole-hole, hole-electron)
   - Carrier-phonon scattering (hole-LO phonon, hole-acoustic phonon)

   The rates are calculated using second-order Born approximation within the
   screened Hartree-Fock approximation, accounting for Pauli blocking factors.

   :param ne: Electron occupation numbers for each momentum state
   :type ne: ndarray (complex), shape (Nk,)
   :param nh: Hole occupation numbers for each momentum state
   :type nh: ndarray (complex), shape (Nk,)
   :param VC: Screened Coulomb interaction matrices
   :type VC: ndarray (float), shape (Nk, Nk, 3)
   :param E1D: One-dimensional dielectric screening array
   :type E1D: ndarray (float), shape (Nk, Nk)

   :returns: * **WinH** (*ndarray (float), shape (Nk,)*) -- In-scattering rate into each hole state (Hz).
               W_in^h(k) represents the rate of scattering INTO state k.
             * **WoutH** (*ndarray (float), shape (Nk,)*) -- Out-scattering rate from each hole state (Hz).
               W_out^h(k) represents the rate of scattering OUT OF state k.

   .. rubric:: Notes

   The scattering rates satisfy detailed balance and ensure proper
   thermalization. Pauli exclusion is enforced through (1-n_h) factors.

   Calls MBPH (Many-Body Perturbation theory for Holes) from the phonons
   module, which implements the full quantum kinetic theory calculation.

   .. note::
       **Possible Modifications:** WinH, WoutH could be inplace arguments.

   .. seealso::

      :py:obj:`RelaxationE`
          Equivalent calculation for electrons

      :py:obj:`MBPH`
          The underlying many-body calculation (in phonons module)


.. py:function:: dpdt(C, D, p, Heh, Hee, Hhh, GamE, GamH, OffP)

   Calculate the time derivative of the electron-hole coherence (interband polarization).

   Implements the Semiconductor Bloch Equation for the electron-hole coherence p,
   which represents the microscopic interband polarization that gives rise to the
   macroscopic optical polarization.

   The equation solved is:
   iℏ dp_{k_e,k_h}/dt =
       + Σ_k' H_{k_h,k'}^{hh} p_{k',k_e}           [hole Hamiltonian term]
       + Σ_k' H_{k_e,k'}^{ee} p_{k_h,k'}           [electron Hamiltonian term]
       - Σ_k' H_{k',k_h}^{eh†} C_{k',k_e}          [electron-electron correlation]
       - Σ_k' H_{k_e,k'}^{eh} D_{k',k_h}           [hole-hole correlation]
       + H_{k_e,k_h}^{eh}                          [light-matter coupling]
       - iℏ(γ_e(k_e) + γ_h(k_h)) p_{k_e,k_h}      [diagonal dephasing]
       + Γ_p^{off}(k_e,k_h)                        [off-diagonal dephasing]

   :param C: Electron-electron coherence matrix C_{k1,k2}.
             Diagonal elements C_{k,k} = n_e(k) are electron occupation numbers.
             Off-diagonal elements represent electron-electron quantum correlations.
   :type C: ndarray (complex), shape (Nk, Nk)
   :param D: Hole-hole coherence matrix D_{k1,k2}.
             Diagonal elements D_{k,k} = n_h(k) are hole occupation numbers.
             Off-diagonal elements represent hole-hole quantum correlations.
   :type D: ndarray (complex), shape (Nk, Nk)
   :param p: Electron-hole coherence matrix p_{k_e,k_h}.
             This is the microscopic polarization between electron state k_e
             and hole state k_h.
   :type p: ndarray (complex), shape (Nk, Nk)
   :param Heh: Electron-hole Hamiltonian matrix elements H_{k_e,k_h}^{eh}.
               Contains the light-matter coupling and screened Coulomb attraction.
   :type Heh: ndarray (complex), shape (Nk, Nk)
   :param Hee: Electron-electron Hamiltonian matrix elements H_{k1,k2}^{ee}.
               Contains kinetic energy (diagonal) and Coulomb repulsion (off-diagonal).
   :type Hee: ndarray (complex), shape (Nk, Nk)
   :param Hhh: Hole-hole Hamiltonian matrix elements H_{k1,k2}^{hh}.
               Contains kinetic energy (diagonal) and Coulomb repulsion (off-diagonal).
   :type Hhh: ndarray (complex), shape (Nk, Nk)
   :param GamE: Diagonal electron dephasing rate γ_e(k) for each momentum state (Hz).
                Due to carrier-carrier and carrier-phonon scattering.
   :type GamE: ndarray (float), shape (Nk,)
   :param GamH: Diagonal hole dephasing rate γ_h(k) for each momentum state (Hz).
                Due to carrier-carrier and carrier-phonon scattering.
   :type GamH: ndarray (float), shape (Nk,)
   :param OffP: Off-diagonal dephasing term Γ_p^{off}(k_e, k_h).
                Accounts for correlations in scattering processes.
   :type OffP: ndarray (complex), shape (Nk, Nk)

   :returns: **dpdt_result** -- Time derivative dp/dt of the electron-hole coherence (1/s).
   :rtype: ndarray (complex), shape (Nk, Nk)

   .. rubric:: Notes

   This is one of the three coupled Semiconductor Bloch Equations (SBEs).
   The equations for C (electrons) and D (holes) are given by dCdt and dDdt.

   The electron-hole coherence p is related to the macroscopic polarization P by:
   P(r,t) = Σ_{k_e,k_h} d_{cv} p_{k_e,k_h}(t) exp(i(k_e-k_h)·r)
   where d_{cv} is the interband dipole matrix element.

   Physical interpretation:
   - The Hamiltonian terms (Hee, Hhh) cause phase evolution
   - The correlation terms (via C, D) include Coulomb many-body effects
   - The Heh term couples to the external field (light)
   - Dephasing terms model irreversible decay processes

   Uses JIT compilation for performance with automatic fallback to pure Python.

   .. rubric:: References

   V. M. Axt and T. Kuhn, "Femtosecond spectroscopy in semiconductors:
   a key to coherences, correlations and quantum kinetics",
   Rep. Prog. Phys. 67, 433 (2004), Eqs. 2.15-2.19.

   .. seealso::

      :py:obj:`dCdt`
          Time derivative of electron-electron coherence

      :py:obj:`dDdt`
          Time derivative of hole-hole coherence


.. py:function:: dCdt(Cee, Dhh, Phe, Heh, Hee, Hhh, GamE, GamH, OffE)

   Calculate the time derivative of the electron-electron coherence.

   Implements the Semiconductor Bloch Equation for the electron-electron coherence C,
   which describes the quantum correlations between different electron momentum states.
   The diagonal elements C_{k,k} = n_e(k) are the electron occupation numbers, while
   off-diagonal elements represent quantum coherence between different momentum states.

   The equation solved is:
   iℏ dC_{k1,k2}/dt =
       + Σ_k' H_{k2,k'}^{ee} C_{k1,k'}          [k2 electron Hamiltonian]
       - Σ_k' H_{k',k1}^{ee} C_{k',k2}          [k1 electron Hamiltonian, commutator]
       + Σ_k' H_{k2,k'}^{eh} p_{k1,k'}^†        [e-h correlation via p†]
       - Σ_k' H_{k',k1}^{eh†} p_{k',k2}         [e-h correlation via Heh†]

   Note: Off-diagonal dephasing terms (commented out in original Fortran) are not included.

   :param Cee: Electron-electron coherence matrix C_{k1,k2}.
               Diagonal: C_{k,k} = n_e(k) is electron occupation.
               Off-diagonal: represents electron quantum correlations.
   :type Cee: ndarray (complex), shape (Nk, Nk)
   :param Dhh: Hole-hole coherence matrix D_{k1,k2} (not used in this equation,
               kept for interface compatibility).
   :type Dhh: ndarray (complex), shape (Nk, Nk)
   :param Phe: Electron-hole coherence matrix p_{k_e,k_h}.
               Note: Fortran uses Phe for p, but it's the same as p from dpdt.
   :type Phe: ndarray (complex), shape (Nk, Nk)
   :param Heh: Electron-hole Hamiltonian matrix H_{k_e,k_h}^{eh}.
   :type Heh: ndarray (complex), shape (Nk, Nk)
   :param Hee: Electron-electron Hamiltonian matrix H_{k1,k2}^{ee}.
               Diagonal: kinetic energy E_e(k).
               Off-diagonal: screened Coulomb repulsion between electrons.
   :type Hee: ndarray (complex), shape (Nk, Nk)
   :param Hhh: Hole-hole Hamiltonian (not used, kept for interface compatibility).
   :type Hhh: ndarray (complex), shape (Nk, Nk)
   :param GamE: Electron dephasing rates (not used in this equation).
   :type GamE: ndarray (float), shape (Nk,)
   :param GamH: Hole dephasing rates (not used, kept for interface compatibility).
   :type GamH: ndarray (float), shape (Nk,)
   :param OffE: Off-diagonal dephasing for electrons (not used in current implementation).
   :type OffE: ndarray (complex), shape (Nk, Nk)

   :returns: **dCdt_result** -- Time derivative dC/dt of electron-electron coherence (1/s).
   :rtype: ndarray (complex), shape (Nk, Nk)

   .. rubric:: Notes

   This equation governs the evolution of electron correlations, including:
   - Single-particle evolution via Hee (phase evolution, energy renormalization)
   - Coupling to the interband polarization p via Heh
   - Generation of correlations due to Coulomb interaction

   Physical significance:
   - Diagonal elements: rate of change of electron occupation n_e(k)
   - Off-diagonal: buildup/decay of electron quantum coherence
   - Couples to the p equation via Heh, forming a closed system

   The off-diagonal dephasing terms involving GamE are commented out in the
   original Fortran code and not implemented here. If needed, they would add:
   - iℏ·I_{k1≠k2}·(γ_e(k1) + γ_e(k2))·C_{k1,k2}
   where I_{k1≠k2} is the anti-identity matrix.

   Uses JIT compilation for performance with automatic fallback.

   .. rubric:: References

   V. M. Axt and T. Kuhn, Rep. Prog. Phys. 67, 433 (2004), Eqs. 2.15-2.19.

   .. seealso::

      :py:obj:`dpdt`
          Time derivative of electron-hole coherence (interband polarization)

      :py:obj:`dDdt`
          Time derivative of hole-hole coherence


.. py:function:: dDdt(Cee, Dhh, Phe, Heh, Hee, Hhh, GamE, GamH, OffH)

   Calculate the time derivative of the hole-hole coherence.

   Implements the Semiconductor Bloch Equation for the hole-hole coherence D,
   which describes the quantum correlations between different hole momentum states.
   The diagonal elements D_{k,k} = n_h(k) are the hole occupation numbers, while
   off-diagonal elements represent quantum coherence between different momentum states.

   The equation solved is:
   iℏ dD_{k1,k2}/dt =
       + Σ_k' H_{k2,k'}^{hh} D_{k1,k'}          [k2 hole Hamiltonian]
       - Σ_k' H_{k',k1}^{hh} D_{k',k2}          [k1 hole Hamiltonian, commutator]
       + Σ_k' H_{k',k2}^{eh†} p_{k',k1}^†       [e-h correlation via p†]
       - Σ_k' H_{k1,k'}^{eh†} p_{k2,k'}         [e-h correlation via Heh†]

   Note: Off-diagonal dephasing terms (commented out in original Fortran) are not included.

   :param Cee: Electron-electron coherence (not used, kept for interface compatibility).
   :type Cee: ndarray (complex), shape (Nk, Nk)
   :param Dhh: Hole-hole coherence matrix D_{k1,k2}.
               Diagonal: D_{k,k} = n_h(k) is hole occupation.
               Off-diagonal: represents hole quantum correlations.
   :type Dhh: ndarray (complex), shape (Nk, Nk)
   :param Phe: Electron-hole coherence matrix p_{k_e,k_h}.
   :type Phe: ndarray (complex), shape (Nk, Nk)
   :param Heh: Electron-hole Hamiltonian matrix H_{k_e,k_h}^{eh}.
   :type Heh: ndarray (complex), shape (Nk, Nk)
   :param Hee: Electron-electron Hamiltonian (not used, kept for interface compatibility).
   :type Hee: ndarray (complex), shape (Nk, Nk)
   :param Hhh: Hole-hole Hamiltonian matrix H_{k1,k2}^{hh}.
               Diagonal: kinetic energy E_h(k).
               Off-diagonal: screened Coulomb repulsion between holes.
   :type Hhh: ndarray (complex), shape (Nk, Nk)
   :param GamE: Electron dephasing rates (not used, kept for interface compatibility).
   :type GamE: ndarray (float), shape (Nk,)
   :param GamH: Hole dephasing rates (not used in this equation).
   :type GamH: ndarray (float), shape (Nk,)
   :param OffH: Off-diagonal dephasing for holes (not used in current implementation).
   :type OffH: ndarray (complex), shape (Nk, Nk)

   :returns: **dDdt_result** -- Time derivative dD/dt of hole-hole coherence (1/s).
   :rtype: ndarray (complex), shape (Nk, Nk)

   .. rubric:: Notes

   This equation is analogous to the electron equation (dCdt), but for holes.
   It governs the evolution of hole correlations, including:
   - Single-particle evolution via Hhh (phase evolution, energy renormalization)
   - Coupling to the interband polarization p via Heh
   - Generation of correlations due to Coulomb interaction

   Physical significance:
   - Diagonal elements: rate of change of hole occupation n_h(k)
   - Off-diagonal: buildup/decay of hole quantum coherence
   - Couples to the p equation via Heh, forming a closed system with dpdt and dCdt

   The three equations (dpdt, dCdt, dDdt) form the complete set of Semiconductor
   Bloch Equations that must be solved self-consistently. Together they describe:
   - Optical response (via p)
   - Carrier dynamics (via diagonal C and D)
   - Quantum correlations and many-body effects (via off-diagonal C and D)

   The off-diagonal dephasing terms involving GamH are commented out in the
   original Fortran code and not implemented here. If needed, they would add:
   - iℏ·I_{k1≠k2}·(γ_h(k1) + γ_h(k2))·D_{k1,k2}
   where I_{k1≠k2} is the anti-identity matrix.

   Uses JIT compilation for performance with automatic fallback.

   .. rubric:: References

   V. M. Axt and T. Kuhn, "Femtosecond spectroscopy in semiconductors",
   Rep. Prog. Phys. 67, 433 (2004), Eqs. 2.15-2.19.

   .. seealso::

      :py:obj:`dpdt`
          Time derivative of electron-hole coherence

      :py:obj:`dCdt`
          Time derivative of electron-electron coherence


.. py:function:: write_statistics(w, dt, ne2, nh2, Re, Rh)

   Write statistical data to file.

   Writes detailed carrier statistics including velocities, densities,
   energies, temperatures, and currents.

   :param w: Wire index
   :type w: int
   :param dt: Time step
   :type dt: float
   :param ne2: Electron occupation numbers
   :type ne2: ndarray
   :param nh2: Hole occupation numbers
   :type nh2: ndarray
   :param Re: Electron charge density
   :type Re: ndarray
   :param Rh: Hole charge density
   :type Rh: ndarray


.. py:function:: CalcMeh(Ex, Ey, Ez, w, Meh)

   Calculate the dipole-field coupling matrix for electron-hole transitions.

   Computes the matrix elements of the light-matter interaction Hamiltonian
   M_{k_e,k_h}^{eh} which couples the electric field to the interband polarization.
   This is the driving term in the optical Bloch equations that causes absorption
   and emission of photons.

   The matrix elements are calculated as:
   M_{k_e,k_h}^{eh} = -η_{int} [X_{cv}(k_e,k_h)·E_x(q) + Y_{cv}(k_e,k_h)·E_y(q)·y_w(w)
                                 + Z_{cv}(k_e,k_h)·E_z(q)·(-1)^w]

   where:
   - η_{int} is the electron-hole spatial overlap integral
   - X_{cv}, Y_{cv}, Z_{cv} are the momentum-dependent dipole matrix elements
   - q = k_e - k_h is the momentum transfer (photon momentum)
   - y_w(w) is a wire-dependent weighting factor
   - (-1)^w alternates sign for different wires

   :param Ex: X-component of electric field in momentum space (Fourier transformed).
              Indexed by momentum q.
   :type Ex: ndarray (complex), shape (Nr,)
   :param Ey: Y-component of electric field in momentum space.
              Multiplied by wire-dependent factor yw(w).
   :type Ey: ndarray (complex), shape (Nr,)
   :param Ez: Z-component of electric field in momentum space.
              Multiplied by (-1)^w for wire parity.
   :type Ez: ndarray (complex), shape (Nr,)
   :param w: Wire index. Used to determine y-polarization weight yw(w) and
             z-polarization sign (-1)^w.
   :type w: int
   :param Meh: Output matrix for dipole-field coupling (modified in-place).
   :type Meh: ndarray (complex), shape (Nk, Nk)

   :returns: Meh is modified in-place.
   :rtype: None

   .. rubric:: Notes

   This function is central to the optical response of the semiconductor.
   The coupling matrix Meh appears in the SBE for the electron-hole coherence p:

   iℏ dp/dt = ... + M^{eh}_{k_e,k_h} + ...

   The momentum index q = k_e - k_h represents the photon momentum absorbed/emitted
   in a transition. This is obtained via the index mapping array kkp(ke, kh).

   The spatial overlap integral η_{int} (ehint) accounts for the finite size
   of the quantum wire and reduces the coupling strength compared to the
   bare dipole moment.

   The factors yw(w) and (-1)^w allow for different polarization responses
   in different wires, enabling modeling of wire arrays with varying orientations.

   Important: The comment in the Fortran code notes that previously there was
   confusion about whether to use FFT or IFFT for the fields, and that q should
   be ke - kh. This has been corrected in the current implementation.

   .. seealso::

      :py:obj:`Xcv`, :py:obj:`Ycv`, :py:obj:`Zcv`

      :py:obj:`dpdt`
          The SBE that uses this coupling matrix


.. py:function:: CalcWnn(q0, Vr, Wnn)

   Calculate the monopole-potential coupling matrix for carrier-carrier interactions.

   Computes the matrix elements of the free-charge potential coupling
   W_{k1,k2}^{nn} which represents the effect of long-range Coulomb potential
   from free carriers on the carrier states. This contributes to the longitudinal
   field effects in the SBEs.

   The matrix elements are:
   W_{k1,k2}^{nn} = q_0 · V_r(q)

   where:
   - q_0 is the charge of the carrier (+e for holes, -e for electrons)
   - V_r(q) is the electric potential from free charge in momentum space
   - q = k1 - k2 is the momentum transfer

   :param q0: Free charge of carrier species:
              +e0 (positive) for holes
              -e0 (negative) for electrons
              where e0 is the elementary charge (C)
   :type q0: float
   :param Vr: Electric potential from free charge in momentum space (Fourier transformed).
              This is the long-range Coulomb potential V(r) = ρ(r)/(4πε_0ε_r) in q-space.
   :type Vr: ndarray (complex), shape (Nr,)
   :param Wnn: Output monopole-potential coupling matrix (modified in-place).
   :type Wnn: ndarray (complex), shape (Nk, Nk)

   :returns: Wnn is modified in-place.
   :rtype: None

   .. rubric:: Notes

   This function calculates the coupling between carriers and the self-consistent
   mean-field potential arising from the carrier density distribution. It's used
   when the longitudinal field (_LF) is enabled to include plasmon effects and
   long-range Coulomb interactions.

   The coupling matrix Wnn would appear in the SBEs as additional diagonal terms:
   - For electrons: H_{k1,k2}^{ee} += W_{k1,k2}^{ee} (with q0 = -e0)
   - For holes: H_{k1,k2}^{hh} += W_{k1,k2}^{hh} (with q0 = +e0)

   The momentum transfer q = k1 - k2 is obtained via the index mapping kkp(k1, k2).

   Note: This function is currently not actively used in the CalcH function (it's
   commented out in the Fortran code), but is kept for potential future use or
   for studying longitudinal field effects.

   Important: As noted in the Fortran comments, there was previously confusion
   about FFT vs IFFT conventions, which has been corrected. The q index now
   properly represents q = k1 - k2.

   .. seealso::

      :py:obj:`CalcMeh`
          Dipole-field coupling matrix for optical transitions

      :py:obj:`CalcH`
          Hamiltonian calculation (where Wnn would be used)


.. py:function:: CalcXqw(iq, w, kr, fe, fh, Ee, Eh, gap, area, game, gamh, dcv)

   Calculate the linear optical susceptibility χ(q,ω) for a quantum wire.

   Computes the frequency and momentum-dependent linear susceptibility using
   the Lindhard formula generalized to include population inversion (fe, fh)
   and dephasing rates (game, gamh). This describes the linear optical response
   of the quantum wire system to an external electromagnetic field.

   The susceptibility includes contributions from both absorption (fc < fv) and
   stimulated emission (fc > fv) processes at each momentum state.

   Physics
   -------
   The linear susceptibility is calculated as:

   χ(q,ω) = Σ_k [N·|d_cv|²/ε₀] × {
       (f_c(k) - f_v(k+q)) / [E_v(k+q) - E_c(k) - ℏω - iℏ(γ_h(k+q) + γ_e(k))]
     + (f_v(k) - f_c(k+q)) / [E_c(k+q) - E_v(k) - ℏω - iℏ(γ_e(k+q) + γ_h(k))]
   }

   where:
   - N = 2·Δk/(2π·A) is the density of states normalization
   - d_cv is the interband dipole matrix element
   - f_c, f_v are electron (conduction) and hole (valence) occupation numbers
   - E_c, E_v are conduction and valence band energies
   - γ_e, γ_h are electron and hole dephasing rates
   - q is the photon momentum (momentum transfer)
   - ω is the photon frequency

   The first term represents transitions where an electron in state k absorbs
   a photon with momentum q, while the second term represents the time-reversed
   process (stimulated emission).

   :param iq: Momentum index for photon momentum q. Can be positive, negative, or zero.
              The actual momentum is q = iq * (kr[1] - kr[0]).
   :type iq: int
   :param w: Angular frequency ω (rad/s) of the electromagnetic field.
   :type w: float
   :param kr: Momentum grid (rad/m) for carrier states.
   :type kr: ndarray (float), shape (Nk,)
   :param fe: Electron occupation numbers f_e(k) at each momentum state.
              Range: [0, 1] for physical occupation.
   :type fe: ndarray (float), shape (Nk,)
   :param fh: Hole occupation numbers f_h(k) at each momentum state.
              Range: [0, 1] for physical occupation.
   :type fh: ndarray (float), shape (Nk,)
   :param Ee: Electron energies E_e(k) relative to conduction band edge (J).
   :type Ee: ndarray (float), shape (Nk,)
   :param Eh: Hole energies E_h(k) relative to valence band edge (J).
   :type Eh: ndarray (float), shape (Nk,)
   :param gap: Band gap energy E_g (J).
   :type gap: float
   :param area: Cross-sectional area A of the quantum wire (m²).
   :type area: float
   :param game: Electron dephasing rates γ_e(k) (1/s).
   :type game: ndarray (float), shape (Nk,)
   :param gamh: Hole dephasing rates γ_h(k) (1/s).
   :type gamh: ndarray (float), shape (Nk,)
   :param dcv: Interband dipole matrix element d_cv (C·m).
   :type dcv: complex

   :returns: **Xqw** -- Linear optical susceptibility χ(q,ω) (dimensionless).
             Real part: related to refractive index change Δn.
             Imaginary part: related to absorption/gain coefficient α.
   :rtype: complex

   .. rubric:: Notes

   The summation range is carefully chosen to avoid out-of-bounds array access:
   - For iq ≥ 0: kmin = 0, kmax = Nk - 1 - iq (Python indexing)
   - For iq < 0: kmin = -iq, kmax = Nk - 1 (Python indexing)

   This ensures that both k and k+iq remain within [0, Nk-1].

   The minimum dephasing is set to 1e-4 eV to prevent numerical instabilities
   from vanishing denominators.

   The valence band occupations are f_v = 1 - f_h, as holes represent absence
   of electrons in the valence band.

   The imaginary part Im[χ(q,ω)] > 0 indicates absorption, while Im[χ] < 0
   indicates gain (population inversion). The real part Re[χ(q,ω)] is related
   to dispersion via the Kramers-Kronig relations.

   Physical applications:
   - Optical absorption/gain spectra
   - Refractive index changes
   - Electromagnetically induced transparency (EIT)
   - Population inversion and lasing conditions
   - Exciton resonances in quantum wires

   .. rubric:: References

   H. Haug and S. W. Koch, "Quantum Theory of the Optical and Electronic
   Properties of Semiconductors", 5th ed., World Scientific (2009), Ch. 13.

   .. seealso::

      :py:obj:`QWChi1`
          Related function for calculating χ from coulomb module

      :py:obj:`RecordXqw`
          Function that records χ(q,ω) data to files

      :py:obj:`GetChi1Dqw`
          1D susceptibility calculation from coulomb module

   .. rubric:: Examples

   >>> # Calculate susceptibility at q=0, near band edge
   >>> iq = 0
   >>> w = gap / hbar  # Frequency at band gap
   >>> chi = CalcXqw(iq, w, kr, fe, fh, Ee, Eh, gap, area, game, gamh, dcv)
   >>> alpha = 2 * w / c * np.imag(chi)  # Absorption coefficient


.. py:function:: RecordEpsLqw(Qr, fe, fh, Ee, Eh, gap, area, gamE, gamH, dcv, ind)

   Record the longitudinal dielectric function ε_L(q,ω) and susceptibility χ_L(q,ω).

   Calculates and saves to file the frequency and momentum-dependent longitudinal
   dielectric function and linear susceptibility for a quantum wire. This provides
   a complete characterization of the collective excitations (plasmons) and
   optical response of the system.

   The longitudinal dielectric function describes the screening of longitudinal
   electric fields (parallel to the wire axis) and determines the dispersion
   relation of plasmon modes via ε_L(q,ω) = 0.

   :param Qr: Momentum grid (rad/m) for the output. Determines the q-resolution.
   :type Qr: ndarray (float), shape (Nq,)
   :param fe: Electron occupation numbers f_e(k).
   :type fe: ndarray (float), shape (Nk,)
   :param fh: Hole occupation numbers f_h(k).
   :type fh: ndarray (float), shape (Nk,)
   :param Ee: Electron energies E_e(k) (J).
   :type Ee: ndarray (float), shape (Nk,)
   :param Eh: Hole energies E_h(k) (J).
   :type Eh: ndarray (float), shape (Nk,)
   :param gap: Band gap energy E_g (J).
   :type gap: float
   :param area: Wire cross-sectional area A (m²).
   :type area: float
   :param gamE: Electron dephasing rates γ_e(k) (1/s).
   :type gamE: ndarray (float), shape (Nk,)
   :param gamH: Hole dephasing rates γ_h(k) (1/s).
   :type gamH: ndarray (float), shape (Nk,)
   :param dcv: Interband dipole matrix element d_cv (C·m).
   :type dcv: complex
   :param ind: File index for output filename generation.
   :type ind: int

   :returns: * *None* -- Data is written to files in 'dataQW/Wire/Xqw/' directory.
             * *Files Created*
             * *-------------*
             * **dataQW/Wire/Xqw/EpsL.{ind** (*06d}.dat :*) -- Contains Re[ε_L(q,ω) - 1] and Im[ε_L(q,ω)] in two columns.
               Data is organized as nested loops: outer loop over ω, inner loop over q.
               Total size: (nwmax+1) × (Nq+1) rows, 2 columns.
             * **dataQW/Wire/Xqw/ChiL.{ind** (*06d}.dat :*) -- Contains Re[χ_L(q,ω)] and Im[χ_L(q,ω)] in two columns.
               Same structure as EpsL file.
             * *dataQW/Wire/Xqw/EpsL.params* -- Parameter file (written only once when _Xqwparams is True).
               Contains grid information: Nq, Nw, Δω, Δq, frequency range, momentum range.

   .. rubric:: Notes

   The frequency grid is automatically generated:
   - ω_max = 2·E_g/ℏ (twice the band gap frequency)
   - Δω = ω_max / 2000
   - Number of points: 2001 (from ω=0 to ω_max)

   The momentum grid uses the input kr spacing:
   - Δq = kr[1] - kr[0]
   - q ranges from 0 to Nk·Δq

   The 1D carrier density is calculated as:
   n_1D = Σ(f_e + f_h) / (2·L)
   but is currently overridden to a fixed value n_1D = 1.5×10⁸ m⁻¹ for testing.

   Two different methods are used:
   1. GetEps1Dqw: Analytical RPA dielectric function (from coulomb module)
   2. GetChi1Dqw: Numerical susceptibility from actual occupations (from coulomb module)

   The longitudinal dielectric function is related to susceptibility by:
   ε_L(q,ω) = 1 + V(q)·χ_L(q,ω)
   where V(q) is the 1D Coulomb interaction.

   Physical applications:
   - Plasmon dispersion relations (zeros of ε_L)
   - Collective oscillation frequencies
   - Screening length determination
   - Optical absorption with many-body effects
   - Carrier density diagnostics

   The data format allows easy plotting as 2D contour plots with:
   - X-axis: momentum q
   - Y-axis: frequency ω
   - Color: Re[ε_L] or Im[ε_L]

   .. rubric:: References

   G. D. Mahan, "Many-Particle Physics", 3rd ed., Springer (2000), Ch. 5.

   .. seealso::

      :py:obj:`CalcXqw`
          Calculate linear susceptibility at single (q,ω) point

      :py:obj:`GetEps1Dqw`
          Analytical 1D dielectric function (coulomb module)

      :py:obj:`GetChi1Dqw`
          Numerical 1D susceptibility (coulomb module)

      :py:obj:`RecordXqw`
          Similar function for recording χ(q,ω) using CalcXqw

   .. rubric:: Examples

   >>> # Record dielectric function at time step 1000
   >>> RecordEpsLqw(kr, fe, fh, Ee, Eh, gap, area, gamE, gamH, dcv, ind=1000)
   >>> # Files created: EpsL.001000.dat, ChiL.001000.dat


.. py:function:: RecordXqw(kr, fe, fh, Ee, Eh, gap, area, game, gamh, dcv, ind)

   Record the linear optical susceptibility χ(q,ω) using CalcXqw.

   Calculates and saves to file the frequency and momentum-dependent linear
   susceptibility χ(q,ω) for a quantum wire using the direct CalcXqw function.
   This provides the complete optical response spectrum including absorption,
   gain, and dispersion.

   Unlike RecordEpsLqw which uses analytical RPA functions, this uses the
   CalcXqw function that directly sums over carrier occupations, providing
   a more accurate representation when populations deviate from equilibrium.

   :param kr: Momentum grid (rad/m) for carrier states.
   :type kr: ndarray (float), shape (Nk,)
   :param fe: Electron occupation numbers f_e(k).
   :type fe: ndarray (float), shape (Nk,)
   :param fh: Hole occupation numbers f_h(k).
   :type fh: ndarray (float), shape (Nk,)
   :param Ee: Electron energies E_e(k) (J).
   :type Ee: ndarray (float), shape (Nk,)
   :param Eh: Hole energies E_h(k) (J).
   :type Eh: ndarray (float), shape (Nk,)
   :param gap: Band gap energy E_g (J).
   :type gap: float
   :param area: Wire cross-sectional area A (m²).
   :type area: float
   :param game: Electron dephasing rates γ_e(k) (1/s).
   :type game: ndarray (float), shape (Nk,)
   :param gamh: Hole dephasing rates γ_h(k) (1/s).
   :type gamh: ndarray (float), shape (Nk,)
   :param dcv: Interband dipole matrix element d_cv (C·m).
   :type dcv: complex
   :param ind: File index for output filename generation.
   :type ind: int

   :returns: * *None* -- Data is written to files in 'dataQW/Wire/Xqw/' directory.
             * *Files Created*
             * *-------------*
             * **dataQW/Wire/Xqw/Xqw.{ind** (*06d}.dat :*) -- Contains three columns: ω (rad/s), Re[χ(q,ω)], Im[χ(q,ω)].
               Data is organized as nested loops: outer loop over ω, inner loop over q.
               Total size: (nwmax+1) × (Nk+1) rows, 3 columns.
             * *dataQW/Wire/Xqw/Xqw.params* -- Parameter file (written only once when _Xqwparams is True).
               Contains grid information: Nq, Nw, Δω, Δq, frequency range, momentum range.

   .. rubric:: Notes

   The frequency grid is automatically generated:
   - ω_max = 2·E_g/ℏ (twice the band gap frequency)
   - Δω = ω_max / 2000
   - Number of points: 2001 (from ω=0 to ω_max)

   The momentum grid uses indices iq from 0 to Nk:
   - q ranges from 0 to Nk·Δkr
   - Δkr = kr[1] - kr[0]

   The output format with three columns (ω, Re[χ], Im[χ]) facilitates plotting
   and analysis of the frequency-dependent response at each momentum.

   Computation time scales as O(Nω × Nq × Nk), which can be substantial for
   large grids. For Nω=2001, Nq=101, Nk=101, this requires ~20M function calls
   to CalcXqw.

   Physical applications:
   - Optical absorption/gain spectra vs. carrier density
   - Refractive index changes (via Kramers-Kronig)
   - Identification of excitonic resonances
   - Population inversion and lasing thresholds
   - Non-equilibrium optical response

   The inclusion of ω in the first column makes it easy to plot susceptibility
   vs. frequency for any given q value.

   Differences from RecordEpsLqw:
   - Uses CalcXqw (direct sum over occupations) vs. GetChi1Dqw (equilibrium)
   - Output format: 3 columns (ω, Re, Im) vs. 2 columns (Re, Im)
   - Single file vs. separate files for ε and χ

   .. seealso::

      :py:obj:`CalcXqw`
          Function used to calculate χ(q,ω)

      :py:obj:`RecordEpsLqw`
          Similar function using analytical RPA methods

      :py:obj:`QWChi1`
          Related susceptibility calculation from qwoptics module

   .. rubric:: Examples

   >>> # Record susceptibility after excitation at time step 1000
   >>> RecordXqw(kr, fe, fh, Ee, Eh, gap, area, game, gamh, dcv, ind=1000)
   >>> # File created: Xqw.001000.dat


.. py:function:: GetArrays(x, qx, kx)

   Initialize spatial and momentum arrays for the SBE solver.

   Sets up the fundamental coordinate and momentum space grids used throughout
   the semiconductor Bloch equation calculations. This includes:
   - Real-space positions x for field propagation
   - Momentum space qx for Fourier-transformed fields
   - Carrier momentum grid kx (offset by half grid spacing)

   The carrier momentum grid kx is offset by 0.5 grid spacing to avoid having
   a state exactly at k=0, which simplifies boundary conditions and symmetry.

   :param x: Real-space position array (m). Modified in-place.
   :type x: ndarray (float), shape (Nr,)
   :param qx: Momentum array for fields (rad/m). Modified in-place.
   :type qx: ndarray (float), shape (Nr,)
   :param kx: Carrier momentum array (rad/m). Modified in-place.
   :type kx: ndarray (float), shape (Nk,)

   :returns: Arrays x, qx, kx are modified in-place.
             Module-level variables _NK0 and _NQ0 are set.
   :rtype: None

   .. rubric:: Notes

   The carrier momentum grid kx is centered at k=0 with the formula:
   kx[k] = Δkr × (-dnk + k - 0.5)  for k = 0, 1, ..., Nk-1

   where dnk = (Nk-1)/2, so that:
   - kx is antisymmetric about the origin
   - The grid spacing is Δkr
   - No state sits exactly at k=0 (offset by 0.5)

   The field momentum array qx is obtained from GetKArray and then:
   1. Shifted by cshift(qx, Nr/2) to center the zero-frequency component
   2. The first element is negated: qx[0] = -qx[0]

   Module-level variables set:
   - _NK0: Index where kx ≈ 0 (central carrier momentum index)
   - _NQ0: Index where qx = 0 (zero field momentum index)

   These zero indices are crucial for the kkp mapping array and for properly
   handling momentum conservation in scattering processes.

   The real-space array x spans the domain [-L, L] (total length 2L).
   The momentum array qx corresponds to this spatial grid via FFT convention.

   .. seealso::

      :py:obj:`GetSpaceArray`
          Generate real-space position array (from usefulsubs)

      :py:obj:`GetKArray`
          Generate momentum array for FFT (from usefulsubs)

      :py:obj:`GetArray0Index`
          Find index where array value is closest to zero (from usefulsubs)

      :py:obj:`MakeKKP`
          Create momentum difference mapping using NQ0

   .. rubric:: Examples

   >>> x = np.zeros(Nr)
   >>> qx = np.zeros(Nr)
   >>> kx = np.zeros(Nk)
   >>> GetArrays(x, qx, kx)
   >>> # Now x, qx, kx are initialized and _NK0, _NQ0 are set


.. py:function:: MakeKKP()

   Create the momentum difference mapping array kkp.

   Constructs the index mapping array kkp[k, kp] that gives the field momentum
   index for the momentum difference q = k - kp. This is essential for evaluating
   matrix elements of Fourier-transformed fields in the semiconductor Bloch equations.

   The array satisfies:
   qx[kkp[k, kp]] ≈ kr[k] - kr[kp]

   where qx is the field momentum array and kr is the carrier momentum array.

   :returns: The module-level array _kkp is allocated and filled.
   :rtype: None

   .. rubric:: Notes

   The mapping is calculated as:
   kkp[k, kp] = round[(kr[k] - kr[kp]) / Δkr] + NQ0

   where:
   - kr[k] - kr[kp] is the momentum difference
   - Division by Δkr converts to grid index units
   - round() maps to nearest grid point
   - NQ0 is added to shift from centered indexing to array indexing

   This mapping is used extensively in the SBE Hamiltonian terms:
   - Dipole-field coupling: M_{k_e,k_h} ∝ E(q) where q = k_e - k_h
   - Coulomb interaction: V_{k1,k2} ∝ V(q) where q = k1 - k2
   - Screening: ε(q) where q is momentum transfer

   Physical interpretation:
   When an electron scatters from state kp to state k, the momentum transfer
   is q = k - kp. This momentum must be provided by (or absorbed into) a photon,
   phonon, or other field mode. The kkp array provides the field mode index
   corresponding to this momentum transfer.

   Memory: For Nk=101, kkp requires ~10,000 integers (~40 KB).

   The Fortran code includes commented-out bounds checking:
   - if(kr[0] <= q <= kr[Nr]): only map if q is in range
   - if(kkp < 1 or kkp > Nr): set kkp = 0 for out-of-range

   These checks are omitted in the current implementation, assuming that the
   momentum grids are compatible and all differences are in range.

   Global Variables Modified
   -------------------------
   _kkp : ndarray (int), shape (Nk, Nk)
       Momentum difference mapping array. Allocated and filled.

   .. seealso::

      :py:obj:`GetArrays`
          Must be called first to set _NQ0

      :py:obj:`CalcMeh`
          Uses kkp for dipole-field coupling

      :py:obj:`CalcWnn`
          Uses kkp for potential coupling

      :py:obj:`kindex`
          Convert continuous momentum to grid index

   .. rubric:: Examples

   >>> GetArrays(x, qx, kx)  # Initialize arrays first
   >>> MakeKKP()  # Now create mapping
   >>> # Access field at momentum difference k - kp:
   >>> q_idx = _kkp[k, kp]
   >>> field_at_q = Ex[q_idx]


.. py:function:: kindex(k)

   Convert a continuous momentum value to the nearest grid index.

   Maps a continuous momentum k (in rad/m) to the corresponding index in the
   carrier momentum array kr. Useful for finding which discrete momentum state
   corresponds to a given continuous momentum value.

   :param k: Momentum value (rad/m).
   :type k: float

   :returns: **idx** -- Index in the kr array closest to the given momentum k.
   :rtype: int

   .. rubric:: Notes

   The mapping formula is:
   idx = round(k / Δkr) + NK0

   where:
   - k / Δkr converts momentum to grid index units
   - round() finds nearest grid point
   - NK0 is added to shift from centered indexing to array indexing

   This function is the inverse of:
   k ≈ (idx - NK0) × Δkr

   Caution: No bounds checking is performed. If k is outside the range of the
   kr array, the returned index may be out of bounds [0, Nk-1].

   Physical applications:
   - Finding initial state indices for given carrier momenta
   - Mapping continuous momentum distributions to discrete grid
   - Identifying states near a specific momentum (e.g., Fermi surface)

   .. seealso::

      :py:obj:`GetArrays`
          Sets up kr array and NK0

      :py:obj:`MakeKKP`
          Creates momentum difference mapping

   .. rubric:: Examples

   >>> # Find index for momentum near Fermi momentum
   >>> k_fermi = 1e8  # rad/m
   >>> idx = kindex(k_fermi)
   >>> k_actual = _kr[idx]  # Actual momentum on grid


.. py:function:: InitializeSBE(q, rr, r0, Emaxxx, lam, Nw, QW)

   Initialize the SBE module for calculations.

   This function allocates all module-level arrays, initializes them to zero,
   calculates material constants, and sets up all subsystems required for
   solving the Semiconductor Bloch Equations. It must be called before any
   SBE calculations are performed.

   The initialization process includes:
   1. Reading physical parameters from parameter files
   2. Calculating momentum and spatial grids
   3. Allocating coherence matrices (YY, CC, DD) for all wires
   4. Computing material constants (dipole moment, screening lengths, etc.)
   5. Initializing subsystems (Coulomb, Phonons, DC field, Dephasing, Emission)
   6. Setting up output files
   7. Calculating initial carrier distributions

   :param q: Momentum array for fields (rad/m). Used for compatibility but not
             directly modified in this function.
   :type q: ndarray (float), shape (Nq,)
   :param rr: Spatial position array for propagation space (m). Used to determine
              the quantum wire window within the propagation domain.
   :type rr: ndarray (float), shape (Nr_prop,)
   :param r0: Reference position offset (m). Used to locate the quantum wire
              within the propagation spatial grid.
   :type r0: float
   :param Emaxxx: Initial peak electric field magnitude (V/m). Used to determine
                  when to activate quantum wire calculations (via _wireoff flag).
   :type Emaxxx: float
   :param lam: Laser wavelength (m). Used for calculating linear susceptibility
               and initializing QW optics.
   :type lam: float
   :param Nw: Number of quantum wires in the simulation. Each wire has its own
              set of coherence matrices (YY, CC, DD).
   :type Nw: int
   :param QW: Flag to enable quantum wire calculations. If False, only minimal
              initialization is performed.
   :type QW: bool

   :returns: All module-level arrays and variables are set.
   :rtype: None

   .. rubric:: Notes

   The function performs extensive setup:

   **Grid Calculation:**
   - Maximum momentum: kmax = sqrt(1.2 * gap * 2 * me / hbar²)
   - Momentum spacing: dkr = 2π / (2*L)
   - Number of k-points: Nk = floor(kmax/dkr) * 2 + 1, then Nk = Nk - 1
   - Number of r-points: Nr = Nk * 2

   **Material Constants:**
   - Dipole moment: dcv = sqrt((e0*hbar)² / (6*me0*gap) * (me0/me - 1))
   - Electron confinement: alphae = sqrt(me * HO) / hbar
   - Hole confinement: alphah = sqrt(mh * HO) / hbar
   - Overlap integral: ehint = sqrt(2 * alphae * alphah / (alphae² + alphah²))
   - Critical momentum: qc = 2 * alphae * alphah / (alphae + alphah)
   - Wire area: area = sqrt(2π) / sqrt(alphae² + alphah²) * Delta0

   **Initial Carrier Distribution:**
   - Electrons and holes initialized to Fermi-Dirac distribution at
     energy E = gap/2 (half the band gap)
   - All off-diagonal coherence elements set to zero

   **Subsystem Initialization:**
   - InitializeQWOptics: Sets up optical coupling matrices
   - InitializeCoulomb: Calculates screened Coulomb interactions
   - InitializePhonons: Sets up phonon scattering rates
   - InitializeDC: Prepares DC field transport calculations
   - InitializeDephasing: Sets up dephasing rate calculations
   - InitializeEmission: (if _Recomb=True) Sets up spontaneous emission

   **Output Files:**
   For each wire w:
   - dataQW/info.{w:02d}.t.dat - General information
   - dataQW/EP.{w:02d}.t.dat - Energy and polarization data
   - dataQW/XQ.{w:02d}.t.dat - Susceptibility data
   - dataQW/Etr.dat - Transition energies
   - dataQW/Wire/info/ETHz.t.dat - THz field data

   **Special Modes:**
   If _OBE=True (Optical Bloch Equations only):
   - Disables all many-body effects
   - Only optical coupling remains active
   - Useful for testing basic optical response

   **File I/O:**
   - Reads parameters from 'params/qw.params' and 'params/mb.params'
   - Optionally reads DC field from 'DC.txt' if _ReadDC=True
   - Writes initial arrays using WriteIt function

   The function sets the module-level flag _start to indicate that
   initialization is complete, allowing other functions to check if
   the module has been properly initialized.

   .. seealso::

      :py:obj:`ReadQWParams`
          Read quantum wire physical parameters

      :py:obj:`ReadMBParams`
          Read many-body physics flags

      :py:obj:`GetArrays`
          Set up spatial and momentum grids

      :py:obj:`MakeKKP`
          Create momentum difference mapping

      :py:obj:`InitializeQWOptics`
          Initialize optical coupling

      :py:obj:`InitializeCoulomb`
          Initialize Coulomb interactions

      :py:obj:`InitializePhonons`
          Initialize phonon scattering

      :py:obj:`InitializeDC`
          Initialize DC field transport

      :py:obj:`InitializeDephasing`
          Initialize dephasing rates

      :py:obj:`InitializeEmission`
          Initialize spontaneous emission

      :py:obj:`QWChi1`
          Calculate linear susceptibility

      :py:obj:`RecordXqw`
          Record susceptibility data

   .. rubric:: Examples

   >>> import numpy as np
   >>> q = np.linspace(-1e8, 1e8, 201)
   >>> rr = np.linspace(-500e-9, 500e-9, 201)
   >>> InitializeSBE(q, rr, r0=0.0, Emaxxx=1e6, lam=800e-9, Nw=1, QW=True)
   >>> # Module is now initialized and ready for SBE calculations


.. py:function:: SBECalculator(Ex, Ey, Ez, Vr, dt, Px, Py, Pz, Re, Rh, WriteFields, w)

   Solve the 1D Semiconductor Bloch Equations and calculate source terms.

   This is the main function that solves the Semiconductor Bloch Equations
   for the w'th quantum wire and calculates the source terms Px, Py, Pz, Re,
   and Rh that are used in Maxwell's equations for field propagation.

   The function performs a leapfrog time integration of the SBEs, including:
   - Electron-hole coherence (interband polarization) p
   - Electron-electron coherence C
   - Hole-hole coherence D
   - Many-body effects (Coulomb, phonons, dephasing)
   - DC transport effects
   - Charge density calculations

   :param Ex: X-component electric field in QW momentum space (modified in-place).
              The field is FFT'd to real space for calculations, then FFT'd back.
   :type Ex: ndarray (complex), shape (Nr,)
   :param Ey: Y-component electric field in QW momentum space (modified in-place).
   :type Ey: ndarray (complex), shape (Nr,)
   :param Ez: Z-component electric field in QW momentum space (modified in-place).
   :type Ez: ndarray (complex), shape (Nr,)
   :param Vr: Free charge potential (voltage) in QW momentum space (modified in-place).
   :type Vr: ndarray (complex), shape (Nr,)
   :param dt: Time step (s).
   :type dt: float
   :param Px: X-component QW polarization field (output, modified in-place).
   :type Px: ndarray (complex), shape (Nr,)
   :param Py: Y-component QW polarization field (output, modified in-place).
   :type Py: ndarray (complex), shape (Nr,)
   :param Pz: Z-component QW polarization field (output, modified in-place).
   :type Pz: ndarray (complex), shape (Nr,)
   :param Re: QW electron charge density (output, modified in-place).
   :type Re: ndarray (complex), shape (Nr,)
   :param Rh: QW hole charge density (output, modified in-place).
   :type Rh: ndarray (complex), shape (Nr,)
   :param WriteFields: Flag to record SBE solutions and write output files this time step.
   :type WriteFields: bool
   :param w: Quantum wire index (which wire to calculate for).
   :type w: int

   :returns: All output arrays (Px, Py, Pz, Re, Rh, Ex, Ey, Ez, Vr) are modified in-place.
   :rtype: None

   .. rubric:: Notes

   The function implements the following sequence:

   1. **Initialize source terms** to zero
   2. **Checkout coherence matrices** from module storage for wire w
   3. **Prepare arrays** (Hamiltonians, screening, dephasing) via Preparation()
   4. **Calculate time derivatives** dp/dt, dC/dt, dD/dt
   5. **Time evolve** using leapfrog scheme: X3 = X1 + dX/dt * 2*dt
   6. **Apply relaxation** (phonon/carrier-carrier scattering) if enabled
   7. **Apply DC transport** if enabled
   8. **Normalize populations** to ensure charge neutrality
   9. **Reshuffle** for stability (convert leapfrog to implicit Euler)
   10. **Calculate polarization** Px, Py, Pz from coherence p
   11. **Calculate charge densities** Re, Rh if longitudinal field enabled
   12. **Write output files** if WriteFields is True
   13. **Checkin updated matrices** to module storage

   **Time Integration Scheme:**
   The leapfrog scheme is:
   - X3 = X1 + dX/dt * 2*dt  (2nd order accurate but potentially unstable)
   - Then reshuffled to: X2 = (X1 + X3) / 2  (1st order accurate but stable)

   This converts the 2nd-order accurate (but unstable) leapfrog scheme into
   a 1st-order accurate (but stable) implicit Euler scheme.

   **Charge Neutrality:**
   The populations are normalized so that:
   - Total electrons = Total holes = (sum(ne) + sum(nh)) / 2
   This ensures charge neutrality in the system.

   **FFT Operations:**
   The electric fields and polarizations are FFT'd to real space for
   calculations, then FFT'd back to momentum space. This is done because:
   - Some calculations are easier in real space
   - The output is written in real space (at center point Nr/2)

   **Output Files:**
   If WriteFields is True:
   - WriteSBESolns: Writes coherence matrices and populations
   - WriteDephasing: Writes dephasing rates (if DiagDph enabled)
   - File (uw+w): Writes statistics (velocities, densities, energies, etc.)
   - File (2*uw+w): Writes fields and polarizations at center point

   **Module Variables Used:**
   - _YY1, _YY2, _YY3: Electron-hole coherence matrices
   - _CC1, _CC2, _CC3: Electron-electron coherence matrices
   - _DD1, _DD2, _DD3: Hole-hole coherence matrices
   - _Id, _Ia: Identity and anti-identity matrices
   - _kr, _Ee, _Eh: Momentum and energy arrays
   - _r, _Qr: Spatial and momentum arrays
   - _I0: Drift current array
   - _xxx, _jjj: Time step counters
   - _gap, _me, _mh, _L, _area, _ehint: Material parameters
   - _Optics, _EHs, _Phonon, _DCTrans, _LF, _DiagDph: Physics flags

   .. seealso::

      :py:obj:`Preparation`
          Prepare Hamiltonians and arrays for SBE time step

      :py:obj:`dpdt`
          Calculate time derivative of electron-hole coherence

      :py:obj:`dCdt`
          Calculate time derivative of electron-electron coherence

      :py:obj:`dDdt`
          Calculate time derivative of hole-hole coherence

      :py:obj:`Relaxation`
          Apply phonon and carrier-carrier scattering

      :py:obj:`Transport`
          Apply DC field transport effects

      :py:obj:`QWPolarization3`
          Calculate polarization from coherence

      :py:obj:`QWRho5`
          Calculate charge densities from coherence

      :py:obj:`Checkout`
          Retrieve coherence matrices from module storage

      :py:obj:`Checkin`
          Store coherence matrices to module storage


.. py:class:: SBESolver(q, rr, r0, Emaxxx, lam, Nw, QW, backend='auto')

   Class-based SBE solver. Encapsulates all module-level state as instance
   attributes, enabling multiple independent quantum wire simulations.


   .. py:attribute:: L
      :value: 1e-07



   .. py:attribute:: Delta0
      :value: 5e-09



   .. py:attribute:: gap
      :value: 2.4032649509999997e-19



   .. py:attribute:: me


   .. py:attribute:: mh


   .. py:attribute:: HO
      :value: 1.602176634e-20



   .. py:attribute:: gam_e
      :value: 1000000000000.0



   .. py:attribute:: gam_h
      :value: 1000000000000.0



   .. py:attribute:: gam_eh
      :value: 1000000000000.0



   .. py:attribute:: wL
      :value: 0.0



   .. py:attribute:: epsr
      :value: 9.1



   .. py:attribute:: Oph


   .. py:attribute:: Gph


   .. py:attribute:: Edc
      :value: 0.0



   .. py:attribute:: Optics
      :value: True



   .. py:attribute:: Excitons
      :value: True



   .. py:attribute:: EHs
      :value: True



   .. py:attribute:: Screened
      :value: True



   .. py:attribute:: Phonon
      :value: True



   .. py:attribute:: DCTrans
      :value: False



   .. py:attribute:: LF
      :value: True



   .. py:attribute:: FreePot
      :value: False



   .. py:attribute:: DiagDph
      :value: True



   .. py:attribute:: OffDiagDph
      :value: True



   .. py:attribute:: OBE
      :value: False



   .. py:attribute:: Recomb
      :value: False



   .. py:attribute:: ReadDC
      :value: False



   .. py:attribute:: PLSpec
      :value: False



   .. py:attribute:: ignorewire
      :value: False



   .. py:attribute:: debug1
      :value: False



   .. py:attribute:: Xqwparams
      :value: False



   .. py:attribute:: Id
      :value: None



   .. py:attribute:: Ia
      :value: None



   .. py:attribute:: Ee
      :value: None



   .. py:attribute:: Eh
      :value: None



   .. py:attribute:: r
      :value: None



   .. py:attribute:: Qr
      :value: None



   .. py:attribute:: QE
      :value: None



   .. py:attribute:: kr
      :value: None



   .. py:attribute:: EPEnergy
      :value: 0.0



   .. py:attribute:: EPEnergyW
      :value: 0.0



   .. py:attribute:: I0
      :value: None



   .. py:attribute:: ErI0
      :value: None



   .. py:attribute:: hw


   .. py:attribute:: PLS


   .. py:attribute:: dkr
      :value: 0.0



   .. py:attribute:: dr
      :value: 0.0



   .. py:attribute:: Nr1
      :value: 0



   .. py:attribute:: Nr2
      :value: 0



   .. py:attribute:: start
      :value: False



   .. py:attribute:: qw
      :value: None



   .. py:attribute:: Nr
      :value: 0



   .. py:attribute:: Nk
      :value: 0



   .. py:attribute:: small
      :value: 1e-200



   .. py:attribute:: NK0
      :value: 0



   .. py:attribute:: NQ0
      :value: 0



   .. py:attribute:: nqq
      :value: 0



   .. py:attribute:: nqq10
      :value: 0



   .. py:attribute:: kkp
      :value: None



   .. py:attribute:: dcv
      :value: None



   .. py:attribute:: ehint
      :value: 1.0



   .. py:attribute:: Emax0
      :value: 0.0



   .. py:attribute:: alphae
      :value: 0.0



   .. py:attribute:: alphah
      :value: 0.0



   .. py:attribute:: qc
      :value: 0.0



   .. py:attribute:: area
      :value: 1e-16



   .. py:attribute:: t
      :value: 0.0



   .. py:attribute:: wph
      :value: 0.0



   .. py:attribute:: chiw
      :value: 0j



   .. py:attribute:: uw
      :value: 820



   .. py:attribute:: vhh0
      :value: 0.0



   .. py:attribute:: ETHz
      :value: 0.0



   .. py:attribute:: wireoff
      :value: True



   .. py:attribute:: xxx
      :value: 1



   .. py:attribute:: jjj
      :value: 1



   .. py:attribute:: jmax
      :value: 1000



   .. py:attribute:: ntmax
      :value: 100000



   .. py:attribute:: file_972
      :value: None



   .. py:attribute:: file_973
      :value: None



   .. py:attribute:: Nw


   .. py:attribute:: YY1


   .. py:attribute:: YY2


   .. py:attribute:: YY3


   .. py:attribute:: CC1


   .. py:attribute:: CC2


   .. py:attribute:: CC3


   .. py:attribute:: DD1


   .. py:attribute:: DD2


   .. py:attribute:: DD3


   .. py:method:: kindex(k)

      Convert continuous momentum to nearest grid index.



   .. py:method:: calc_Xqw(iq, w, kr, fe, fh, Ee, Eh, gap, area, game, gamh, dcv)

      Calculate linear optical susceptibility chi(q,w).



   .. py:method:: chiqw()

      Return linear optical susceptibility.



   .. py:method:: getqc()

      Return critical momentum.



   .. py:method:: QWArea()

      Return quantum wire cross-sectional area.



   .. py:method:: ShutOffOptics()

      Disable optical coupling.



   .. py:method:: write_sbes_data(n)

      Write coherence matrices to backup files.



   .. py:method:: read_sbes_data(Nt)

      Read coherence matrices from backup files.



   .. py:method:: QWCalculator(Exx, Eyy, Ezz, Vrr, rr, q, dt, w, Pxx, Pyy, Pzz, Rho, DoQWP, DoQWDl)

      Time-evolve quantum wire sources for Maxwell's equations.



   .. py:method:: close()

      Close open file handles.



   .. py:method:: __del__()


.. py:function:: InitializeSBE(q, rr, r0, Emaxxx, lam, Nw, QW)

   Backward-compatible shim — creates a default SBESolver instance.


.. py:function:: QWCalculator(Exx, Eyy, Ezz, Vrr, rr, q, dt, w, Pxx, Pyy, Pzz, Rho, DoQWP, DoQWDl)

   Backward-compatible shim — delegates to _default_solver.


.. py:function:: chiqw()

   Backward-compatible shim.


.. py:function:: getqc()

   Backward-compatible shim.


.. py:function:: QWArea()

   Backward-compatible shim.


.. py:function:: ShutOffOptics()

   Backward-compatible shim.


.. py:function:: WriteSBEsData(n)

   Backward-compatible shim.


.. py:function:: ReadSBEsData(Nt)

   Backward-compatible shim.


